<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>时光小栈 on 时光小栈</title>
        <link>/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Fri, 29 Nov 2019 15:43:49 CST</updated>
        
        <item>
            <title>hi3516 mpp sample_venc</title>
            <link>/hardware/hisilicon/hi3516-mpp-sample_venc/</link>
            <pubDate>Fri, 29 Nov 2019 15:43:49 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-sample_venc/</guid>
            <description>&lt;p&gt;本文链接：&lt;a href=&#34;https://blog.csdn.net/QHZM72/article/details/80609140&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/QHZM72/article/details/80609140&lt;/a&gt;&lt;br /&gt;
不多说了，直接上源码+分析......&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/******************************************************************************
  A simple program of Hisilicon HI3531 video encode implementation.
  Copyright (C), 2010-2011, Hisilicon Tech. Co., Ltd.
 ******************************************************************************
    Modification:  2011-2 Created
******************************************************************************/
#ifdef __cplusplus 	//__cplusplus是C++中定义的一个宏，如果这个宏被定义，说明这个程序是C++程序
#if __cplusplus 	//那么如果C++程序要调用C实现的函数或库等，则需要使用extern &amp;quot;C&amp;quot;{ 
extern &amp;quot;C&amp;quot;{		//这是实现C++调用C库或函数的一种手段，原因是因为C++和C语言的编译器不同导致
#endif
#endif /* End of #ifdef __cplusplus */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

#include &amp;quot;sample_comm.h&amp;quot;

//VIDEO_NORM_E gs_enNorm = VIDEO_ENCODING_MODE_PAL;   //PAL(德国制@25帧)，中国主要也是使用这种。
VIDEO_NORM_E gs_enNorm = VIDEO_ENCODING_MODE_NTSC;    //NTSC(美国制@30帧)，(来自网络)更换N制的镜头后，VI VO的属性都要设置成N制的
//VIDEO_NORM_E gs_enNorm = VIDEO_ENCODING_MODE_AUTO, 
//VIDEO_NORM_E gs_enNorm = VIDEO_ENCODING_MODE_BUTT;


#ifdef hi3518ev201

HI_U32 g_u32BlkCnt = 4;
#endif

#ifdef hi3518ev200

HI_U32 g_u32BlkCnt = 4;  //啥意思？块大小？

#endif

#ifdef hi3516cv200

HI_U32 g_u32BlkCnt = 10;

#endif

																  //2018.06.02
/******************************************************************************
* function : show usage  			                   介绍使用方法 
******************************************************************************/
void SAMPLE_VENC_Usage(char *sPrgNm)    //接收的字符串为argv[0]
{
    printf(&amp;quot;Usage : %s &amp;lt;index&amp;gt;\n&amp;quot;, sPrgNm); //string program number
    printf(&amp;quot;index:\n&amp;quot;);
    printf(&amp;quot;\t 0) 1*1080p H264 + 1*VGA H264.\n&amp;quot;);
    printf(&amp;quot;\t 1) 1*1080p MJPEG encode + 1*1080p jpeg.\n&amp;quot;);
    printf(&amp;quot;\t 2) low delay encode(only vi-vpss online).\n&amp;quot;);
    printf(&amp;quot;\t 3) roi background framerate.\n&amp;quot;);
    printf(&amp;quot;\t 4) Thumbnail of 1*1080p jpeg.\n&amp;quot;);
#ifndef hi3518ev201
	printf(&amp;quot;\t 5) svc-t H264\n&amp;quot;);
#endif
    return;
}
																  //2018.06.02
/******************************************************************************
* function : to process abnormal case         处理异常情况，譬如中断处理、结束进程                                      
******************************************************************************/
void SAMPLE_VENC_HandleSig(HI_S32 signo)
{
    if (SIGINT == signo || SIGTERM == signo)
    {
        SAMPLE_COMM_ISP_Stop();
        SAMPLE_COMM_SYS_Exit();
        printf(&amp;quot;\033[0;31mprogram termination abnormally!\033[0;39m\n&amp;quot;);
    }
    exit(-1);
}
																  //2018.06.02
/******************************************************************************
* function : to process abnormal case - the case of stream venc     编码异常处理
******************************************************************************/
void SAMPLE_VENC_StreamHandleSig(HI_S32 signo)
{

    if (SIGINT == signo || SIGTSTP == signo)
    {
        SAMPLE_COMM_ISP_Stop();
        SAMPLE_COMM_SYS_Exit();
        printf(&amp;quot;\033[0;31mprogram exit abnormally!\033[0;39m\n&amp;quot;);
    }

    exit(0);
}

																  //2018.06.02
/******************************************************************************
* function :  H.264@1080p@30fps+H.264@VGA@30fps			支持同时编码2路码流
******************************************************************************/
HI_S32 SAMPLE_VENC_1080P_CLASSIC(HI_VOID)  /* 最重要的函数 */
{
    PAYLOAD_TYPE_E enPayLoad[3]= {PT_H264, PT_H264,PT_H264}; /*枚举类型、数组、3路码流的编码类型 */
    PIC_SIZE_E enSize[3] = {PIC_HD1080, PIC_VGA,PIC_QVGA}; /* 3路码流的分辨率 */
	HI_U32 u32Profile = 0;
	
    VB_CONF_S stVbConf;  /* 视频缓存池 */
    SAMPLE_VI_CONFIG_S stViConfig = {0};

    VPSS_GRP VpssGrp;  /* 这部分是和VPSS相关的 */ 
    VPSS_CHN VpssChn;
    VPSS_GRP_ATTR_S stVpssGrpAttr;
    VPSS_CHN_ATTR_S stVpssChnAttr;
    VPSS_CHN_MODE_S stVpssChnMode;
    
    VENC_CHN VencChn;
    SAMPLE_RC_E enRcMode= SAMPLE_RC_CBR; /* 恒定比特率方式进行编码 */ /* H.264编码方式有好种，这是其中一种 */
	
    HI_S32 s32ChnNum=0;
    
    HI_S32 s32Ret = HI_SUCCESS;
    HI_U32 u32BlkSize;
    SIZE_S stSize;
    char c;


    /******************************************
     step  1: init sys variable      	## 1.这里的sys指“mpp”，指的是初始化mpp的变量 ##
    ******************************************/
    memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S)); /* 刷新缓存池*/
    
	SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);  /* 获取SENSOR,在这个函数里面添加 */
    if (PIC_HD1080 == enSize[0])
    {
        enSize[1] = PIC_VGA;
		s32ChnNum = 2;
    }
    else if (PIC_HD720 == enSize[0])  /* 走的是这条路 */
    {
        enSize[1] = PIC_VGA;  	        /* 通过对VI原始图像(720P)进行裁剪、缩放成这两路(VGA、QVGA) */			
		enSize[2] = PIC_QVGA;
		s32ChnNum = 3; 		/* 这里的3表示3路码流，分别是720P、VGA、QVGA */
    }
    else
    {
        printf(&amp;quot;not support this sensor\n&amp;quot;);
        return HI_FAILURE;
    }
#ifdef hi3518ev201
	s32ChnNum = 1;
#endif
	printf(&amp;quot;s32ChnNum = %d\n&amp;quot;,s32ChnNum);

    stVbConf.u32MaxPoolCnt = 128;   /* 缓存池的数量为128 */

    /*video buffer*/
	if(s32ChnNum &amp;gt;= 1)  /* 走这条通道 */
    {	/* “enSize”表示传进去是多少像素的，“SAMPLE_PIXEL_FORMAT”表示像素格式(RGB888或RGB565) 
    	“SAMPLE_SYS_ALIGN_WIDTH”表示对齐*/
	    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
	                enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 2)
    {
	    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
	                enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[1].u32BlkCnt =g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 3) /*  */
    {
		u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize[2], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
		stVbConf.astCommPool[2].u32BlkSize = u32BlkSize;
		stVbConf.astCommPool[2].u32BlkCnt = g_u32BlkCnt;
    }

    /******************************************
     step 2: mpp system init.  		## 2.初始化MMP系统 ##
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
        goto END_VENC_1080P_CLASSIC_0;		/* 倒影式处理，MPP初始化失败直接结束编码 */
    }

    /******************************************
     step 3: start vi dev &amp;amp; chn to capture	## 3.启动输入和通道捕获 ##
    ******************************************/
    
    stViConfig.enViMode   = SENSOR_TYPE; 
    stViConfig.enRotate   = ROTATE_NONE;  /* 图像不旋转 */
    stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO; /* 图像制式标准 */
    stViConfig.enViChnSet = VI_CHN_SET_NORMAL;  /*  */
    stViConfig.enWDRMode  = WDR_MODE_NONE; /* 不支持宽动态 */
    s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_1;
    }
    
    /******************************************
     step 4: start vpss and vi bind vpss	##4：启动视频处理和绑定视频输入(通道)##
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[0], &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_1;
    }
	if(s32ChnNum &amp;gt;= 1)   /* 走这个通道 */
	{
		VpssGrp = 0;
	    stVpssGrpAttr.u32MaxW = stSize.u32Width;
	    stVpssGrpAttr.u32MaxH = stSize.u32Height;
	    stVpssGrpAttr.bIeEn = HI_FALSE;
	    stVpssGrpAttr.bNrEn = HI_TRUE;
	    stVpssGrpAttr.bHistEn = HI_FALSE;
	    stVpssGrpAttr.bDciEn = HI_FALSE;
	    stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
	    stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
		
	    s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_2;
	    }

	    s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_3;
	    }

		VpssChn = 0;
	    stVpssChnMode.enChnMode      = VPSS_CHN_MODE_USER;
	    stVpssChnMode.bDouble        = HI_FALSE;
	    stVpssChnMode.enPixelFormat  = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	    stVpssChnMode.u32Width       = stSize.u32Width;
	    stVpssChnMode.u32Height      = stSize.u32Height;
	    stVpssChnMode.enCompressMode = COMPRESS_MODE_SEG;
	    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
	    stVpssChnAttr.s32SrcFrameRate = -1;
	    stVpssChnAttr.s32DstFrameRate = -1;
	    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_4;
	    }
	}

	if(s32ChnNum &amp;gt;= 2)
	{
		s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[1], &amp;amp;stSize);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_4;
	    }
	    VpssChn = 1;
	    stVpssChnMode.enChnMode       = VPSS_CHN_MODE_USER;
	    stVpssChnMode.bDouble         = HI_FALSE;
	    stVpssChnMode.enPixelFormat   = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	    stVpssChnMode.u32Width        = stSize.u32Width;
	    stVpssChnMode.u32Height       = stSize.u32Height;
	    stVpssChnMode.enCompressMode  = COMPRESS_MODE_SEG;
	    stVpssChnAttr.s32SrcFrameRate = -1;
	    stVpssChnAttr.s32DstFrameRate = -1;
	    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_4;
	    }
	}
	

	if(s32ChnNum &amp;gt;= 3)
	{	
		s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[2], &amp;amp;stSize);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_4;
	    }
		VpssChn = 2;
		stVpssChnMode.enChnMode 	= VPSS_CHN_MODE_USER;
		stVpssChnMode.bDouble		= HI_FALSE;
		stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
		stVpssChnMode.u32Width		= stSize.u32Width;
		stVpssChnMode.u32Height 	= stSize.u32Height;
		stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
		
		stVpssChnAttr.s32SrcFrameRate = -1;
		stVpssChnAttr.s32DstFrameRate = -1;
		
		s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
		if (HI_SUCCESS != s32Ret)
		{
			SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
			goto END_VENC_1080P_CLASSIC_4;
		}
	}
    /******************************************
     step 5: start stream venc  # 可以在这里叠加OSD信息，并研究哪些码流 #
    ******************************************/
    /*** HD1080P **/
    printf(&amp;quot;\t c) cbr.\n&amp;quot;);
    printf(&amp;quot;\t v) vbr.\n&amp;quot;);
    printf(&amp;quot;\t f) fixQp\n&amp;quot;);
    printf(&amp;quot;please input choose rc mode!\n&amp;quot;);
    c = (char)getchar();
    switch(c)
    {
        case &#39;c&#39;:
            enRcMode = SAMPLE_RC_CBR;
            break;
        case &#39;v&#39;:
            enRcMode = SAMPLE_RC_VBR;
            break;
        case &#39;f&#39;:
            enRcMode = SAMPLE_RC_FIXQP;
            break;
        default:
            printf(&amp;quot;rc mode! is invaild!\n&amp;quot;);
            goto END_VENC_1080P_CLASSIC_4;
    }

	/*** enSize[0] ***/
	if(s32ChnNum &amp;gt;= 1)		
	{
	    VpssGrp = 0;
	    VpssChn = 0; 	/* 媒体处理通道0 */
	    VencChn = 0;	/* 编码通道0 */
		
		/* 通道0、负载类型PT_H264、NTSC制式、PIC_HD1080()、恒定比特率编码、0 */
	    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[0],\
	                                   gs_enNorm, enSize[0], enRcMode,u32Profile);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }

	    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }
	}

	/*** enSize[1] **/
	if(s32ChnNum &amp;gt;= 2)		
	{
	    VpssChn = 1; /* 媒体处理通道1 */
	    VencChn = 1; /* 编码通道1 */
	    &amp;lt;span style=&amp;quot;background-color:rgb(255,102,102);&amp;quot;&amp;gt;/* 通道1、负载类型PT_H264、NTSC制式、PIC_VGA(640 * 480)、恒定比特率编码、0 */&amp;lt;/span&amp;gt;
	    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[1], \
	                                    gs_enNorm, enSize[1], enRcMode,u32Profile);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }

	    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }
	}
	/*** enSize[2] **/
	if(s32ChnNum &amp;gt;= 3)			
	{
	    VpssChn = 2; /* 媒体处理通道2 */
	    VencChn = 2; /* 编码通道2 */
	   &amp;lt;span style=&amp;quot;color:#ff6666;&amp;quot;&amp;gt; /* 通道2、负载类型PT_H264、NTSC制式、PIC_QVGA(320 * 240)、恒定比特率编码、0 */&amp;lt;/span&amp;gt;
	    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[2], \
	                                    gs_enNorm, enSize[2], enRcMode,u32Profile);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }

	    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_1080P_CLASSIC_5;
	    }
	}
    /******************************************
     step 6: stream venc process -- get stream, then save it to file. 
 #在step 5中只是得到了一段裸流，并把这段码流保存为一个文件#
******************************************/ s32Ret = SAMPLE_COMM_VENC_StartGetStream(s32ChnNum); if (HI_SUCCESS != s32Ret) { SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;); goto END_VENC_1080P_CLASSIC_5; } printf(&amp;quot;please press twice ENTER to exit this sample\n&amp;quot;); getchar(); getchar(); /****************************************** step 7: exit process ******************************************/ SAMPLE_COMM_VENC_StopGetStream(); /* 停止去获取码流，不过前面产生码流的6部分并没有停止 */ END_VENC_1080P_CLASSIC_5: /* 倒影式处理产生码流的前六个步骤 */ VpssGrp = 0;switch(s32ChnNum){case 3:VpssChn = 2; VencChn = 2; SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn); SAMPLE_COMM_VENC_Stop(VencChn);case 2:VpssChn = 1; VencChn = 1; SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn); SAMPLE_COMM_VENC_Stop(VencChn);case 1:VpssChn = 0; VencChn = 0; SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn); SAMPLE_COMM_VENC_Stop(VencChn);break;} SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);END_VENC_1080P_CLASSIC_4: //vpss stop VpssGrp = 0;switch(s32ChnNum){case 3:VpssChn = 2;SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);case 2:VpssChn = 1;SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);case 1:VpssChn = 0;SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);break;}END_VENC_1080P_CLASSIC_3: //vpss stop SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);END_VENC_1080P_CLASSIC_2: //vpss stop SAMPLE_COMM_VPSS_StopGroup(VpssGrp);END_VENC_1080P_CLASSIC_1: //vi stop SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);END_VENC_1080P_CLASSIC_0: //system exit SAMPLE_COMM_SYS_Exit(); return s32Ret; }
&amp;lt;span style=&amp;quot;color:#ff0000;&amp;quot;&amp;gt;/*---------end of------&amp;lt;/span&amp;gt; H.264@1080p@30fps+H.265@1080p@30fps+H.264@D1@30fps &amp;lt;span style=&amp;quot;color:#ff0000;&amp;quot;&amp;gt;------------------*/&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color:#ff0000;&amp;quot;&amp;gt;
&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;font-family:SimHei;color:#ff0000;&amp;quot;&amp;gt;/*----------------分界线：上面是一个高清编码回合，是一种编码情况，下面这些是另外一种情况---------------*/&amp;lt;/span&amp;gt;

/******************************************************************************
* function :  1*1080p MJPEG encode + 1*1080p jpeg
******************************************************************************/
HI_S32 SAMPLE_VENC_1080P_MJPEG_JPEG(HI_VOID)
{
    PAYLOAD_TYPE_E enPayLoad = PT_MJPEG;
    PIC_SIZE_E enSize = PIC_HD1080;

	HI_U32 u32Profile = 0;

    VB_CONF_S stVbConf;
    SAMPLE_VI_CONFIG_S stViConfig = {0};
    
    VPSS_GRP VpssGrp;
    VPSS_CHN VpssChn;
    VPSS_GRP_ATTR_S stVpssGrpAttr;
    VPSS_CHN_ATTR_S stVpssChnAttr;
    VPSS_CHN_MODE_S stVpssChnMode;
    
    VENC_CHN VencChn;
    SAMPLE_RC_E enRcMode = SAMPLE_RC_CBR;
    HI_S32 s32ChnNum = 1;
        
    HI_S32 s32Ret = HI_SUCCESS;
    HI_U32 u32BlkSize;
    SIZE_S stSize;
    HI_S32 i = 0;
    char ch;

    /******************************************
     step  1: init sys variable 
    ******************************************/
    memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S));

    stVbConf.u32MaxPoolCnt = 128;
    SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize);

    /*video buffer*/
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize, SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);

    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;


    /******************************************
     step 2: mpp system init. 
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
        goto END_VENC_MJPEG_JPEG_0;
    }
 
    /******************************************
     step 3: start vi dev &amp;amp; chn to capture
    ******************************************/
    stViConfig.enViMode   = SENSOR_TYPE;
    stViConfig.enRotate   = ROTATE_NONE;
    stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;
    stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
    s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_1;
    }
    
    /******************************************
     step 4: start vpss and vi bind vpss
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize, &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_1;
    }
	
    VpssGrp = 0;
    stVpssGrpAttr.u32MaxW = stSize.u32Width;
    stVpssGrpAttr.u32MaxH = stSize.u32Height;
    stVpssGrpAttr.bIeEn = HI_FALSE;
    stVpssGrpAttr.bNrEn = HI_TRUE;
    stVpssGrpAttr.bHistEn = HI_FALSE;
    stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
    stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	stVpssGrpAttr.bDciEn = HI_FALSE;
    s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_2;
    }

    s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_3;
    }

    
    VpssChn = 0;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
    
    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_4;
    }
    
    VpssChn = 1;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;

    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_4;
    }
    
    /******************************************
     step 5: start stream venc
    ******************************************/
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad,\
                                   gs_enNorm, enSize, enRcMode,u32Profile);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }
    
    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    VpssGrp = 0;
    VpssChn = 1;
    VencChn = 1;
    s32Ret = SAMPLE_COMM_VENC_SnapStart(VencChn, &amp;amp;stSize, HI_FALSE);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start snap failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    
    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    /******************************************
     step 6: stream venc process -- get stream, then save it to file. 
    ******************************************/
    s32Ret = SAMPLE_COMM_VENC_StartGetStream(s32ChnNum);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    printf(&amp;quot;press &#39;q&#39; to exit sample!\nperess ENTER to capture one picture to file\n&amp;quot;);
    i = 0;
    while ((ch = (char)getchar()) != &#39;q&#39;)
    {
        s32Ret = SAMPLE_COMM_VENC_SnapProcess(VencChn, HI_TRUE, HI_FALSE);
        if (HI_SUCCESS != s32Ret)
        {
            printf(&amp;quot;%s: sanp process failed!\n&amp;quot;, __FUNCTION__);
            break;
        }
        printf(&amp;quot;snap %d success!\n&amp;quot;, i);
        i++;
    }
 
    printf(&amp;quot;please press ENTER to exit this sample\n&amp;quot;);
    getchar();
    getchar();

    /******************************************
     step 8: exit process
    ******************************************/
    SAMPLE_COMM_VENC_StopGetStream();
    
END_VENC_MJPEG_JPEG_5:
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
    SAMPLE_COMM_VENC_Stop(VencChn);

    VpssChn = 1;
    VencChn = 1;
    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
    SAMPLE_COMM_VENC_Stop(VencChn);
END_VENC_MJPEG_JPEG_4:    //vpss stop
    VpssGrp = 0;
    VpssChn = 0;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn); 
    VpssChn = 1;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
END_VENC_MJPEG_JPEG_3:    //vpss stop       
    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_MJPEG_JPEG_2:    //vpss stop   
    SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
END_VENC_MJPEG_JPEG_1:    //vi stop
    SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);
END_VENC_MJPEG_JPEG_0:	//system exit
    SAMPLE_COMM_SYS_Exit();
    
    return s32Ret;
}

/******************************************************************************
* function :  low delay encode(only vi-vpss online).
******************************************************************************/
HI_S32 SAMPLE_VENC_LOW_DELAY(HI_VOID)
{
    PAYLOAD_TYPE_E enPayLoad[2]= {PT_H264, PT_H264};
    PIC_SIZE_E enSize[2] = {PIC_HD1080, PIC_VGA};
	HI_U32 u32Profile = 0;

    VB_CONF_S stVbConf;
    SAMPLE_VI_CONFIG_S stViConfig = {0};
    HI_U32 u32Priority;
    
    VPSS_GRP VpssGrp;
    VPSS_CHN VpssChn;
    VPSS_GRP_ATTR_S stVpssGrpAttr;
    VPSS_CHN_ATTR_S stVpssChnAttr;
    VPSS_CHN_MODE_S stVpssChnMode;
    VPSS_LOW_DELAY_INFO_S stLowDelayInfo;
    
    VENC_CHN VencChn;
    SAMPLE_RC_E enRcMode= SAMPLE_RC_CBR;
    HI_S32 s32ChnNum = 2;
    
    HI_S32 s32Ret = HI_SUCCESS;
    HI_U32 u32BlkSize;
    SIZE_S stSize;
    char c;

    /******************************************
     step  1: init sys variable 
    ******************************************/
    memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S));

    SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);
    if (PIC_HD1080 == enSize[0])
    {
        enSize[1] = PIC_VGA;
		s32ChnNum = 2;
    }
    else if (PIC_HD720 == enSize[0])
    {
        enSize[1] = PIC_VGA;			
		s32ChnNum = 2;
    }
    else
    {
        printf(&amp;quot;not support this sensor\n&amp;quot;);
        return HI_FAILURE;
    }
    #ifdef hi3518ev201

		s32ChnNum = 1;

	#endif
    stVbConf.u32MaxPoolCnt = 128;

    /*video buffer*/       
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);

	if(s32ChnNum &amp;gt;= 1)
    {
	    printf(&amp;quot;u32BlkSize: %d\n&amp;quot;, u32BlkSize);
	    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 2)
    {
	    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
	                enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[1].u32BlkCnt = g_u32BlkCnt;    
	}
    /******************************************
     step 2: mpp system init. 
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
        goto END_VENC_LOW_DELAY_0;
    }

    /******************************************
     step 3: start vi dev &amp;amp; chn to capture
    ******************************************/
    stViConfig.enViMode   = SENSOR_TYPE;
    stViConfig.enRotate   = ROTATE_NONE;
    stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;
    stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
    s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_1;
    }
    
    /******************************************
     step 4: start vpss and vi bind vpss
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[0], &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_1;
    }

    VpssGrp = 0;
    stVpssGrpAttr.u32MaxW = stSize.u32Width;
    stVpssGrpAttr.u32MaxH = stSize.u32Height;
    stVpssGrpAttr.bIeEn = HI_FALSE;
    stVpssGrpAttr.bNrEn = HI_TRUE;
    stVpssGrpAttr.bHistEn = HI_FALSE;
    stVpssGrpAttr.bDciEn = HI_FALSE;
    stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
    stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_2;
    }

    s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_3;
    }

    VpssChn = 0;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_4;
    }
	
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[1], &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_4;
    }
    VpssChn = 1;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_4;
    }

    /******************************************
     step 5: start stream venc
    ******************************************/
    /*** HD1080P **/
    printf(&amp;quot;\t c) cbr.\n&amp;quot;);
    printf(&amp;quot;\t v) vbr.\n&amp;quot;);
    printf(&amp;quot;\t f) fixQp\n&amp;quot;);
    printf(&amp;quot;please input choose rc mode!\n&amp;quot;);
    c = (char)getchar();
    switch(c)
    {
        case &#39;c&#39;:
            enRcMode = SAMPLE_RC_CBR;
            break;
        case &#39;v&#39;:
            enRcMode = SAMPLE_RC_VBR;
            break;
        case &#39;f&#39;:
            enRcMode = SAMPLE_RC_FIXQP;
            break;
        default:
            printf(&amp;quot;rc mode! is invaild!\n&amp;quot;);
            goto END_VENC_LOW_DELAY_4;
    }
	if(s32ChnNum &amp;gt;= 1)
	{
	    VpssGrp = 0;
	    VpssChn = 0;
	    VencChn = 0;
	    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[0],\
	                                   gs_enNorm, enSize[0], enRcMode,u32Profile);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }

	    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }

	    /*set chnl Priority*/
	    s32Ret = HI_MPI_VENC_GetChnlPriority(VencChn,&amp;amp;u32Priority);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Get Chnl Priority failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }
	    
	    u32Priority = 1;

	    s32Ret = HI_MPI_VENC_SetChnlPriority(VencChn,u32Priority);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Set Chnl Priority failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }

	    /*set low delay*/
	    #if 1
	    s32Ret = HI_MPI_VPSS_GetLowDelayAttr(VpssGrp,VpssChn,&amp;amp;stLowDelayInfo);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;HI_MPI_VPSS_GetLowDelayAttr failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }
	    stLowDelayInfo.bEnable = HI_TRUE;
	    stLowDelayInfo.u32LineCnt = stVpssChnMode.u32Height/2;
	    s32Ret = HI_MPI_VPSS_SetLowDelayAttr(VpssGrp,VpssChn,&amp;amp;stLowDelayInfo);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;HI_MPI_VPSS_SetLowDelayAttr failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }
	    #endif
	}
	
    /*** 1080p **/
	if(s32ChnNum &amp;gt;= 2)
    {
	    VpssChn = 1;
	    VencChn = 1;
	    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[1], \
	                                    gs_enNorm, enSize[1], enRcMode,u32Profile);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }

	    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
	    if (HI_SUCCESS != s32Ret)
	    {
	        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
	        goto END_VENC_LOW_DELAY_5;
	    }
	}
    
    /******************************************
     step 6: stream venc process -- get stream, then save it to file. 
    ******************************************/
    s32Ret = SAMPLE_COMM_VENC_StartGetStream(s32ChnNum);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_LOW_DELAY_5;
    }

    printf(&amp;quot;please press twice ENTER to exit this sample\n&amp;quot;);
    getchar();
    getchar();

    /******************************************
     step 7: exit process
    ******************************************/
    SAMPLE_COMM_VENC_StopGetStream();
    
END_VENC_LOW_DELAY_5:
    VpssGrp = 0;

	if(s32ChnNum &amp;gt;= 1)
    {
	    VpssChn = 0;  
	    VencChn = 0;
	    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
	    SAMPLE_COMM_VENC_Stop(VencChn);
    }
	if(s32ChnNum &amp;gt;= 2)
    {
    	VpssChn = 1;   
	    VencChn = 1;
	    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
	    SAMPLE_COMM_VENC_Stop(VencChn);
	}
    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_LOW_DELAY_4:   //vpss stop
    VpssGrp = 0;
    VpssChn = 0;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
    VpssChn = 1;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
END_VENC_LOW_DELAY_3:    //vpss stop       
    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_LOW_DELAY_2:    //vpss stop   
    SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
END_VENC_LOW_DELAY_1:   //vi stop
    SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);
END_VENC_LOW_DELAY_0:   //system exit
    SAMPLE_COMM_SYS_Exit();
    
    return s32Ret;    
}


HI_S32 SAMPLE_VENC_ROIBG_CLASSIC(HI_VOID)
{
    PAYLOAD_TYPE_E enPayLoad= PT_H264;
    PIC_SIZE_E enSize[3] = {PIC_HD1080,PIC_VGA,PIC_QVGA};
	HI_U32 u32Profile = 0;

    VB_CONF_S stVbConf;
    SAMPLE_VI_CONFIG_S stViConfig = {0};
    
    VPSS_GRP VpssGrp;
    VPSS_CHN VpssChn;
    VPSS_GRP_ATTR_S stVpssGrpAttr;
    VPSS_CHN_ATTR_S stVpssChnAttr;
    VPSS_CHN_MODE_S stVpssChnMode;
    VENC_ROI_CFG_S  stVencRoiCfg;
    VENC_ROIBG_FRAME_RATE_S stRoiBgFrameRate;
    
    VENC_CHN VencChn;
    SAMPLE_RC_E enRcMode= SAMPLE_RC_CBR;
    HI_S32 s32ChnNum = 1;
    
    HI_S32 s32Ret = HI_SUCCESS;
    HI_U32 u32BlkSize;
    SIZE_S stSize;
    char c;

    /******************************************
     step  1: init sys variable 
    ******************************************/
    memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S));

    SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);
    if (PIC_HD1080 == enSize[0])
    {
		s32ChnNum = 1;
    }
    else if (PIC_HD720 == enSize[0])
    {
		s32ChnNum = 1;
    }
    else
    {
        printf(&amp;quot;not support this sensor\n&amp;quot;);
        return HI_FAILURE;
    }
    
    stVbConf.u32MaxPoolCnt = 128;

    /*video buffer*/
	if(s32ChnNum &amp;gt;= 1)
    {
	    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
	                enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 2)
    {
    	u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[1].u32BlkCnt = g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 3)
    {
	    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
	                enSize[2], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	    stVbConf.astCommPool[2].u32BlkSize = u32BlkSize;
	    stVbConf.astCommPool[2].u32BlkCnt = g_u32BlkCnt;
	}

    /******************************************
     step 2: mpp system init. 
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
        goto END_VENC_1080P_CLASSIC_0;
    }

    /******************************************
     step 3: start vi dev &amp;amp; chn to capture
    ******************************************/
    stViConfig.enViMode   = SENSOR_TYPE;
    stViConfig.enRotate   = ROTATE_NONE;
    stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;
    stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
    s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_1;
    }
    
    /******************************************
     step 4: start vpss and vi bind vpss
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[0], &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_1;
    }

    VpssGrp = 0;
    stVpssGrpAttr.u32MaxW = stSize.u32Width;
    stVpssGrpAttr.u32MaxH = stSize.u32Height;
    stVpssGrpAttr.bIeEn = HI_FALSE;
    stVpssGrpAttr.bNrEn = HI_TRUE;
    stVpssGrpAttr.bHistEn = HI_FALSE;
    stVpssGrpAttr.bDciEn = HI_FALSE;
    stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
    stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_2;
    }

    s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_3;
    }

    VpssChn = 0;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_4;
    }

    /******************************************
     step 5: start stream venc
    ******************************************/
    /*** HD1080P **/
    printf(&amp;quot;\t c) cbr.\n&amp;quot;);
    printf(&amp;quot;\t v) vbr.\n&amp;quot;);
    printf(&amp;quot;\t f) fixQp\n&amp;quot;);
    printf(&amp;quot;please input choose rc mode!\n&amp;quot;);
    c = (char)getchar();
    switch(c)
    {
        case &#39;c&#39;:
            enRcMode = SAMPLE_RC_CBR;
            break;
        case &#39;v&#39;:
            enRcMode = SAMPLE_RC_VBR;
            break;
        case &#39;f&#39;:
            enRcMode = SAMPLE_RC_FIXQP;
            break;
        default:
            printf(&amp;quot;rc mode! is invaild!\n&amp;quot;);
            goto END_VENC_1080P_CLASSIC_4;
    }
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad,\
                                   gs_enNorm, enSize[0], enRcMode,u32Profile);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }

    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }
    stVencRoiCfg.bAbsQp   = HI_TRUE;
    stVencRoiCfg.bEnable  = HI_TRUE;
    stVencRoiCfg.s32Qp    = 30;
    stVencRoiCfg.u32Index = 0;
    stVencRoiCfg.stRect.s32X = 64;
    stVencRoiCfg.stRect.s32Y = 64;
    stVencRoiCfg.stRect.u32Height =256;
    stVencRoiCfg.stRect.u32Width =256;
    s32Ret = HI_MPI_VENC_SetRoiCfg(VencChn,&amp;amp;stVencRoiCfg);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }

    s32Ret = HI_MPI_VENC_GetRoiBgFrameRate(VencChn,&amp;amp;stRoiBgFrameRate);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;HI_MPI_VENC_GetRoiBgFrameRate failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }
    stRoiBgFrameRate.s32SrcFrmRate = (VIDEO_ENCODING_MODE_PAL== gs_enNorm)?25:30;   
    stRoiBgFrameRate.s32DstFrmRate = (VIDEO_ENCODING_MODE_PAL== gs_enNorm)?5:15;
    
    s32Ret = HI_MPI_VENC_SetRoiBgFrameRate(VencChn,&amp;amp;stRoiBgFrameRate);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;HI_MPI_VENC_SetRoiBgFrameRate!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }
    /******************************************
     step 6: stream venc process -- get stream, then save it to file. 
    ******************************************/
    s32Ret = SAMPLE_COMM_VENC_StartGetStream(s32ChnNum);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }

    printf(&amp;quot;please press ENTER to exit this sample\n&amp;quot;);
    getchar();
    getchar();

    /******************************************
     step 7: exit process
    ******************************************/
    SAMPLE_COMM_VENC_StopGetStream();
    
END_VENC_1080P_CLASSIC_5:
    VpssGrp = 0;
    
    VpssChn = 0;  
    VencChn = 0;
    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
    SAMPLE_COMM_VENC_Stop(VencChn);

    

    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_1080P_CLASSIC_4:	//vpss stop
    VpssGrp = 0;
    VpssChn = 0;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
END_VENC_1080P_CLASSIC_3:    //vpss stop       
    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_1080P_CLASSIC_2:    //vpss stop   
    SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
END_VENC_1080P_CLASSIC_1:	//vi stop
    SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);
END_VENC_1080P_CLASSIC_0:	//system exit
    SAMPLE_COMM_SYS_Exit();
    
    return s32Ret;    
}

HI_S32 SAMPLE_VENC_SVC_H264(HI_VOID)
{
	PAYLOAD_TYPE_E enPayLoad= PT_H264;
	PIC_SIZE_E enSize[3] = {PIC_HD1080,PIC_HD720,PIC_D1};
	HI_U32 u32Profile = 3;/* Svc-t */
		
	VB_CONF_S stVbConf;
	SAMPLE_VI_CONFIG_S stViConfig = {0};
	
	VPSS_GRP VpssGrp;
	VPSS_CHN VpssChn;
	VPSS_GRP_ATTR_S stVpssGrpAttr;
	VPSS_CHN_ATTR_S stVpssChnAttr;
	VPSS_CHN_MODE_S stVpssChnMode;

	
	VENC_CHN VencChn;
	SAMPLE_RC_E enRcMode= SAMPLE_RC_CBR;
	HI_S32 s32ChnNum = 1;
	
	HI_S32 s32Ret = HI_SUCCESS;
	HI_U32 u32BlkSize;
	SIZE_S stSize;
	char c;

	/******************************************
	 step  1: init sys variable 
	******************************************/
	memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S));

    SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);
    if (PIC_HD1080 == enSize[0])
    {
		s32ChnNum = 1;
    }
    else if (PIC_HD720 == enSize[0])
    {
		s32ChnNum = 1;
    }
    else
    {
        printf(&amp;quot;not support this sensor\n&amp;quot;);
        return HI_FAILURE;
    }
    
	stVbConf.u32MaxPoolCnt = 128;

	/*video buffer*/  
	if(s32ChnNum &amp;gt;= 1)
	{
		u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
					enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
		stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
		stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;
	}
	if(s32ChnNum &amp;gt;= 2)
	{
		u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
					enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
		stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;
		stVbConf.astCommPool[1].u32BlkCnt = g_u32BlkCnt;
	}
	
	if(s32ChnNum &amp;gt;= 1)
	{
		u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
					enSize[2], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
		stVbConf.astCommPool[2].u32BlkSize = u32BlkSize;
		stVbConf.astCommPool[2].u32BlkCnt = g_u32BlkCnt;
	}

	/******************************************
	 step 2: mpp system init. 
	******************************************/
	s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
		goto END_VENC_1080P_CLASSIC_0;
	}

	/******************************************
	 step 3: start vi dev &amp;amp; chn to capture
	******************************************/
	stViConfig.enViMode   = SENSOR_TYPE;
	stViConfig.enRotate   = ROTATE_NONE;
	stViConfig.enNorm	  = VIDEO_ENCODING_MODE_AUTO;
	stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
	s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_1;
	}
	
	/******************************************
	 step 4: start vpss and vi bind vpss
	******************************************/
	s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize[0], &amp;amp;stSize);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_1;
	}

	VpssGrp = 0;
	stVpssGrpAttr.u32MaxW = stSize.u32Width;
	stVpssGrpAttr.u32MaxH = stSize.u32Height;
	stVpssGrpAttr.bIeEn = HI_FALSE;
	stVpssGrpAttr.bNrEn = HI_TRUE;
	stVpssGrpAttr.bHistEn = HI_FALSE;
	stVpssGrpAttr.bDciEn = HI_FALSE;
	stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
	stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_2;
	}

	s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_3;
	}

	VpssChn = 0;
	stVpssChnMode.enChnMode 	= VPSS_CHN_MODE_USER;
	stVpssChnMode.bDouble		= HI_FALSE;
	stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	stVpssChnMode.u32Width		= stSize.u32Width;
	stVpssChnMode.u32Height 	= stSize.u32Height;
	stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
	memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
	stVpssChnAttr.s32SrcFrameRate = -1;
	stVpssChnAttr.s32DstFrameRate = -1;
	s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_4;
	}

	/******************************************
	 step 5: start stream venc
	******************************************/
	/*** HD1080P **/
	printf(&amp;quot;\t c) cbr.\n&amp;quot;);
	printf(&amp;quot;\t v) vbr.\n&amp;quot;);
	printf(&amp;quot;\t f) fixQp\n&amp;quot;);
	printf(&amp;quot;please input choose rc mode!\n&amp;quot;);
	c = (char)getchar();
	switch(c)
	{
		case &#39;c&#39;:
			enRcMode = SAMPLE_RC_CBR;
			break;
		case &#39;v&#39;:
			enRcMode = SAMPLE_RC_VBR;
			break;
		case &#39;f&#39;:
			enRcMode = SAMPLE_RC_FIXQP;
			break;
		default:
			printf(&amp;quot;rc mode! is invaild!\n&amp;quot;);
			goto END_VENC_1080P_CLASSIC_4;
	}
	VpssGrp = 0;
	VpssChn = 0;
	VencChn = 0;
	s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad,\
								   gs_enNorm, enSize[0], enRcMode,u32Profile);
	
	printf(&amp;quot;SAMPLE_COMM_VENC_Start is ok\n&amp;quot;);
	
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_5;
	}

	s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);

	printf(&amp;quot;SAMPLE_COMM_VENC_BindVpss is ok\n&amp;quot;);

	
	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_5;
	}
	
	/******************************************
	 step 6: stream venc process -- get stream, then save it to file. 
	******************************************/
	s32Ret = SAMPLE_COMM_VENC_StartGetStream_Svc_t(s32ChnNum);

	if (HI_SUCCESS != s32Ret)
	{
		SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
		goto END_VENC_1080P_CLASSIC_5;
	}

	printf(&amp;quot;please press ENTER to exit this sample\n&amp;quot;);
	getchar();
	getchar();

	/******************************************
	 step 7: exit process
	******************************************/
	SAMPLE_COMM_VENC_StopGetStream();
	
	printf(&amp;quot;SAMPLE_COMM_VENC_StopGetStream is ok\n&amp;quot;);
END_VENC_1080P_CLASSIC_5:
	VpssGrp = 0;
	
	VpssChn = 0;  
	VencChn = 0;
	SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
	SAMPLE_COMM_VENC_Stop(VencChn);

	

	SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_1080P_CLASSIC_4:	//vpss stop
	VpssGrp = 0;
	VpssChn = 0;
	SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
END_VENC_1080P_CLASSIC_3:	 //vpss stop	   
	SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_1080P_CLASSIC_2:	 //vpss stop   
	SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
END_VENC_1080P_CLASSIC_1:	//vi stop
	SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);	
END_VENC_1080P_CLASSIC_0:	//system exit
	SAMPLE_COMM_SYS_Exit();
	return s32Ret;	  
}

/******************************************************************************
* function :  Thumbnail of 1*1080p jpeg
******************************************************************************/
HI_S32 SAMPLE_VENC_1080P_JPEG_Thumb(HI_VOID)

{
    PIC_SIZE_E enSize = PIC_HD1080;
    ISP_DCF_INFO_S stIspDCF;

    VB_CONF_S stVbConf;
    SAMPLE_VI_CONFIG_S stViConfig = {0};
    
    VPSS_GRP VpssGrp;
    VPSS_CHN VpssChn;
    VPSS_GRP_ATTR_S stVpssGrpAttr;
    VPSS_CHN_ATTR_S stVpssChnAttr;
    VPSS_CHN_MODE_S stVpssChnMode;
    
    VENC_CHN VencChn;
        
    HI_S32 s32Ret = HI_SUCCESS;
    HI_U32 u32BlkSize;
    SIZE_S stSize;
    HI_S32 i = 0;
    char ch;

    /******************************************
     step  1: init sys variable 
    ******************************************/
    memset(&amp;amp;stVbConf,0,sizeof(VB_CONF_S));

    stVbConf.u32MaxPoolCnt = 128;
    SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize);

    /*video buffer*/
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize, SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);

    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;


    /******************************************
     step 2: mpp system init. 
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_Init_With_DCF(&amp;amp;stVbConf);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
        goto END_VENC_MJPEG_JPEG_0;
    }
 
    /******************************************
     step 3: start vi dev &amp;amp; chn to capture
    ******************************************/
    stViConfig.enViMode   = SENSOR_TYPE;
    stViConfig.enRotate   = ROTATE_NONE;
    stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;
    stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
    s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_1;
    }
    
    /******************************************
     step 4: start vpss and vi bind vpss
    ******************************************/
    s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize, &amp;amp;stSize);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_SYS_GetPicSize failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_1;
    }
	
    VpssGrp = 0;
    stVpssGrpAttr.u32MaxW = stSize.u32Width;
    stVpssGrpAttr.u32MaxH = stSize.u32Height;
    stVpssGrpAttr.bIeEn = HI_FALSE;
    stVpssGrpAttr.bNrEn = HI_TRUE;
    stVpssGrpAttr.bHistEn = HI_FALSE;
    stVpssGrpAttr.enDieMode = VPSS_DIE_MODE_NODIE;
    stVpssGrpAttr.enPixFmt = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
	stVpssGrpAttr.bDciEn = HI_FALSE;
    s32Ret = SAMPLE_COMM_VPSS_StartGroup(VpssGrp, &amp;amp;stVpssGrpAttr);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Vpss failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_2;
    }

    s32Ret = SAMPLE_COMM_VI_BindVpss(stViConfig.enViMode);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Vi bind Vpss failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_3;
    }

    
    VpssChn = 0;
    stVpssChnMode.enChnMode     = VPSS_CHN_MODE_USER;
    stVpssChnMode.bDouble       = HI_FALSE;
    stVpssChnMode.enPixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_420;
    stVpssChnMode.u32Width      = stSize.u32Width;
    stVpssChnMode.u32Height     = stSize.u32Height;
    stVpssChnMode.enCompressMode = COMPRESS_MODE_NONE;
    
    memset(&amp;amp;stVpssChnAttr, 0, sizeof(stVpssChnAttr));
    stVpssChnAttr.s32SrcFrameRate = -1;
    stVpssChnAttr.s32DstFrameRate = -1;
    s32Ret = SAMPLE_COMM_VPSS_EnableChn(VpssGrp, VpssChn, &amp;amp;stVpssChnAttr, &amp;amp;stVpssChnMode, HI_NULL);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Enable vpss chn failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_4;
    }
    
    /******************************************
     step 5: set CDF info
    ******************************************/
    
    HI_MPI_ISP_GetDCFInfo(&amp;amp;stIspDCF);
    
    //description: Thumbnail test
    memcpy(stIspDCF.au8ImageDescription,&amp;quot;Thumbnail test&amp;quot;,strlen(&amp;quot;Thumbnail test&amp;quot;));
    
    //manufacturer: Hisilicon
    memcpy(stIspDCF.au8Make,&amp;quot;Hisilicon&amp;quot;,strlen(&amp;quot;Hisilicon&amp;quot;));
    
    //model number: Hisilicon IP Camera
    memcpy(stIspDCF.au8Model,&amp;quot;Hisilicon IP Camera&amp;quot;,strlen(&amp;quot;Hisilicon IP Camera&amp;quot;));
    
    //firmware version: v.1.1.0 
    memcpy(stIspDCF.au8Software,&amp;quot;v.1.1.0&amp;quot;,strlen(&amp;quot;v.1.1.0&amp;quot;));
    
    stIspDCF.u16ISOSpeedRatings         = 500;
    stIspDCF.u32ExposureBiasValue       = 5;
    stIspDCF.u32ExposureTime            = 0x00010004;
    stIspDCF.u32FNumber                 = 0x0001000f;
    stIspDCF.u32FocalLength             = 0x00640001;
    stIspDCF.u32MaxApertureValue        = 0x00010001;
    stIspDCF.u8Contrast                 = 5;
    stIspDCF.u8CustomRendered           = 0;
    stIspDCF.u8ExposureMode             = 0;
    stIspDCF.u8ExposureProgram          = 1;
    stIspDCF.u8FocalLengthIn35mmFilm    = 1;
    stIspDCF.u8GainControl              = 1;
    stIspDCF.u8LightSource              = 1;
    stIspDCF.u8MeteringMode             = 1;
    stIspDCF.u8Saturation               = 1;
    stIspDCF.u8SceneCaptureType         = 1;
    stIspDCF.u8SceneType                = 0;
    stIspDCF.u8Sharpness                = 5;
    stIspDCF.u8WhiteBalance             = 1;
    
    HI_MPI_ISP_SetDCFInfo(&amp;amp;stIspDCF);
    
    /******************************************
     step 6: start stream venc
    ******************************************/
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    
    s32Ret = SAMPLE_COMM_VENC_SnapStart(VencChn, &amp;amp;stSize, HI_TRUE);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start snap failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    
    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_MJPEG_JPEG_5;
    }

    /******************************************
     step 7: stream venc process -- get stream, then save it to file. 
    ******************************************/
    printf(&amp;quot;press &#39;q&#39; to exit sample!\nperess ENTER to capture one picture to file\n&amp;quot;);
    i = 0;
    while ((ch = (char)getchar()) != &#39;q&#39;)
    {
        s32Ret = SAMPLE_COMM_VENC_SnapProcess(VencChn, HI_TRUE, HI_TRUE);
        if (HI_SUCCESS != s32Ret)
        {
            printf(&amp;quot;%s: sanp process failed!\n&amp;quot;, __FUNCTION__);
            break;
        }
        printf(&amp;quot;snap %d success!\n&amp;quot;, i);
        i++;
    }
 
    printf(&amp;quot;please press ENTER to exit this sample\n&amp;quot;);
    getchar();
    getchar();

    /******************************************
     step 8: exit process
    ******************************************/
    SAMPLE_COMM_VENC_StopGetStream();
    
END_VENC_MJPEG_JPEG_5:
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
    SAMPLE_COMM_VENC_Stop(VencChn);
END_VENC_MJPEG_JPEG_4:    //vpss stop
    VpssGrp = 0;
    VpssChn = 0;
    SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn); 
END_VENC_MJPEG_JPEG_3:    //vpss stop       
    SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
END_VENC_MJPEG_JPEG_2:    //vpss stop   
    SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
END_VENC_MJPEG_JPEG_1:    //vi stop
    SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);
END_VENC_MJPEG_JPEG_0:	//system exit
    SAMPLE_COMM_SYS_Exit();
    
    return s32Ret;
}



/******************************************************************************
* function    : main()
* Description : video venc sample
******************************************************************************/
int main(int argc, char *argv[])
{
    HI_S32 s32Ret;
    if ( (argc &amp;lt; 2) || (1 != strlen(argv[1])))  //argc传参校验，参数个不能大于2个。参数2字符串长度不等于1 
    {
        SAMPLE_VENC_Usage(argv[0]); //提示程序使用方法
        return HI_FAILURE;  //return -1
    }

    signal(SIGINT, SAMPLE_VENC_HandleSig);  //SIGINT=2 , 属于中断信号,定义在/usr/include/i386-linux-gnu/bits/signal.h
    signal(SIGTERM, SAMPLE_VENC_HandleSig); //SIGTERM=15，属于结束信号，类似kill命令发送的OS默认终止信号
    										//SAMPLE_VENC_HandleSig这个函数主要是停止ISP和退出SYS
    switch (*argv[1])
    {
        case &#39;0&#39;:/* H.264@1080p@30fps+H.265@1080p@30fps+H.264@D1@30fps */ 
            s32Ret = SAMPLE_VENC_1080P_CLASSIC(); //实现如上三路码流实时编码,帧率默认设置为30,实时编码都正常。
            break;
        case &#39;1&#39;:/* 1*1080p mjpeg encode + 1*1080p jpeg  */
            s32Ret = SAMPLE_VENC_1080P_MJPEG_JPEG(); //1×1080p MJPEG编码+ 1×1080p JPEG
            break;
        case &#39;2&#39;:/* low delay */
            s32Ret = SAMPLE_VENC_LOW_DELAY(); //低延时
            break;
        case &#39;3&#39;:/* roibg framerate */
            s32Ret = SAMPLE_VENC_ROIBG_CLASSIC();
            break;
        case &#39;4&#39;:/* Thumbnail of 1*1080p jpeg  */
            s32Ret = SAMPLE_VENC_1080P_JPEG_Thumb();  //1×1080p JPEG缩略图
            break;
#ifndef hi3518ev201			
		case &#39;5&#39;:/* H.264 Svc-t */
			s32Ret = SAMPLE_VENC_SVC_H264();
			break;
#endif
        default:
            printf(&amp;quot;the index is invaild!\n&amp;quot;);
            SAMPLE_VENC_Usage(argv[0]);
            return HI_FAILURE;
    }
    
    if (HI_SUCCESS == s32Ret)
        printf(&amp;quot;program exit normally!\n&amp;quot;);
    else
        printf(&amp;quot;program exit abnormally!\n&amp;quot;);
    exit(s32Ret);
}

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* End of #ifdef __cplusplus */
总结：1.设置视频编码模式(N制或P制)

           2.mian 套           

                        SAMPLE_VENC_1080P_CLASSIC
					SAMPLE_COMM_VI_GetSizeBySensor（step1）
					SAMPLE_COMM_SYS_CalcPicVbBlkSize	
						SAMPLE_COMM_SYS_GetPicSize
					SAMPLE_COMM_SYS_Init（step2）
						HI_MPI_SYS_Exit();
						HI_MPI_VB_Exit();
						HI_MPI_VB_SetConf
						HI_MPI_VB_Init
						HI_MPI_SYS_SetConf
						HI_MPI_SYS_Init
					SAMPLE_COMM_VI_StartVi（step3）
						IsSensorInput
						SAMPLE_COMM_VI_StartIspAndVi
							SAMPLE_COMM_VI_StartMIPI（1）
								SAMPLE_COMM_VI_SetMipiAttr
									fd = open(&amp;quot;/dev/hi_mipi&amp;quot;, O_RDWR);
									ioctl(fd, HI_MIPI_SET_DEV_ATTR, pstcomboDevAttr)
							SAMPLE_COMM_ISP_Init（2）
								sensor_register_callback
								HI_MPI_AE_Register
								HI_MPI_AWB_Register
								HI_MPI_AF_Register
								HI_MPI_ISP_MemInit
								HI_MPI_ISP_SetWDRMode
								HI_MPI_ISP_SetPubAttr
								HI_MPI_ISP_Init
							SAMPLE_COMM_ISP_Run（3）
								pthread_create(&amp;amp;gs_IspPid, &amp;amp;attr, (void* (*)(void*))Test_ISP_Run, NULL)
									Test_ISP_Run
										HI_MPI_ISP_Run
							SAMPLE_COMM_VI_StartDev（4）
								HI_MPI_VI_SetDevAttr
								HI_MPI_ISP_GetWDRMode
								HI_MPI_VI_SetWDRAttr
								HI_MPI_VI_EnableDev
							SAMPLE_COMM_VI_StartChn（5）
								HI_MPI_VI_SetChnAttr
								HI_MPI_VI_SetRotate
								HI_MPI_VI_EnableChn					
					SAMPLE_COMM_SYS_GetPicSize（step4）----VPSS
					SAMPLE_COMM_VPSS_StartGroup
					SAMPLE_COMM_VI_BindVpss
					SAMPLE_COMM_VPSS_EnableChn
					SAMPLE_COMM_VENC_Start（step5） 
						-----
						-----
						-----
					SAMPLE_COMM_VENC_BindVpss
					SAMPLE_COMM_VENC_StartGetStream（step6）
					SAMPLE_COMM_VENC_StopGetStream（step7）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「ZHAITEACH」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/QHZM72/article/details/80609140&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/QHZM72/article/details/80609140&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mpp sdk2</title>
            <link>/hardware/hisilicon/hi3516-mpp-sdk2/</link>
            <pubDate>Fri, 29 Nov 2019 15:02:25 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-sdk2/</guid>
            <description>&lt;p&gt;本文链接：&lt;a href=&#34;https://blog.csdn.net/taotongning/article/details/84882431&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/taotongning/article/details/84882431&lt;/a&gt;&lt;br /&gt;
1.官方sampe&lt;br /&gt;
（1）海思官方提供的sampe位于Z:\Hi3518E_SDK_V1.0.3.0\mpp\sample中&lt;br /&gt;
sample其实是很多个例程，所以有很多个Main，每一个例程面向一个典型应用。&lt;br /&gt;
common 是通用性主体函数，里面的东西全是被其他程序调用的。我们只分析视频编码venc&lt;br /&gt;
（2）基本的架构是：venc中的main调用venc中的功能函数，再调用common中的功能函数，&lt;br /&gt;
common中的功能函数再调用mpp中的API，mpp的API在哪里？mpp中的API实现的函数体在ko里面，&lt;br /&gt;
他们是以库的形式（驱动）来提供的，这些ko你是看不见海思的源码的，你只能去查海思的手册，&lt;br /&gt;
HiMPP IPC V2.0 媒体处理软件开发参考.pdf，这份文档就是mpp的API手册，里面包括了所有mpp的&lt;br /&gt;
的API，API（驱动）最终会去调用hi3518E内部的硬件单元（内部有ARM DSP）。&lt;br /&gt;
mpp就是海思图像处理的这套体系&lt;br /&gt;
mpp里面包含ko（运行时要加载的动态库） lib（静态库） sample（我们的应用程序）&lt;br /&gt;
hifb显示用的，free buffer，可以接屏幕显示。&lt;br /&gt;
除了common（被其他目录的函数调用），其他目录下面的都是一个独立的程序（例程，面向一个典型应用），有自己的Main函数。&lt;/p&gt;

&lt;p&gt;海思这一套到了很多关键的地方就是调用了一个库函数，很多情况很多核心的东西是看不到的，只知道调用这个库函数就能完成操作，&lt;br /&gt;
研究的重点是怎么去调这个库函数，怎么去传参，参数是什么意思，参数如果不对会返回怎么样一个错误，&lt;/p&gt;

&lt;p&gt;（3）sampe的配置和编译，目录要完全搞清楚了再动。&lt;br /&gt;
2.sampe代码的学习的关键&lt;br /&gt;
（1）得理解很多基础概念，譬如图像采集原理、模拟数字、通道（海思发明的）、绑定等等。&lt;br /&gt;
说白了就是海思的人在定义概念，我们通过手册去理解概念。&lt;br /&gt;
（2）得从宏观上理解整个视频采集、内部传递、处理、编码输出、网络传输等的过程。&lt;br /&gt;
（3）的反复看代码，熟才能生巧，才能帮助理解整个代码。&lt;br /&gt;
（4）的查阅mpp手册，熟悉海思这一套API的规矩和一般用法。&lt;br /&gt;
（5）从sample/venc/Sampe_venc.c中的main函数开始看&lt;br /&gt;
3.几个基本的概念&lt;br /&gt;
（1） 分辨率&lt;br /&gt;
    VGA（640*480） D1（720*576） 720p 1080p 4K（4096*2160）  8K（8192*4320）&lt;br /&gt;
（2） 视频压缩标准&lt;br /&gt;
    h.264 H.264也称作MPEG-4AVC(Advanced Video Coding)，是一种视频压缩标准，同时也是一种被广泛使用的&lt;br /&gt;
    高精度视频录制、压缩、和发布格式。&lt;br /&gt;
    h.265/HEVC的编码架构大致上和h.264/AVC的架构相似。目前的HEVC标准总共有三种模式：Main、Main10、Main Still Picture.&lt;br /&gt;
（3）fps(frame per second)帧率&lt;br /&gt;
4.图像像素格式深度理解1&lt;br /&gt;
（1）颜色的学问&lt;br /&gt;
a.颜色是主观的还是客观存在的？ 颜色的本质是光的波长，但是因为有人去看了才有了颜色这个概念。&lt;br /&gt;
  是主观存在的概念。意思就是脱离人眼去研究颜色是没有意义的。&lt;br /&gt;
b.颜色的三个关键概念：亮度、色度、饱和度。&lt;br /&gt;
c.人的眼睛并非理想完美的颜色识别器件，图像表达也有清晰度和质量高低的差异。&lt;br /&gt;
d.科学研究如何定义（或者表达、记录、计算）一种颜色？色彩空间的概念&lt;br /&gt;
    颜色其实是有无数种，在RGB888中，RGB分别用8位二级制来表示，那么颜色就有2^24=16777216种，&lt;br /&gt;
    这其实是一种简化，其实颜色是有无数种的，因为光的波长是连续分布的。用这种简化已经足够应对&lt;br /&gt;
    人眼，再细分人眼也看不出区别。&lt;br /&gt;
   RGB就是一种色彩空间，色彩空间 不止一种，比如还有YUV，计算机领域主要有RGB和YUV这两种色彩空间，&lt;br /&gt;
   他们之间可以转换。&lt;br /&gt;
   &lt;br /&gt;
   色彩空间是一种方法，研究的是如何用数字来表达一种颜色。&lt;br /&gt;
5.rawRGB和图像采集过程&lt;br /&gt;
（1）图像采集的过程：光照在成像物体被反射-&amp;gt;镜头汇聚-&amp;gt;Sensor光电转换(模拟的光信号转为模拟的电信号)-&amp;gt;ADC为rawRGB（这个数字的电信号就rawRGB）&lt;br /&gt;
（2）sensor上每一个像素点只采集一种颜色，像素点的上方有一个滤镜，只透一种颜色。这种采集到的就是rawRGB,一个像素只有一个颜色分量。因为sensor&lt;br /&gt;
单个像素根本就没有办法同时采集到三种颜色。&lt;br /&gt;
（3）rawRGB和RGB都是用来描述图像的，图像采集时RGB是由rawRGB计算而来的&lt;br /&gt;
（4）因为图像颜色本身有一定连贯性，而且人眼是非理想的，因此图像采集和再显示给人这整个构成中有三个要素：分辨率（多大像素）、pictch、观看距离&lt;br /&gt;
（5）如果是视频、质量好坏还要加上帧率framerate&lt;br /&gt;
（6）图像的表达、压缩、修整等相关技术，就发生在rawRGB进来以后的各个环节&lt;/p&gt;

&lt;p&gt;6.RGB&lt;br /&gt;
（1）RGB有RGB565（要求不严格的领域里面还过的去）和RGB888（1600万色，真彩色，颜色精度高）,ARGB（A表示透明度）等多种子分类，&lt;br /&gt;
也可以搞一个RGB101010，只不过那么高的精度对人眼的意义不大。RGB888对人眼已经完全够用了。&lt;br /&gt;
（2）RGB的本质：自然界的颜色可以分成红绿蓝，是因为自然界颜色是可以叠加的。将色度分解为R、G、B三部分，然后记录下亮度数据&lt;br /&gt;
注意：用RGB来表示颜色，我们只是记录R G B各自的亮度数据，并没有记录颜色。例如0x234567  值23就是R的亮度值，45就是G的亮度值，67就是B的亮度值。&lt;br /&gt;
    RGB就是由rawRGB转换而来，做了一个平均运算，这个像素缺的那两个颜色值去周围取平均来补充。&lt;br /&gt;
    一幅图像的尺寸是1024*1024像素，每个像素的灰度是8比特，如果图像不压缩，则需要(1024*1024*8 bit)(1MB)的存储空间&lt;br /&gt;
    RGB有RGB556和RGB888，ARGB等多种子分类。R表示透明度&lt;br /&gt;
    RGB888表示R需要8bit，G需要8bit，B需要8bit，加起来需要24bit，&lt;br /&gt;
    RGB565是16位的，2个字节，就是R-5bit G-6bit B-5bit&lt;br /&gt;
    正常的RGB24是由24位即3个字节来描述一个像素,R G B各8位，而实际中为了减少图像数据的尺寸，如视频领域，对R G B 所使用的位数进行的缩减，如RGB565 RGB555&lt;br /&gt;
    颜色是可以叠加的，RGB的本质：将色度分解为R、G、B三部分，本身并没有记录颜色，只是记录了亮度。&lt;br /&gt;
    例如0x00234567 00表示透明度，23表示红色的亮度，45表示绿色的亮度，67表示蓝色的亮度&lt;br /&gt;
    用数学方法记录下来的就是为了复现，&lt;br /&gt;
    RGB的优势：方便数字化表达，广泛用于数字化彩色显示器，计算机编程等领域。&lt;br /&gt;
    RGG的劣势：和传统的灰度图（黑白图像，没有色度，只有亮度）兼容不好，表达颜色的效率不高。&lt;br /&gt;
    &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;YUV    &lt;br /&gt;
    在这个体系了里面，亮度Y与色度UV是分开的，只有Y就是黑白图像，再加上UV就是彩色图像了，YUV的一个好处&lt;br /&gt;
    就是让彩色系统和传统黑白系统很好地兼容。一幅彩色的YUV图可以瞬间变成黑白的，YUV的出现就是为了兼容传统的&lt;br /&gt;
    黑白图像。电视广播发的是YUV的图，彩色电视全盘接受，黑白电视把色度UV丢掉就行。如果给的是RGB信号，黑白电视机&lt;br /&gt;
    根本就不认，因为在黑白电视机年代根本就还没有RGB这种模型。但是RGB的亮度信息是分成三个参量的。&lt;br /&gt;
    &lt;br /&gt;
    YUV和RGB的相同点是：都是用来表达颜色的数学方法;不同点是：对颜色的描述思路和方法不同。&lt;br /&gt;
    RGB将一个颜色拆解为3个基色的亮度组合，YUV将一个颜色分解为一个颜色分解为一个亮度和两个色度的组合。&lt;br /&gt;
    RGB和YUV是可以互相转换，是一个浮点数运算过程。&lt;br /&gt;
    R = Y + 1.4075 * (V-128);  &lt;br /&gt;
    G = Y - 0.3455 * (U-128) - 0.7169*(V-128);  &lt;br /&gt;
    B = Y + 1.779 * (U-128);  &lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    Y = 0.299*R + 0.587*G + 0.114*B;&lt;br /&gt;
    U = (B-Y)/1.772;    &lt;br /&gt;
    V = (R-Y)/1.402;       (U~(-128-127))&lt;/p&gt;

&lt;p&gt;    我们不用关心公式是怎么来的，关心的是相互转换的快慢。建议用DSP或者GPU来算，CUP来算就比较慢。&lt;br /&gt;
    YCbCr，几乎可以理解为YUV，差别比较小&lt;br /&gt;
    &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;YUV格式&lt;br /&gt;
    YUV格式通常有两大类：packed格式和平面planar格式。前者将YUV分量存放在同一个数组中，通常是几个&lt;br /&gt;
    相邻的像素组成一个宏像素（macro-pixel）;而后者使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。&lt;br /&gt;
    &lt;br /&gt;
    假设有4个像素，每个像素都有一个YUV&lt;br /&gt;
    所以：Y0U0V0 Y1U1V1 Y2U2V2 Y3U3V3&lt;br /&gt;
    packed:定义四个数组&lt;br /&gt;
    [Y0,U0,V0],[Y1,U1,V1],[Y2,U2,V2],[Y3,U3,V3] 将YUV分量存放在同一个数组中，如果是取一幅图像的一半&lt;br /&gt;
    当然是用packed的好处理，直接去掉前面或者后面的两个数组即可。&lt;br /&gt;
    planer：&lt;br /&gt;
    [Y0,Y1,Y2,Y3],[U0,U1,U2,U3],[V0,V1,V2,V3] 如果是感觉图片曝光有点暗，我们要调亮一些，当然是planer好处理，&lt;br /&gt;
    直接去调第一个数组就行。&lt;br /&gt;
    packed格式比较简单，planer格式比较复杂&lt;br /&gt;
    我们主要来关注planer&lt;br /&gt;
    YUV422 &lt;br /&gt;
    YUV420  一个像素对应一个Y，相邻的2*2像素小方块对应一个U和一个V，为什么UV可以简化，因为相邻的像素颜色相似性很高，&lt;br /&gt;
    packed这种格式比较简单，实践中见的大多数是planar格式&lt;br /&gt;
    我们可以看出任何一种格式Y都没有简化，因为对于人眼亮度信息比色度信息更加敏感。&lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
        &lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有多种YUV相关的概念需要弄清楚&lt;br /&gt;
YUV    &lt;br /&gt;
YUYV&lt;br /&gt;
YUV422 &lt;br /&gt;
YUV420    (YUV411更加合适)&lt;br /&gt;
YUV422 planar  （YUV422P）&lt;br /&gt;
YUV420 planar  (YUV420P)&lt;br /&gt;
YUV422 semi planar  (YUV422SP)&lt;br /&gt;
YUV420 semi planar（YUV420SP）&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;YUV420SP与YUV420P的数据格式它们的UV排列在原理上是完全不同的。&lt;br /&gt;
planer：&lt;br /&gt;
[Y0,Y1,Y2,Y3],[U0,U1,U2,U3],[V0,V1,V2,V3]&lt;br /&gt;
Semi palanar&lt;br /&gt;
[Y0,Y1,Y2,Y3],[U0,V0],[U1,V1],[U2,V2],[U3,V3]&lt;/p&gt;

&lt;p&gt;YUV420的格式6个值Y1 Y2 Y3 Y4 U1 V1对应到每个像素怎么来表达&lt;br /&gt;
第一个像素点[Y1,U1,V1] &lt;br /&gt;
第二个像素点[Y2,U1,V1]&lt;br /&gt;
第三个像素点[Y3,U1,V1]&lt;br /&gt;
第四个像素点[Y4,U1,V1]&lt;br /&gt;
这四个像素点是共用了UV,但是Y是各自的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mpp&lt;br /&gt;
mpp与驱动处在同一个层级，其实本来就是驱动，只不过以KO、API的形式提供的而已，只不过没有源代码而已。&lt;br /&gt;
驱动上面才是应用层。&lt;br /&gt;
（1）VI模块捕获视频图像，可对其做剪切、缩放等处理，并输出多路不同分辨率的图像数据。&lt;br /&gt;
注意：海思的枚举定义规范所有的字母大写，用下划线来分开，最后会有一个E，告诉你这是个枚举类型。&lt;br /&gt;
例如：PAYLOAD_TYPE_E 你在传输视频的时候，视频的类型我们叫PAYLOAD_TYPE&lt;br /&gt;
你把RTSP视频传输看做是用饺子皮把饺子馅运走，PAYLOAD_TYPE就是问你这个饺子是什么馅的&lt;br /&gt;
RTSP可以传送的类型（馅）有如下类型：RTSP本来就是用来传送一些音视频的&lt;br /&gt;
PT_H264  &lt;br /&gt;
PT_MP3&lt;br /&gt;
PT_AAC&lt;br /&gt;
...&lt;br /&gt;
这个音视频编码的种类特别多，你要用PAYLOAD_TYPE来告诉别人你要传输的是什么视频&lt;br /&gt;
enPayLoad[3]  这个以en开头的就告诉别人你这个是emue类型&lt;br /&gt;
stVpssGrpAttr 以st打头的就告诉别人你这个是一个结构体&lt;br /&gt;
VPSS_GRP_ATTR_S  这个类型表示结构体类型，以_S结尾&lt;br /&gt;
PAYLOAD_TYPE_E enPayLoad[3] = &lt;br /&gt;
VPSS_GRP_ATTR_S stVpssGrpAttr = {0};   st打头说明为结构体变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;/* We just coyp this value of payload type from RTP/RTSP definition &lt;em&gt;/&lt;br /&gt;
typedef enum&lt;br /&gt;
{&lt;br /&gt;
    PT_PCMU          = 0,&lt;br /&gt;
    PT_1016          = 1,&lt;br /&gt;
    PT_G721          = 2,&lt;br /&gt;
    PT_GSM           = 3,&lt;br /&gt;
    PT_G723          = 4,&lt;br /&gt;
    PT_DVI4_8K       = 5,&lt;br /&gt;
    PT_DVI4_16K      = 6,&lt;br /&gt;
    PT_LPC           = 7,&lt;br /&gt;
    PT_PCMA          = 8,&lt;br /&gt;
    PT_G722          = 9,&lt;br /&gt;
    PT_S16BE_STEREO  = 10,&lt;br /&gt;
    PT_S16BE_MONO    = 11,&lt;br /&gt;
    PT_QCELP         = 12,&lt;br /&gt;
    PT_CN            = 13,&lt;br /&gt;
    PT_MPEGAUDIO     = 14,&lt;br /&gt;
    PT_G728          = 15,&lt;br /&gt;
    PT_DVI4_3        = 16,&lt;br /&gt;
    PT_DVI4_4        = 17,&lt;br /&gt;
    PT_G729          = 18,&lt;br /&gt;
    PT_G711A         = 19,&lt;br /&gt;
    PT_G711U         = 20,&lt;br /&gt;
    PT_G726          = 21,&lt;br /&gt;
    PT_G729A         = 22,&lt;br /&gt;
    PT_LPCM          = 23,&lt;br /&gt;
    PT_CelB          = 25,&lt;br /&gt;
    PT_JPEG          = 26,&lt;br /&gt;
    PT_CUSM          = 27,&lt;br /&gt;
    PT_NV            = 28,&lt;br /&gt;
    PT_PICW          = 29,&lt;br /&gt;
    PT_CPV           = 30,&lt;br /&gt;
    PT_H261          = 31,&lt;br /&gt;
    PT_MPEGVIDEO     = 32,&lt;br /&gt;
    PT_MPEG2TS       = 33,&lt;br /&gt;
    PT_H263          = 34,&lt;br /&gt;
    PT_SPEG          = 35,&lt;br /&gt;
    PT_MPEG2VIDEO    = 36,&lt;br /&gt;
    PT_AAC           = 37,&lt;br /&gt;
    PT_WMA9STD       = 38,&lt;br /&gt;
    PT_HEAAC         = 39,&lt;br /&gt;
    PT_PCM_VOICE     = 40,&lt;br /&gt;
    PT_PCM_AUDIO     = 41,&lt;br /&gt;
    PT_AACLC         = 42,&lt;br /&gt;
    PT_MP3           = 43,&lt;br /&gt;
    PT_ADPCMA        = 49,&lt;br /&gt;
    PT_AEC           = 50,&lt;br /&gt;
    PT_X_LD          = 95,&lt;br /&gt;
    PT_H264          = 96,&lt;br /&gt;
    PT_D_GSM_HR      = 200,&lt;br /&gt;
    PT_D_GSM_EFR     = 201,&lt;br /&gt;
    PT_D_L8          = 202,&lt;br /&gt;
    PT_D_RED         = 203,&lt;br /&gt;
    PT_D_VDVI        = 204,&lt;br /&gt;
    PT_D_BT656       = 220,&lt;br /&gt;
    PT_D_H263_1998   = 221,&lt;br /&gt;
    PT_D_MP1S        = 222,&lt;br /&gt;
    PT_D_MP2P        = 223,&lt;br /&gt;
    PT_D_BMPEG       = 224,&lt;br /&gt;
    PT_MP4VIDEO      = 230,&lt;br /&gt;
    PT_MP4AUDIO      = 237,&lt;br /&gt;
    PT_VC1           = 238,&lt;br /&gt;
    PT_JVC_ASF       = 255,&lt;br /&gt;
    PT_D_AVI         = 256,&lt;br /&gt;
    PT_DIVX3         = 257,&lt;br /&gt;
    PT_AVS             = 258,&lt;br /&gt;
    PT_REAL8         = 259,&lt;br /&gt;
    PT_REAL9         = 260,&lt;br /&gt;
    PT_VP6             = 261,&lt;br /&gt;
    PT_VP6F             = 262,&lt;br /&gt;
    PT_VP6A             = 263,&lt;br /&gt;
    PT_SORENSON          = 264,&lt;br /&gt;
    PT_H265          = 265,&lt;br /&gt;
    PT_MAX           = 266,&lt;br /&gt;
    /&lt;/em&gt; add by hisilicon */&lt;br /&gt;
    PT_AMR           = 1001,&lt;br /&gt;
    PT_MJPEG         = 1002,&lt;br /&gt;
    PT_AMRWB         = 1003,&lt;br /&gt;
    PT_BUTT                          //这个是一个结尾标志符，不能用的，不要以为PT_BUTT也是一种传输类型，值为1004，&lt;br /&gt;
} PAYLOAD_TYPE_E;                    //值不重要，重要的是最后一个&lt;/p&gt;

&lt;p&gt;typedef enum hiPIC_SIZE_E&lt;br /&gt;
{&lt;br /&gt;
    PIC_QCIF = 0,&lt;br /&gt;
    PIC_CIF,&lt;br /&gt;
    PIC_2CIF,&lt;br /&gt;
    PIC_HD1,&lt;br /&gt;
    PIC_D1,&lt;br /&gt;
    PIC_960H,&lt;/p&gt;

&lt;p&gt;    PIC_QVGA,    /* 320 * 240 &lt;em&gt;/&lt;br /&gt;
    PIC_VGA,     /&lt;/em&gt; 640 * 480 &lt;em&gt;/&lt;br /&gt;
    PIC_XGA,     /&lt;/em&gt; 1024 * 768 &lt;em&gt;/&lt;br /&gt;
    PIC_SXGA,    /&lt;/em&gt; 1400 * 1050 &lt;em&gt;/&lt;br /&gt;
    PIC_UXGA,    /&lt;/em&gt; 1600 * 1200 &lt;em&gt;/&lt;br /&gt;
    PIC_QXGA,    /&lt;/em&gt; 2048 * 1536 */&lt;/p&gt;

&lt;p&gt;    PIC_WVGA,    /* 854 * 480 &lt;em&gt;/&lt;br /&gt;
    PIC_WSXGA,   /&lt;/em&gt; 1680 * 1050 &lt;em&gt;/&lt;br /&gt;
    PIC_WUXGA,   /&lt;/em&gt; 1920 * 1200 &lt;em&gt;/&lt;br /&gt;
    PIC_WQXGA,   /&lt;/em&gt; 2560 * 1600 */&lt;/p&gt;

&lt;p&gt;    PIC_HD720,   /* 1280 * 720 &lt;em&gt;/&lt;br /&gt;
    PIC_HD1080,  /&lt;/em&gt; 1920 * 1080 &lt;em&gt;/&lt;br /&gt;
    PIC_2304x1296, /&lt;/em&gt; 3M:2304 * 1296 &lt;em&gt;/&lt;br /&gt;
    PIC_2592x1520, /&lt;/em&gt; 4M:2592 * 1520 &lt;em&gt;/&lt;br /&gt;
    PIC_5M,        /&lt;/em&gt; 2592 * 1944 &lt;em&gt;/&lt;br /&gt;
    PIC_2688x1944,/&lt;/em&gt; 2688 * 1944 &lt;em&gt;/&lt;br /&gt;
    PIC_6M,        /&lt;/em&gt; 3072 * 2160 &lt;em&gt;/&lt;br /&gt;
    PIC_UHD4K,     /&lt;/em&gt; 3840 * 2160 &lt;em&gt;/&lt;br /&gt;
    PIC_3Kx3K,      /&lt;/em&gt; 3000 * 3000 &lt;em&gt;/&lt;br /&gt;
    PIC_12M,         /&lt;/em&gt; 4000 * 3000 &lt;em&gt;/&lt;br /&gt;
    PIC_16M,         /&lt;/em&gt; 4608 * 3456 */&lt;/p&gt;

&lt;p&gt;    PIC_BUTT&lt;br /&gt;
} PIC_SIZE_E;&lt;/p&gt;

&lt;p&gt;/******************************************************************************&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function :  H.264@1080p@30fps+H.264@VGA@30fps&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;******************************************************************************/&lt;br /&gt;
HI_S32 SAMPLE_VENC_NORMALP_CLASSIC(HI_VOID)&lt;br /&gt;
{&lt;br /&gt;
    PAYLOAD_TYPE_E enPayLoad[2]= {PT_H265, PT_H264};   //告诉你有两路码流，编码类型一路是H.265，一路是H.264&lt;br /&gt;
    PIC_SIZE_E enSize[2] = {PIC_HD1080, PIC_HD1080};   //告诉你这两路码流的分辨率的大小，都是1080p&lt;/p&gt;

&lt;p&gt;    VB_CONF_S stVbConf;  //视频缓存池&lt;br /&gt;
    &lt;br /&gt;
7.2 视频缓存池&lt;br /&gt;
7.2.1 什么是视频缓冲值&lt;br /&gt;
（1）视频的本质是多帧的图片，图片的本质是RGB或rawRGB数据，要占用一段连续内存。&lt;br /&gt;
（2）视频的裁剪、缩放、修正处理等各种操作，本质上就是对内存中的数据进行运算。&lt;br /&gt;
（3）视频缓存池（VB, video buffer）就是一段很大，又被合理划分和管理的内存，用来做&lt;br /&gt;
视频数据的暂存和运算场地&lt;br /&gt;
（4）公共视频缓存池的公共2字，可以理解为全局变量，也就是各个模块都能访问的一段内存&lt;br /&gt;
（5）看似视频缓存块在各个模块之间流转，实际上并没有内存复制，而是指针在传递&lt;br /&gt;
（6）视频缓冲池的内存由MPP来维护，我们在系统启动时就把整个SDRAM分成了2部分：系统部分&lt;br /&gt;
（由linux kernel来维护管理）和mpp部分（由mpp系统来维护管理）。&lt;br /&gt;
（7）缓冲池需要几个，每个中包含几个缓冲块，每个缓存块多大，都是可以由用户程序设置&lt;br /&gt;
好参数，然后调用MPP的相应API来向MPP申请分配的。&lt;br /&gt;
7.2.2 相关的数据结构和API&lt;br /&gt;
（1）VB_CONF_S   通过这个结构体告诉MPP缓冲池要几个，每个缓冲池要几个缓存块，每个缓冲块有多大&lt;br /&gt;
（2）HI_MPI_VB_SetConf  //VB_CONF_S只是做了个模型，这里是设置，&lt;br /&gt;
（3）HI_MPI_VB_Init     //真正执行了这个操作，开始分配内存了&lt;br /&gt;
VB_CONF_S（点菜，在菜单上把对应的菜给划上了）这个结构体变量定义，做了填充，把模型定下来了；&lt;br /&gt;
HI_MPI_VB_SetConf（把点好的那个菜单交给服务员了）之后就是把模型告诉了&lt;br /&gt;
VB了，HI_MPI_VB_Init （后厨开始按照菜单开始做菜了）之后就是VB真正去执行了，开始分配内存。&lt;/p&gt;

&lt;p&gt;HI_MPI_VB_SetConf()   这个函数就在之前你装载的某个ko里面&lt;br /&gt;
这里需要注意顺序：先HI_MPI_VB_SetConf()再HI_MPI_VB_Init(),相当于先点菜，厨师再做菜&lt;br /&gt;
typedef struct hiVB_CONF_S&lt;br /&gt;
{&lt;br /&gt;
    HI_U32 u32MaxPoolCnt;     /* max count of pools, (0,VB_MAX_POOLS]  */    &lt;br /&gt;
    struct hiVB_CPOOL_S&lt;br /&gt;
    {&lt;br /&gt;
        HI_U32 u32BlkSize;   //每个缓冲池的内部block的大小                     &lt;br /&gt;
        HI_U32 u32BlkCnt;    //每个缓冲池的内部block的数量&lt;br /&gt;
        HI_CHAR acMmzName[MAX_MMZ_NAME_LEN]; //每个缓冲池的名字     &lt;br /&gt;
    }astCommPool[VB_MAX_COMM_POOLS];              //#define VB_MAX_COMM_POOLS 16&lt;br /&gt;
} VB_CONF_S;                                      //相当于定义了16个公共缓冲池&lt;/p&gt;

&lt;p&gt;    /******************************************&lt;br /&gt;
     step  1: init sys variable                         //mpp系统变量的初始化&lt;br /&gt;
    ******************************************/&lt;br /&gt;
这一部分是填充那些变量&lt;/p&gt;

&lt;p&gt;    /******************************************&lt;br /&gt;
     step 2: mpp system init.&lt;br /&gt;
    ***************************************&lt;strong&gt;&lt;em&gt;/&lt;br /&gt;
    &lt;br /&gt;
    /&lt;/em&gt;&lt;/strong&gt;***************************************&lt;br /&gt;
     step 3: start vi dev &amp;amp; chn to capture&lt;br /&gt;
    ******************************************/&lt;br /&gt;
图像的采集，启动VI部分的dev（设备）和chn（通道）&lt;/p&gt;

&lt;p&gt;    /******************************************&lt;br /&gt;
     step 4: start vpss and vi bind vpss&lt;br /&gt;
    ***************************************&lt;strong&gt;&lt;em&gt;/&lt;br /&gt;
VI之后就会传给VPSS，传给VPSS之前先要把它启动起来&lt;br /&gt;
vi bind vpss：VI和VPSS是两个独立的模块.通过bind这操作，MPP系统提供的一个API(bind api)，&lt;br /&gt;
通过调用bind api就可以把VI和VPSS这两个模块绑定起来。绑定起来之后有什么作用呢？&lt;br /&gt;
VI这边当它采集到一帧图像丢到一个VB(VIDEO BUFFER视频缓冲池)里面的缓存块里面之后，这个&lt;br /&gt;
缓存块会自动传送到VPSS里面去。&lt;br /&gt;
    /&lt;/em&gt;&lt;/strong&gt;***************************************&lt;br /&gt;
     step 5: start stream venc&lt;br /&gt;
    ***************************************&lt;strong&gt;&lt;em&gt;/&lt;br /&gt;
VPSS处理完之后就会到VENC里面去。这一步就开始启动VENC单元，如果你要添加水印信息就在这一步去&lt;br /&gt;
添加。H.264编码也在这一步去研究。编码完之后呢就得到H.264的一个码流了。&lt;br /&gt;
    /&lt;/em&gt;&lt;/strong&gt;***************************************&lt;br /&gt;
     step 6: stream venc process -- get stream, then save it to file.&lt;br /&gt;
    ******************************************/&lt;br /&gt;
我们得到H.264码流之后怎么处理呢？&lt;br /&gt;
（1）可以把这个码流打包成一个MP4存储到硬盘里面去，这就是录像。&lt;br /&gt;
（2）也可以分包，分成一个一个视频包通过RTSP传出去。&lt;br /&gt;
（3）也可以像sample一样直接作为一个裸流直接丢到流文件里面去。&lt;br /&gt;
    那么这种流文件必须通过像VLC这种能够解析裸流文件的播放器来观看。&lt;br /&gt;
所以说编码模块只负责输出一段H.264的裸流，这个裸流要怎么办是你的事。&lt;/p&gt;

&lt;p&gt;    /******************************************&lt;br /&gt;
     step 7: exit process&lt;br /&gt;
    ******************************************/&lt;br /&gt;
如果不想录了之后就按两次回车跑到SAMPLE_COMM_VENC_StopGetStream();里面去&lt;/p&gt;

&lt;p&gt;2.8 程序流程分析和MPP初始化详解&lt;/p&gt;

&lt;p&gt;    /******************************************&lt;br /&gt;
     step  1: init sys variable&lt;br /&gt;
    ******************************************/&lt;br /&gt;
（1）初始化MPP的变量&lt;/p&gt;

&lt;p&gt;/******************************************************************************&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;funciton : Get enSize by diffrent sensor&lt;br /&gt;
*****************************************************************************&lt;em&gt;/&lt;br /&gt;
HI_S32 SAMPLE_COMM_VI_GetSizeBySensor(PIC_SIZE_E&lt;/em&gt; penSize)&lt;br /&gt;
{&lt;br /&gt;
    HI_S32 s32Ret = HI_SUCCESS;&lt;br /&gt;
    SAMPLE_VI_MODE_E enMode = SENSOR_TYPE;   //这个SENSOR_TYPE其实是在Makefile.param里面配置的SONY_IMX323_CMOS_1080P_30FPS&lt;br /&gt;
    &lt;br /&gt;
    if (!penSize)    //要传一个可访问的地址&lt;br /&gt;
    {&lt;br /&gt;
        return HI_FAILURE;&lt;br /&gt;
    }&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    switch (enMode)&lt;br /&gt;
    {&lt;br /&gt;
        case PANASONIC_MN34220_SUBLVDS_720P_120FPS:&lt;br /&gt;
        case PANASONIC_MN34220_MIPI_720P_120FPS:&lt;br /&gt;
        case SONY_IMX117_LVDS_720P_240FPS:&lt;br /&gt;
            *penSize = PIC_HD720;&lt;br /&gt;
            break;&lt;br /&gt;
        case APTINA_MT9P006_DC_1080P_30FPS:&lt;br /&gt;
        case PANASONIC_MN34220_SUBLVDS_1080P_30FPS:&lt;br /&gt;
        case PANASONIC_MN34220_MIPI_1080P_30FPS:&lt;br /&gt;
        case OMNIVISION_OV4689_MIPI_1080P_30FPS:&lt;br /&gt;
        case OMNIVISION_OV2718_MIPI_1080P_30FPS:&lt;br /&gt;
        case OMNIVISION_OV2718_2A_MIPI_1080P_30FPS:&lt;br /&gt;
        case SONY_IMX323_CMOS_1080P_30FPS:             //我们就case到这里&lt;br /&gt;
        case APTINA_AR0237_LVDS_1080P_30FPS:&lt;br /&gt;
        case APTINA_AR0330_MIPI_1080P_30FPS:&lt;br /&gt;
        case SONY_IMX178_LVDS_1080P_30FPS:&lt;br /&gt;
        case SONY_IMX185_MIPI_1080P_30FPS:&lt;br /&gt;
        case SONY_IMX290_MIPI_1080P_30FPS:&lt;br /&gt;
        case JX_F22_MIPI_1080P_20FPS:&lt;br /&gt;
        case SMARTSENS_SC2235_CMOS_1080P_20FPS:&lt;br /&gt;
        case SONY_IMX117_LVDS_1080P_120FPS:&lt;br /&gt;
        case APTINA_AR0230_HISPI_1080P_30FPS:&lt;br /&gt;
            *penSize = PIC_HD1080;         //上面这一堆case都会到这里来，&lt;br /&gt;
            break;&lt;br /&gt;
        case APTINA_AR0330_MIPI_1536P_25FPS:&lt;br /&gt;
            *penSize = PIC_QXGA;&lt;br /&gt;
            break;&lt;br /&gt;
        case APTINA_AR0330_MIPI_1296P_25FPS:&lt;br /&gt;
            *penSize = PIC_2304x1296;&lt;br /&gt;
            break;&lt;br /&gt;
        case OMNIVISION_OV4689_MIPI_4M_30FPS:&lt;br /&gt;
            *penSize = PIC_2592x1520;&lt;br /&gt;
            break;&lt;br /&gt;
        case SONY_IMX178_LVDS_5M_30FPS:&lt;br /&gt;
        case OMNIVISION_OV5658_MIPI_5M_30FPS:&lt;br /&gt;
            *penSize = PIC_5M;&lt;br /&gt;
            break;&lt;br /&gt;
        case SONY_IMX226_LVDS_4K_30FPS:&lt;br /&gt;
        case SONY_IMX117_LVDS_4K_30FPS:&lt;br /&gt;
            *penSize = PIC_UHD4K;&lt;br /&gt;
            break;&lt;/p&gt;

&lt;p&gt;        default:&lt;br /&gt;
            break;&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;    return s32Ret;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);   //最终enSize[0]变成了PIC_HD1080&lt;/p&gt;

&lt;p&gt;stVbConf.u32MaxPoolCnt = 128;   //规定缓冲池的上限，就是个空头支票，结合内存大小来给，海思那边有经验的人给出的&lt;/p&gt;

&lt;p&gt;PIC_SIZE_E enSize[2] = {PIC_HD1080, PIC_HD1080};  //最开始初始化的时候其实也是PIC_HD1080&lt;/p&gt;

&lt;p&gt;s32ChnNum   //标识出来是几路码流，比如3路码流是什么意思？同一个sensor输出3路不同分辨率的码流&lt;br /&gt;
一路主码流（原始的没有裁剪的，全功能版本），另外两路（在主码流的基础上经过裁剪缩放等操作简化而来，阉割版本）&lt;br /&gt;
为子码流，客户用手机看的话就用子码流看就行了，没必要看主码流，还可以省点网络带宽，还比较流畅。&lt;/p&gt;

&lt;p&gt;裸流：开发过程中的半成品，把文件头一解析就知道这个文件的分辨率， mp4等都可以查一下文件头来看。&lt;br /&gt;
裸流是没有这个文件头的。720p 1280*720=92万像素至少要留点余量，100万像素以上&lt;br /&gt;
1080p 1920*1080 = 207万像素  至少sensor也要210万像素以上&lt;/p&gt;

&lt;p&gt;    if(s32ChnNum &amp;gt;= 1)    //每一路码流对应一个缓冲池&lt;br /&gt;
    {&lt;br /&gt;
        u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,&lt;br /&gt;
                    enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);//关键是把enSize[0]传进去，&lt;br /&gt;
        stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;                    //从上面的得到enSize[0]为PIC_HD1080&lt;br /&gt;
        #ifndef hi3516ev100                                                 //把SAMPLE_PIXEL_FORMAT（像素格式）传进去，RGB888，RGB565占的字节就不一样&lt;br /&gt;
        stVbConf.astCommPool[0].u32BlkCnt = 10;                             //SAMPLE_SYS_ALIGN_WIDTH对齐排布&lt;br /&gt;
        #else&lt;br /&gt;
        stVbConf.astCommPool[0].u32BlkCnt = 5;&lt;br /&gt;
        #endif&lt;br /&gt;
    }&lt;br /&gt;
    if(s32ChnNum &amp;gt;= 2)&lt;br /&gt;
    {&lt;br /&gt;
        u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,&lt;br /&gt;
                    enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);&lt;br /&gt;
        stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;&lt;br /&gt;
        stVbConf.astCommPool[1].u32BlkCnt =10;&lt;br /&gt;
    }&lt;br /&gt;
    if(s32ChnNum &amp;gt;= 3)&lt;br /&gt;
    {&lt;br /&gt;
        u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,&lt;br /&gt;
                    enSize[2], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);&lt;br /&gt;
        stVbConf.astCommPool[2].u32BlkSize = u32BlkSize;&lt;br /&gt;
        stVbConf.astCommPool[2].u32BlkCnt = 10;&lt;br /&gt;
    }&lt;br /&gt;
为什么不同的码流要对应不同的pool呢？因为不同的码流分辨率不一样，对应的blocksize的大小也就不一样&lt;/p&gt;

&lt;p&gt;    //SAMPLE_PRT(&amp;quot;w:%d, u32AlignWidth:%d\n&amp;quot;, CEILING_2_POWER(stSize.u32Width,u32AlignWidth), u32AlignWidth);&lt;br /&gt;
    u32VbSize = (CEILING_2_POWER(stSize.u32Width, u32AlignWidth) * &lt;br /&gt;
                 CEILING_2_POWER(stSize.u32Height, u32AlignWidth) * &lt;br /&gt;
                 ((PIXEL_FORMAT_YUV_SEMIPLANAR_422 == enPixFmt) ? 2 : 1.5));          //YUV422 4个像素占4+2+2=8个字节，那么每个像素平均占8/4=2个字节&lt;br /&gt;
    u32VbSize=宽*高*每个像素的字节数                                                                      //YUV420 4个像素占4+2+0=6个字节，那么每个像素平均占6/4=1.5个字节&lt;br /&gt;
                                                                                      &lt;br /&gt;
                                                                                      &lt;br /&gt;
 &lt;br /&gt;
        u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\          //最后算出来u32BlkSize一帧图像所需内存的大小&lt;br /&gt;
                    enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);&lt;/p&gt;

&lt;p&gt;/******************************************************************************&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function : vb init &amp;amp; MPI system init&lt;br /&gt;
*****************************************************************************&lt;em&gt;/&lt;br /&gt;
HI_S32 SAMPLE_COMM_SYS_Init(VB_CONF_S&lt;/em&gt; pstVbConf)&lt;br /&gt;
{&lt;br /&gt;
    MPP_SYS_CONF_S stSysConf = {0};&lt;br /&gt;
    HI_S32 s32Ret = HI_FAILURE;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;    HI_MPI_SYS_Exit();  //注意顺序，释放的时候是SYS在前，VB在后的&lt;br /&gt;
    HI_MPI_VB_Exit();   //怕你之前的VB和SYS没处理干净，保险起见，打扫卫生的&lt;br /&gt;
    &lt;br /&gt;
    if (NULL == pstVbConf)&lt;br /&gt;
    {&lt;br /&gt;
        SAMPLE_PRT(&amp;quot;input parameter is null, it is invaild!\n&amp;quot;);&lt;br /&gt;
        return HI_FAILURE;&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;    s32Ret = HI_MPI_VB_SetConf(pstVbConf);   //建立的时候是VB在前&lt;br /&gt;
    if (HI_SUCCESS != s32Ret)&lt;br /&gt;
    {&lt;br /&gt;
        SAMPLE_PRT(&amp;quot;HI_MPI_VB_SetConf failed!\n&amp;quot;);&lt;br /&gt;
        return HI_FAILURE;&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;    s32Ret = HI_MPI_VB_Init();&lt;br /&gt;
    if (HI_SUCCESS != s32Ret)&lt;br /&gt;
    {&lt;br /&gt;
        SAMPLE_PRT(&amp;quot;HI_MPI_VB_Init failed!\n&amp;quot;);&lt;br /&gt;
        return HI_FAILURE;&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;//只要把VB（缓冲池搞好了），SYS里面都是自动化的，海思封装的特别好，我们要操心的是VB的参数pstVbconf&lt;/p&gt;

&lt;p&gt;8.1 学习方法：绘制调用关系图谱&lt;br /&gt;
（1）学习重点1：全局把控熟悉整个过程全景视图&lt;br /&gt;
VI里面：DEV和chanel&lt;/p&gt;

&lt;p&gt;8.2 常用Sensor的接口有三种：MIPI LVDS DC&lt;br /&gt;
WDR ：宽动态范围，很亮和很暗都可以看得很清楚的一种技术。硬件本身要支持才行。&lt;br /&gt;
动态范围：在图像里面能看到的最亮的和最暗的一个比例。&lt;br /&gt;
ISP:image signal process图像信号处理，3518E内部的一个硬件单元，这个硬件单元就是用来做ISP运算的，&lt;br /&gt;
这个模块在MPP里面被封装成了API，SAMPLE_COMM_ISP_Init()函数就是启动ISP这个硬件单元，把这个线程&lt;br /&gt;
运行起来，ISP主要是用来处理图像，比如典型的3A，如果你自己添加了一个专用的ISP芯片，那么你可以不用&lt;br /&gt;
3518E内部的这个ISP模块（不启动它）。&lt;/p&gt;

&lt;p&gt;8.3 进入ISP启动函数SAMPLE_COMM_ISP_Init()我们发现sensor_register_callback()，但是我们找不到&lt;br /&gt;
sensor_register_callback()在哪里定义的，其实它在sensor驱动里面定义的，&lt;br /&gt;
驱动定义目录为Z:\Hi3516CV300_SDK_V1.0.3.0\mpp\component\isp\sensor\sony_imx323\imx323_cmos.c&lt;br /&gt;
int sensor_register_callback(void)&lt;br /&gt;
{&lt;br /&gt;
    ISP_DEV IspDev = 0;&lt;br /&gt;
    HI_S32 s32Ret;&lt;br /&gt;
    ALG_LIB_S stLib;&lt;br /&gt;
    ISP_SENSOR_REGISTER_S stIspRegister;&lt;br /&gt;
    AE_SENSOR_REGISTER_S  stAeRegister;&lt;br /&gt;
    AWB_SENSOR_REGISTER_S stAwbRegister;&lt;/p&gt;

&lt;p&gt;    cmos_init_sensor_exp_function(&amp;amp;stIspRegister.stSnsExp);&lt;br /&gt;
    s32Ret = HI_MPI_ISP_SensorRegCallBack(IspDev, IMX323_ID, &amp;amp;stIspRegister);&lt;br /&gt;
    if (s32Ret)&lt;br /&gt;
    {&lt;br /&gt;
        printf(&amp;quot;sensor register callback function failed!\n&amp;quot;);&lt;br /&gt;
        return s32Ret;&lt;br /&gt;
    }&lt;br /&gt;
    &lt;br /&gt;
    stLib.s32Id = 0;&lt;br /&gt;
    strncpy(stLib.acLibName, HI_AE_LIB_NAME, sizeof(HI_AE_LIB_NAME));&lt;br /&gt;
    cmos_init_ae_exp_function(&amp;amp;stAeRegister.stSnsExp);&lt;br /&gt;
    s32Ret = HI_MPI_AE_SensorRegCallBack(IspDev, &amp;amp;stLib, IMX323_ID, &amp;amp;stAeRegister);&lt;br /&gt;
    if (s32Ret)&lt;br /&gt;
    {&lt;br /&gt;
        printf(&amp;quot;sensor register callback function to ae lib failed!\n&amp;quot;);&lt;br /&gt;
        return s32Ret;&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;    stLib.s32Id = 0;&lt;br /&gt;
    strncpy(stLib.acLibName, HI_AWB_LIB_NAME, sizeof(HI_AWB_LIB_NAME));&lt;br /&gt;
    cmos_init_awb_exp_function(&amp;amp;stAwbRegister.stSnsExp);&lt;br /&gt;
    s32Ret = HI_MPI_AWB_SensorRegCallBack(IspDev, &amp;amp;stLib, IMX323_ID, &amp;amp;stAwbRegister);&lt;br /&gt;
    if (s32Ret)&lt;br /&gt;
    {&lt;br /&gt;
        printf(&amp;quot;sensor register callback function to ae lib failed!\n&amp;quot;);&lt;br /&gt;
        return s32Ret;&lt;br /&gt;
    }&lt;br /&gt;
    &lt;br /&gt;
    return 0;&lt;br /&gt;
}&lt;br /&gt;
这个函数的使用可以参考  ISP_3A 开发指南.pdf    HiISP 开发参考.pdf&lt;/p&gt;

&lt;p&gt;8.4 HI3518E内部ISP单元是隶属于VI模块的，VI模块就包含3大部分：&lt;br /&gt;
第一部分是和sensor对接的部分；第二部分就是ISP，第三部分就是VI dev和channel&lt;br /&gt;
dev就是用来采集图像的一个硬件单元，一个dev可能有好几个通道（分支），可以分成好几条道路（分支），然后&lt;br /&gt;
来进行不同的裁剪，并且每一个通道和后面进行绑定，dev就是一个整体管道，我这个管道有一个入口，从sensor这&lt;br /&gt;
边进去的，但是有3个甚至10出口（通道），每一个出口连接了后端的一个流程，&lt;br /&gt;
Hi3519v101可以接两路sensor自然就有两个dev和两个channel&lt;/p&gt;

&lt;p&gt;9  VPSS部分详解&lt;br /&gt;
VPSS(Video Process Sub-System)  对一幅图像进行统一处理，不是针对某一块&lt;br /&gt;
去噪、去隔行（把隔行扫描的转成逐行扫描的，之前有的sensor是隔行扫描的，现在的sensor一般都是逐行扫描的了）&lt;br /&gt;
然后再对各通道分别进行缩放（我们出来的图像有1080p，有720p，VGA的等就是因为进行了缩放，是在VPSS这里来处理的）&lt;br /&gt;
最后输出多种不同分辨率的图像（从这里可以看出一进多出的，VI是一路进来，VPSS是多路输出的）。&lt;br /&gt;
FRC(Frame Rate Control) Crop（裁剪） NR(Noise Reduce) LDC(Lens Distortion Correction)&lt;br /&gt;
Rotate Cover/Overlay  Scale（缩放）  Mirror/Flip  FishEye（鱼眼）&lt;/p&gt;

&lt;p&gt;基本概念：&lt;/p&gt;

&lt;p&gt;9.1  VPSS手册部分解读&lt;br /&gt;
9.2  VPSS的函数调用关系图谱&lt;/p&gt;

&lt;p&gt;9.3 VPSS部分详解2&lt;br /&gt;
9.3.1 VPSS的Grp和Chn&lt;br /&gt;
Grp是一个组合，一个物理硬件VPSS在软件上的一个映射，如果我们只有一个Grp的话就是物理硬件VPSS在软件上的一个&lt;br /&gt;
1:1的一个映射。&lt;br /&gt;
chn是Grp里面的通道，这个通道有物理的有扩展的，物理通道有对应的硬件，扩展通道没有对应的硬件，扩展通道其实&lt;br /&gt;
是对应了一些功能（缩放等），&lt;br /&gt;
注意：VI的chn和VPSS的chn是两回事，VI那边的chn是VI里面Dev里面的chn，VI那边DEV的地位有点类似于VPSS这边的Grp。&lt;br /&gt;
对接的时候是VI这边的chn去绑定VPSS这边的Grp。&lt;/p&gt;

&lt;p&gt;10.图像编码压缩基本原理&lt;br /&gt;
为什么需要压缩，因为原始的图像数据太多，不利于传输。&lt;/p&gt;

&lt;p&gt;10.1 常见图像、视频、音频数据中存在的冗余类型：&lt;br /&gt;
（1）空间冗余&lt;br /&gt;
一幅图像表面上个采样点的颜色之间往往存在空间的连贯性，比如图片，两只老鼠的颜色，背后的墙，灰色的地板，颜色&lt;br /&gt;
都一样。这些颜色相同的块就可以压缩。&lt;br /&gt;
空间冗余主要发生在单张图片，比如我们的照片。&lt;/p&gt;

&lt;p&gt;（2）时间冗余&lt;br /&gt;
这种冗余主要针对视频。&lt;br /&gt;
运动图像（视频）一般为位于一时间轴区间的一组连续画面，其中的相邻帧往往包含相同的背景和移动物体，只不过移动物体&lt;br /&gt;
所在的空间位置略有不同，所以后一帧的数据与前一帧的数据有许多共同的地方，这种共同性是由于相邻帧记录了相邻时刻的&lt;br /&gt;
同一场景画面，所以称为时间冗余。&lt;/p&gt;

&lt;p&gt;（3）视觉冗余&lt;br /&gt;
人类视觉系统对细微的颜色差异感觉不明显。&lt;br /&gt;
说白了就是图像本身存的清晰度是高于人眼的识别度的，高出了的这些清晰度其实媚眼抛给瞎子了。&lt;br /&gt;
所以干脆把它去掉算了。去掉后对图像来说清晰度是下降了，但对人眼来说感觉不出来。&lt;/p&gt;

&lt;p&gt;10.2 一些概念&lt;br /&gt;
压缩比&lt;br /&gt;
图像质量&lt;br /&gt;
压缩和解压缩的速度&lt;br /&gt;
H.264 profile: 图像清晰度的一个标准（可以理解为普通的清晰度，高清的清晰度）&lt;br /&gt;
         BP（基本的，清晰度最差的，这种编码速度快，压缩比也会高）&lt;br /&gt;
         MP（中等的，主流的）&lt;br /&gt;
         HP（高清的，清晰度最好）&lt;br /&gt;
JPEG：用来做图片的，不是视频&lt;br /&gt;
MOTION JPEG(MJPEG) : 早于H.264的视频压缩标准，过时了&lt;br /&gt;
H.265  只支持MP&lt;br /&gt;
码率控制器（RC）：什么是码率？码率就是数据传输时单位时间传送的数据位数。一般我们用的单位是kbps即千位每秒。&lt;br /&gt;
通俗一点理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件。&lt;br /&gt;
但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。&lt;/p&gt;

&lt;p&gt;10.3 VPSS与VENC绑定关系&lt;br /&gt;
    /*** enSize[0] **/&lt;br /&gt;
    if(s32ChnNum &amp;gt;= 1)&lt;br /&gt;
    {&lt;br /&gt;
        VpssGrp = 0;&lt;br /&gt;
        VpssChn = 0;&lt;br /&gt;
        VencChn = 0;    //从这里可以看出来VPSS的Chn0和Venc的Chn0绑定&lt;/p&gt;

&lt;p&gt;        s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[0],&lt;br /&gt;
                                       gs_enNorm, enSize[0], enRcMode,u32Profile,ROTATE_NONE);&lt;br /&gt;
        if (HI_SUCCESS != s32Ret)&lt;br /&gt;
        {&lt;br /&gt;
            SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);&lt;br /&gt;
            goto END_VENC_1080P_CLASSIC_5;&lt;br /&gt;
        }&lt;/p&gt;

&lt;p&gt;        s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);&lt;br /&gt;
        if (HI_SUCCESS != s32Ret)&lt;br /&gt;
        {&lt;br /&gt;
            SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);&lt;br /&gt;
            goto END_VENC_1080P_CLASSIC_5;&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;/p&gt;

&lt;p&gt;裸流：没有文件头，没有文件格式。文件头就是告诉别人我这个文件（视频，图片等）是什么格式的，比如是mp4的等等。&lt;br /&gt;
播放器拿到这个文件首先要获取我的文件头知道是什么格式的文件后才去处理。&lt;br /&gt;
视频裸流（只有视频数据）你拿到普通的播放器是播放不了的，&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「陶通宁」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/taotongning/article/details/84882431&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/taotongning/article/details/84882431&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mpp</title>
            <link>/hardware/hisilicon/hi3516-mpp-sdk1/</link>
            <pubDate>Fri, 29 Nov 2019 14:58:35 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-sdk1/</guid>
            <description>

&lt;p&gt;命名规则：&lt;br /&gt;
变量定义 以变量类型为前缀&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VB_CONFIG_S             stVbConf;    // 结构体变量 st
SAMPLE_VI_CONFIG_S      stViConfig;
VPSS_CHN_ATTR_S         stVpssChnAttr[VPSS_MAX_PHY_CHN_NUM] = {0};   // 
HI_BOOL                 abChnEnable[VPSS_MAX_PHY_CHN_NUM] = {0};   // 数组变量 a 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/taotongning/article/details/82427955&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/taotongning/article/details/82427955&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.&lt;br /&gt;
/* We just coyp this value of payload type from RTP/RTSP definition */&lt;br /&gt;
typedef enum&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PT_PCMU          = 0,
.......          ....
PT_H265          = 265,
PT_MAX           = 266,
/* add by hisilicon */
PT_AMR           = 1001,
PT_MJPEG         = 1002,
PT_AMRWB         = 1003,
PT_BUTT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} PAYLOAD_TYPE_E;&lt;/p&gt;

&lt;p&gt;#海思源码中，枚举类型都是以大写字母加下划线构成，并以E结尾，结构体是以S结尾&lt;br /&gt;
#这里面PT就是PAYLOAD_TYPE，PAYLOAD简单理解为载体或者载荷，可以这么理解，假设你在传输一个视频，你传输的这个视频是个什么类型的&lt;br /&gt;
#这就是这个视频的PAYLOAD_TYPE，你把RTSP视频传输看成是用饺子皮把饺子馅包起来运走，这个PAYLOAD_TYPE就是问你这个饺子是什么馅的。&lt;br /&gt;
#通过RTSP不仅能传H.264类型的，还可以传其他类型的，都列在枚举里面&lt;br /&gt;
#RTP/RTSP本来就是用来传输音视频的一些东西，音视频的编码种类特别多，那你传输的是怎样一种编码，你要用PAYLOAD_TYPE告诉别人&lt;/p&gt;

&lt;h1 id=&#34;pt-butt是结尾标识符-不能用&#34;&gt;#PT_BUTT是结尾标识符，不能用&lt;/h1&gt;

&lt;p&gt;2.&lt;br /&gt;
PAYLOAD_TYPE_E enPayLoad[3]= {PT_H264, PT_H264,PT_H264};&lt;br /&gt;
#这个变量enPayLoad以en打头就告诉你这个是enum类型的&lt;br /&gt;
#从这个数组有三个变量来看，要编3路视频&lt;/p&gt;

&lt;h1 id=&#34;三路都是h-264的-这里只是一个初始化-后面再去填充&#34;&gt;#三路都是H.264的，这里只是一个初始化，后面再去填充&lt;/h1&gt;

&lt;p&gt;3.&lt;br /&gt;
VPSS_GRP_ATTR_S stVpssGrpAttr;&lt;/p&gt;

&lt;h1 id=&#34;以st打头的就是结构体变量-前的vpss-grp-attr-s就是一个结构体-全部大写-下划线分开-s结尾&#34;&gt;#以st打头的就是结构体变量，前的VPSS_GRP_ATTR_S就是一个结构体，全部大写，下划线分开，S结尾&lt;/h1&gt;

&lt;p&gt;4.&lt;br /&gt;
typedef enum hiPIC_SIZE_E&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PIC_QCIF = 0,  //176*144
PIC_CIF,       //352*288
PIC_2CIF,
PIC_HD1,
PIC_D1,        //704*576
PIC_960H,

PIC_QVGA,    /* 320 * 240 */
PIC_VGA,     /* 640 * 480 */
PIC_XGA,     /* 1024 * 768 */
PIC_SXGA,    /* 1400 * 1050 */
PIC_UXGA,    /* 1600 * 1200 */
PIC_QXGA,    /* 2048 * 1536 */

PIC_WVGA,    /* 854 * 480 */
PIC_WSXGA,   /* 1680 * 1050 */
PIC_WUXGA,   /* 1920 * 1200 */
PIC_WQXGA,   /* 2560 * 1600 */

PIC_HD720,   /* 1280 * 720 */
PIC_HD1080,  /* 1920 * 1080 */
PIC_2304x1296, /* 3M:2304 * 1296 */
PIC_2592x1520, /* 4M:2592 * 1520 */
PIC_5M,        /* 2592 * 1944 */
PIC_UHD4K,     /* 3840 * 2160 */
PIC_12M,       /* 4000 * 3000 */

PIC_BUTT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} PIC_SIZE_E;&lt;/p&gt;

&lt;h1 id=&#34;图片分辨率的&#34;&gt;#图片分辨率的&lt;/h1&gt;

&lt;p&gt;5.&lt;br /&gt;
VB_CONF_S;定义了模型，点菜&lt;br /&gt;
HI_MPI_VB_SetConf; 把模型告诉了VB，点好菜交给服务员&lt;br /&gt;
HI_MPI_VB_Init;VB真正去执行分配了，服务员把点好的菜单交给后厨开始做菜&lt;br /&gt;
#顺序不能搞错&lt;/p&gt;

&lt;h1 id=&#34;可以有多个缓冲池-每个缓冲池又分多个缓存块&#34;&gt;#可以有多个缓冲池，每个缓冲池又分多个缓存块&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;br /&gt;
step 6: stream venc process -- get stream, then save it to file.&lt;br /&gt;
#可以把这个码流打包成一个MP4存储到你的硬盘里面去，这就是录像。&lt;br /&gt;
#也可以分包，分成一个一个的视频包通过RTSP传出去。&lt;br /&gt;
#也可以作为一个裸流直接丢到流文件里面。这个裸流文件必须通过像VLC这些可以解析流文件的播放器才可以观看。&lt;br /&gt;
#裸流是开发过程中的半成品，没有文件头，就得花时间去检测一下这幅图是多大，正常情况不会给别人提供裸流的&lt;br /&gt;
#正常的视频去分辨率都是直接从文件中提取的&lt;br /&gt;
=============================================================================================================&lt;br /&gt;
7.&lt;br /&gt;
step  1: init sys variable   指的是初始化MMP这个系统的变量&lt;br /&gt;
=============================================================================================================&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;br /&gt;
typedef struct hiVB_CONF_S&lt;br /&gt;
{&lt;br /&gt;
HI_U32 u32MaxPoolCnt;     /* max count of pools, (0,VB_MAX_POOLS]  */&lt;br /&gt;
struct hiVB_CPOOL_S&lt;br /&gt;
{&lt;br /&gt;
    HI_U32 u32BlkSize;    /*what the size of each block. */&lt;br /&gt;
    HI_U32 u32BlkCnt;     /&lt;em&gt;How many blocks of each pool&lt;/em&gt;/&lt;br /&gt;
    HI_CHAR acMmzName[MAX_MMZ_NAME_LEN];&lt;br /&gt;
}astCommPool[VB_MAX_COMM_POOLS];&lt;br /&gt;
} VB_CONF_S;&lt;br /&gt;
#u32BlkSize一帧图像的大小决定了一个缓冲块的大小&lt;br /&gt;
#u32BlkCnt 缓冲块的数量按道理来说越多越好，要适量分配，避免浪费。内存大你就多给点避免不够用的情况出现，内存不多就要合理安排&lt;br /&gt;
#step  1: init sys variable这一步是根据我们的实际来核算各路缓存池的BlkSize，BlkCnt，不是随便给的，&lt;br /&gt;
#在这一步整个MPP系统还没有启动&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;=============================================================================================================&lt;br /&gt;
9.&lt;br /&gt;
SAMPLE_COMM_VI_GetSizeBySensor(&amp;amp;enSize[0]);&lt;br /&gt;
#填充变量，命令表明函数的位置在sample/common目录下，意思是通过sensor来算得到的图像大小&lt;br /&gt;
#我们这里的SENSOR是720p的，这个函数出来后就变成720p了&lt;/p&gt;

&lt;h1 id=&#34;刚开始初始化时pic-size-e-ensize-3-pic-hd1080-pic-vga-pic-qvga-给的是这三路码流-经过我们初始化后的到一路720p了&#34;&gt;#刚开始初始化时PIC_SIZE_E enSize[3] = {PIC_HD1080, PIC_VGA,PIC_QVGA};给的是这三路码流,经过我们初始化后的到一路720p了&lt;/h1&gt;

&lt;p&gt;10.&lt;br /&gt;
SAMPLE_VI_MODE_E enMode = SENSOR_TYPE;&lt;br /&gt;
#SENSOR_TYPE是在sample目录下面Makefile.param配置的&lt;/p&gt;

&lt;p&gt;################# select sensor type for your sample ####################&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_9M034_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;SENSOR_TYPE ?= SONY_IMX222_DC_1080P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= SONY_IMX222_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0130_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= PANASONIC_MN34222_MIPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0230_HISPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV9712_DC_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9732_DC_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9750_MIPI_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9752_MIPI_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV2718_MIPI_1080P_25FPS&lt;/p&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;##########################################################################&lt;/h1&gt;

&lt;p&gt;11.&lt;br /&gt;
 if (PIC_HD1080 == enSize[0])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    enSize[1] = PIC_VGA;
    s32ChnNum = 2;
}
else if (PIC_HD720 == enSize[0])
{
    enSize[1] = PIC_VGA;            
    enSize[2] = PIC_QVGA;
    s32ChnNum = 3;
}
else
{
    printf(&amp;quot;not support this sensor\n&amp;quot;);
    return HI_FAILURE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#最后我们得到的是720p，三路码流，enSize[0]=PIC_HD720 enSize[1] = PIC_VGA enSize[2] = PIC_QVGA&lt;br /&gt;
#PIC_HD720是主码流，PIC_VGA，PIC_QVGA是子码流，子码流的意思是通过对主码流裁剪，缩放等操作后得到的。&lt;/p&gt;

&lt;h1 id=&#34;子码流一般是通过手机来观看-手机屏幕毕竟小-没必要hd720-而且还流畅-节省带宽&#34;&gt;#子码流一般是通过手机来观看，手机屏幕毕竟小，没必要HD720，而且还流畅，节省带宽。&lt;/h1&gt;

&lt;p&gt;12.&lt;br /&gt;
stVbConf.u32MaxPoolCnt = 128;&lt;br /&gt;
#视频缓存池的个数是我们自己根据资源估算设置的，128是一个经验值&lt;/p&gt;

&lt;h1 id=&#34;不是实际设置了128个-而是设置了一个上限&#34;&gt;#不是实际设置了128个，而是设置了一个上限&lt;/h1&gt;

&lt;p&gt;13.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*video buffer*/
if(s32ChnNum &amp;gt;= 1)
{
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize[0], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
    stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
    stVbConf.astCommPool[0].u32BlkCnt = g_u32BlkCnt;
}   \\返回一帧图像所要的内存大小即u32VbSize，这个值就是block的大小-----第一路码流的公共缓存池
if(s32ChnNum &amp;gt;= 2)
{
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
                enSize[1], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
    stVbConf.astCommPool[1].u32BlkSize = u32BlkSize;
    stVbConf.astCommPool[1].u32BlkCnt =g_u32BlkCnt;
}   \\---第二路码流的公共缓存池
if(s32ChnNum &amp;gt;= 3)
{
    u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
            enSize[2], SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
    stVbConf.astCommPool[2].u32BlkSize = u32BlkSize;
    stVbConf.astCommPool[2].u32BlkCnt = g_u32BlkCnt;
}   \\---第三路码流的公共缓存池
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#各路缓存池的BlkSize，BlkCnt是不一样的&lt;br /&gt;
#一个缓冲池其实就对应一路码流，&lt;br /&gt;
#为什么要这么分呢，是因为不同的码流分辨率不一样，耗费的内存的块block也不一样，这是为了避免浪费内存空间&lt;br /&gt;
#enSize[0]目前为PIC_HD720，&lt;br /&gt;
#SAMPLE_PIXEL_FORMAT为像素格式，比如RGB888，RGB565就不一样，RGB888 24b占三个字节，RGB565 16b占两个字节&lt;/p&gt;

&lt;h1 id=&#34;sample-sys-align-width对齐&#34;&gt;#SAMPLE_SYS_ALIGN_WIDTH对齐&lt;/h1&gt;

&lt;p&gt;14.&lt;br /&gt;
((PIXEL_FORMAT_YUV_SEMIPLANAR_422 == enPixFmt)?2:1.5));&lt;br /&gt;
#这里指的是平均一个像素占几个字节&lt;br /&gt;
#YUV422 4+2+2=8字节，4个像素一共占了8个字节，那一个像素平均占多少个字节8/4=2字节&lt;/p&gt;

&lt;h1 id=&#34;yuv420-4-2-6字节-4个像素一共占了6个字节-那一个像素平均占多少个字节6-4-1-5字节&#34;&gt;#YUV420 4+2=6字节，4个像素一共占了6个字节，那一个像素平均占多少个字节6/4=1.5字节&lt;/h1&gt;

&lt;p&gt;15.&lt;br /&gt;
u32VbSize += u32HeaderSize;&lt;/p&gt;

&lt;h1 id=&#34;最后还要加上头信息&#34;&gt;#最后还要加上头信息&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;VB_PIC_HEADER_SIZE(stSize.u32Width, stSize.u32Height, enPixFmt, u32HeaderSize);&lt;br /&gt;
u32VbSize += u32HeaderSize;&lt;/p&gt;

&lt;p&gt;return u32VbSize;&lt;/p&gt;

&lt;h1 id=&#34;返回u32vbsize就知道考虑了所有的的余量之后一帧图像要多大内存&#34;&gt;#返回u32VbSize就知道考虑了所有的的余量之后一帧图像要多大内存&lt;/h1&gt;

&lt;p&gt;17.&lt;br /&gt;
/******************************************&lt;br /&gt;
 step 2: mpp system init.&lt;br /&gt;
******************************************/&lt;br /&gt;
s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);&lt;br /&gt;
if (HI_SUCCESS != s32Ret)&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_PRT(&amp;quot;system init failed with %d!\n&amp;quot;, s32Ret);
goto END_VENC_1080P_CLASSIC_0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
#s32Ret = SAMPLE_COMM_SYS_Init(&amp;amp;stVbConf);把参数&amp;amp;stVbConf传进来，stVbConf是一个结构体&lt;br /&gt;
#函数内部用了两个API&lt;/p&gt;

&lt;h1 id=&#34;这两个api分别为-s32ret-hi-mpi-vb-setconf-pstvbconf-s32ret-hi-mpi-vb-init&#34;&gt;#这两个API分别为 s32Ret = HI_MPI_VB_SetConf(pstVbConf); s32Ret = HI_MPI_VB_Init();&lt;/h1&gt;

&lt;p&gt;18.&lt;br /&gt;
/******************************************************************************&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;function : vb init &amp;amp; MPI system init&lt;br /&gt;
******************************************************************************/&lt;br /&gt;
HI_S32 SAMPLE_COMM_SYS_Init(VB_CONF_S *pstVbConf)&lt;br /&gt;
{&lt;br /&gt;
MPP_SYS_CONF_S stSysConf = {0};&lt;br /&gt;
HI_S32 s32Ret = HI_FAILURE;&lt;/p&gt;

&lt;p&gt;HI_MPI_SYS_Exit();&lt;br /&gt;
HI_MPI_VB_Exit();&lt;/p&gt;

&lt;p&gt;if (NULL == pstVbConf)&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_PRT(&amp;quot;input parameter is null, it is invaild!\n&amp;quot;);
return HI_FAILURE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;s32Ret = HI_MPI_VB_SetConf(pstVbConf);&lt;br /&gt;
if (HI_SUCCESS != s32Ret)&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_PRT(&amp;quot;HI_MPI_VB_SetConf failed!\n&amp;quot;);
return HI_FAILURE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;s32Ret = HI_MPI_VB_Init();&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#HI_MPI_SYS_Exit(); 和HI_MPI_VB_Exit(); 打扫场地用的，注意调用顺序，释放是SYS在前，VB在后&lt;br /&gt;
#建立的时候是先VB后SYS&lt;/p&gt;

&lt;h1 id=&#34;其实vb的参数要操点心-pstvbconf自己去算好-余下的都是模式化&#34;&gt;#其实VB的参数要操点心，pstVbConf自己去算好，余下的都是模式化，&lt;/h1&gt;

&lt;p&gt;19.&lt;br /&gt;
//SAMPLE_PRT(&amp;quot;w:%d, u32AlignWidth:%d\n&amp;quot;, CEILING_2_POWER(stSize.u32Width,u32AlignWidth), u32AlignWidth);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;u32VbSize = (CEILING_2_POWER(stSize.u32Width, u32AlignWidth) * \
        CEILING_2_POWER(stSize.u32Height,u32AlignWidth) * \
       ((PIXEL_FORMAT_YUV_SEMIPLANAR_422 == enPixFmt)?2:1.5));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#CEILING_2_POWER(stSize.u32Width, u32AlignWidth) 这个宏的意思是stSize.u32Width向u32AlignWidth对齐&lt;/p&gt;

&lt;h1 id=&#34;怎么对齐-stsize-u32width向上取整-u32alignwidth是64-stsize-u32width为1280-往上数-一直数到够第一个够64整除的数-意思就是往上留点余量&#34;&gt;#怎么对齐，stSize.u32Width向上取整，u32AlignWidth是64，stSize.u32Width为1280，往上数，一直数到够第一个够64整除的数，意思就是往上留点余量&lt;/h1&gt;

&lt;p&gt;20.&lt;br /&gt;
PIXEL_FORMAT_YUV_SEMIPLANAR_420&lt;br /&gt;
#是怎么定成YUV420的&lt;br /&gt;
#其实是写APP的人用宏定义直接定义出来的，他怎么知道把它定成YUV420?&lt;br /&gt;
#define VB_PIC_HEADER_SIZE(Width, Height, Type, size)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do{\
    if (PIXEL_FORMAT_YUV_SEMIPLANAR_422 == Type || PIXEL_FORMAT_RGB_BAYER == Type )\
    {\
        size = VB_HEADER_STRIDE * (Height) * 2;\
    }\
    else if(PIXEL_FORMAT_YUV_SEMIPLANAR_420 == Type)\
    {\
        size = (VB_HEADER_STRIDE * (Height) * 3) &amp;gt;&amp;gt; 1;\
    }\
    else if(PIXEL_FORMAT_YUV_400 == Type)\
    {\
        size = VB_HEADER_STRIDE * (Height);\
    }\
}while(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#PIXEL_FORMAT_RGB_BAYER指的是rawRGB，后面转成RGA，再到YUV，为什么不直接用RGB呢？&lt;br /&gt;
#是因为YUV这种方式表达颜色更加科学，所以最后不管你sensor这边出来是什么格式，一律转成YUV格式&lt;br /&gt;
#你想变成YUV422还是YUV420都可以，自己来定&lt;br /&gt;
#很明显YUV422的颜色分量会多一些，将来出来的色彩的还原度会高一些，但有比较浪费内存，所以自己来权衡颜色分量和内存占用情况&lt;/p&gt;

&lt;h1 id=&#34;行业内yuv420用得比较多&#34;&gt;#行业内YUV420用得比较多&lt;/h1&gt;

&lt;p&gt;21.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/******************************************
 step 3: start vi dev &amp;amp; chn to capture     
******************************************/
stViConfig.enViMode   = SENSOR_TYPE;
stViConfig.enRotate   = ROTATE_NONE;
stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;
stViConfig.enViChnSet = VI_CHN_SET_NORMAL;
stViConfig.enWDRMode  = WDR_MODE_NONE;
s32Ret = SAMPLE_COMM_VI_StartVi(&amp;amp;stViConfig);
if (HI_SUCCESS != s32Ret)
{
    SAMPLE_PRT(&amp;quot;start vi failed!\n&amp;quot;);
    goto END_VENC_1080P_CLASSIC_1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#MPP里面的函数我们追不进去&lt;br /&gt;
#HI_MPI_VI_SetDevAttr  MPI代表MPP interface&lt;br /&gt;
#常用senso接口，MIPI，LVDS，DC（并口）&lt;br /&gt;
#stViConfig.enRotate   = ROTATE_NONE;图像出来要旋转的话在这里设置&lt;br /&gt;
#stViConfig.enNorm     = VIDEO_ENCODING_MODE_AUTO;图像制式的标准有PAL和NTSC两种，对于这种数字接口的sensor来说，不重要。&lt;br /&gt;
#stViConfig.enViChnSet = VI_CHN_SET_NORMAL; 图像镜像，翻转在这里设置&lt;br /&gt;
#stViConfig.enWDRMode  = WDR_MODE_NONE;宽动态，这种技术需要sensor硬件支持。动态范围：在一幅图像中，能看到最亮与最暗的比例&lt;br /&gt;
#动态范围的模式有如下几种&lt;br /&gt;
typedef enum hiWDR_MODE_E&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;WDR_MODE_NONE = 0,
WDR_MODE_BUILT_IN,

WDR_MODE_2To1_LINE,
WDR_MODE_2To1_FRAME,
WDR_MODE_2To1_FRAME_FULL_RATE,

WDR_MODE_3To1_LINE,
WDR_MODE_3To1_FRAME,
WDR_MODE_3To1_FRAME_FULL_RATE,

WDR_MODE_4To1_LINE,
WDR_MODE_4To1_FRAME,
WDR_MODE_4To1_FRAME_FULL_RATE,

WDR_MODE_BUTT,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} WDR_MODE_E;&lt;br /&gt;
#sensor运行需要驱动&lt;br /&gt;
HI_S32 SAMPLE_COMM_VI_SetMipiAttr(SAMPLE_VI_CONFIG_S* pstViConfig)&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HI_S32 fd;
combo_dev_attr_t *pstcomboDevAttr = NULL;

/* mipi reset unrest */
fd = open(&amp;quot;/dev/hi_mipi&amp;quot;, O_RDWR);
if (fd &amp;lt; 0)
{
    printf(&amp;quot;warning: open hi_mipi dev failed\n&amp;quot;);
    return -1;
}
printf(&amp;quot;=============SAMPLE_COMM_VI_SetMipiAttr enWDRMode: %d\n&amp;quot;, pstViConfig-&amp;gt;enWDRMode);

if ( pstViConfig-&amp;gt;enViMode == APTINA_AR0230_HISPI_1080P_30FPS )
{
    pstcomboDevAttr = &amp;amp;HISPI_4lane_SENSOR_AR0230_12BIT_ATTR;
}

if ( pstViConfig-&amp;gt;enViMode == PANASONIC_MN34222_MIPI_1080P_30FPS )
{
    pstcomboDevAttr = &amp;amp;MIPI_2lane_SENSOR_MN34222_12BIT_NOWDR_ATTR;
}

if ( (pstViConfig-&amp;gt;enViMode == OMNIVISION_OV9752_MIPI_720P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == OMNIVISION_OV9750_MIPI_720P_30FPS) )
{
    pstcomboDevAttr = &amp;amp;MIPI_2lane_SENSOR_OV9752_12BIT_NOWDR_ATTR;
}

if ( pstViConfig-&amp;gt;enViMode ==  OMNIVISION_OV2718_MIPI_1080P_25FPS )
{
    pstcomboDevAttr = &amp;amp;MIPI_4lane_SENSOR_OV2718_12BIT_NOWDR_ATTR;
}

if ( (pstViConfig-&amp;gt;enViMode == APTINA_9M034_DC_720P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == APTINA_AR0130_DC_720P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == SONY_IMX222_DC_1080P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == SONY_IMX222_DC_720P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == OMNIVISION_OV9712_DC_720P_30FPS)
    || (pstViConfig-&amp;gt;enViMode == OMNIVISION_OV9732_DC_720P_30FPS) )
{
    pstcomboDevAttr = &amp;amp;MIPI_CMOS3V3_ATTR;
}

if (NULL == pstcomboDevAttr)
{
    printf(&amp;quot;Func %s() Line[%d], unsupported enViMode: %d\n&amp;quot;, __FUNCTION__, __LINE__, pstViConfig-&amp;gt;enViMode);
    close(fd);
    return HI_FAILURE;   
}

if (ioctl(fd, HI_MIPI_SET_DEV_ATTR, pstcomboDevAttr))
{
    printf(&amp;quot;set mipi attr failed\n&amp;quot;);
    close(fd);
    return HI_FAILURE;
}
close(fd);
return HI_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#sensor驱动装载完后会生成/dev/hi_mipi这样的一个设备文件，打开，打开后准备好相应的参数，不同的sensor填充的参数是不一样的&lt;br /&gt;
#填充完以后通过一个ioctl(fd, HI_MIPI_SET_DEV_ATTR, pstcomboDevAttr)，HI_MIPI_SET_DEV_ATTR是3518E给sensor做属性设置的命令，传参的标准都是海思定义好的一个结构体，&lt;br /&gt;
#但是这个结构体在不用的sensor里面是不一样的，&lt;br /&gt;
#ioctl是驱动对应用开放的接口&lt;br /&gt;
#SAMPLE_COMM_VI_SetMipiAttr功能就是在应用层对sensor做一个初始化&lt;br /&gt;
combo_dev_attr_t HISPI_4lane_SENSOR_AR0230_12BIT_ATTR =&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* input mode */
.input_mode = INPUT_MODE_HISPI,
{
    .lvds_attr = 
    {
        .img_size = {1920, 1080},
        HI_WDR_MODE_NONE,
        LVDS_SYNC_MODE_SOL,
        RAW_DATA_12BIT,
        LVDS_ENDIAN_LITTLE,
        LVDS_ENDIAN_LITTLE,
        .lane_id = {0, 1, 2, 3, -1, -1, -1, -1},
        .sync_code = 
        { 
            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}},

            {{0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}, 
            {0x003, 0x007, 0x001, 0x005}} 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_17&#34;&gt;};&lt;/h1&gt;

&lt;p&gt;22.&lt;br /&gt;
/******************************************&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; step 2: configure sensor and ISP (include WDR mode).
 note: you can jump over this step, if you do not use Hi3516A interal isp. 
******************************************/
s32Ret = SAMPLE_COMM_ISP_Init(pstViConfig-&amp;gt;enWDRMode);
if (HI_SUCCESS != s32Ret)
{
    SAMPLE_PRT(&amp;quot;%s: Sensor init failed!\n&amp;quot;, __FUNCTION__);
    return HI_FAILURE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#ISP image signal process 是一种技术，就是做一下数学运算，3518e内部的一个硬件单元&lt;br /&gt;
#这个ISP硬件单元就是专门用来做ISP的，这个模块在MPP里面被封装成了API&lt;br /&gt;
#SAMPLE_COMM_ISP_Init功能就是把这个ISP的线程运行起来&lt;br /&gt;
#ISP里面处理比如3A&lt;br /&gt;
#也可以专门加一个ISP芯片，不用3518e里面这个ISP模块单元，不启动就行，默认就是关闭的&lt;br /&gt;
/******************************************************************************&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;funciton : ISP init&lt;br /&gt;
******************************************************************************/&lt;br /&gt;
HI_S32 SAMPLE_COMM_ISP_Init(WDR_MODE_E  enWDRMode)&lt;br /&gt;
{&lt;br /&gt;
ISP_DEV IspDev = 0;&lt;br /&gt;
HI_S32 s32Ret;&lt;br /&gt;
ISP_PUB_ATTR_S stPubAttr;&lt;br /&gt;
ALG_LIB_S stLib;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#if 0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 0. set cmos iniparser file path */
s32Ret = sensor_set_inifile_path(&amp;quot;configs/&amp;quot;);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: set cmos iniparser file path failed with %#x!\n&amp;quot;, \
           __FUNCTION__, s32Ret);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#endif&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 1. sensor register callback */
s32Ret = sensor_register_callback();
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: sensor_register_callback failed with %#x!\n&amp;quot;, \
           __FUNCTION__, s32Ret);
    return s32Ret;
}

/* 2. register hisi ae lib */
stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AE_LIB_NAME);
s32Ret = HI_MPI_AE_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AE_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}

/* 3. register hisi awb lib */
stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AWB_LIB_NAME);
s32Ret = HI_MPI_AWB_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AWB_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}

/* 4. register hisi af lib */
stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AF_LIB_NAME);
s32Ret = HI_MPI_AF_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AF_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}

/* 5. isp mem init */
s32Ret = HI_MPI_ISP_MemInit(IspDev);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_ISP_Init failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}

/* 6. isp set WDR mode */
ISP_WDR_MODE_S stWdrMode;
stWdrMode.enWDRMode  = enWDRMode;
s32Ret = HI_MPI_ISP_SetWDRMode(0, &amp;amp;stWdrMode);    
if (HI_SUCCESS != s32Ret)
{
    printf(&amp;quot;start ISP WDR failed!\n&amp;quot;);
    return s32Ret;
}

/* 7. isp set pub attributes */
/* note : different sensor, different ISP_PUB_ATTR_S define.
          if the sensor you used is different, you can change
          ISP_PUB_ATTR_S definition */

switch(SENSOR_TYPE)
{
    case APTINA_9M034_DC_720P_30FPS:
    case APTINA_AR0130_DC_720P_30FPS:
        stPubAttr.enBayer               = BAYER_GRBG;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
        break;

    case SONY_IMX222_DC_1080P_30FPS:
        stPubAttr.enBayer               = BAYER_RGGB;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 200;
        stPubAttr.stWndRect.s32Y        = 20;
        stPubAttr.stWndRect.u32Width    = 1920;
        stPubAttr.stWndRect.u32Height   = 1080;
        break;

    case SONY_IMX222_DC_720P_30FPS:
        stPubAttr.enBayer               = BAYER_RGGB;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 200;
        stPubAttr.stWndRect.s32Y        = 20;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
        break;

    case APTINA_AR0230_HISPI_1080P_30FPS:
        stPubAttr.enBayer               = BAYER_GRBG;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1920;
        stPubAttr.stWndRect.u32Height   = 1080;
        break;

    case PANASONIC_MN34222_MIPI_1080P_30FPS:
        stPubAttr.enBayer               = BAYER_GRBG;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1920;
        stPubAttr.stWndRect.u32Height   = 1080;
        break;

    case OMNIVISION_OV9712_DC_720P_30FPS:
        stPubAttr.enBayer               = BAYER_BGGR;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
        break;

    case OMNIVISION_OV9732_DC_720P_30FPS:
        stPubAttr.enBayer               = BAYER_BGGR;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
        break;

    case OMNIVISION_OV9750_MIPI_720P_30FPS:
    case OMNIVISION_OV9752_MIPI_720P_30FPS:
        stPubAttr.enBayer               = BAYER_BGGR;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
        break;

    case OMNIVISION_OV2718_MIPI_1080P_25FPS:
        stPubAttr.enBayer               = BAYER_BGGR;
        stPubAttr.f32FrameRate          = 25;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1920;
        stPubAttr.stWndRect.u32Height   = 1080;
        break;

    default:
        stPubAttr.enBayer      = BAYER_GRBG;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1920;
        stPubAttr.stWndRect.u32Height   = 1080;
        break;
}

s32Ret = HI_MPI_ISP_SetPubAttr(IspDev, &amp;amp;stPubAttr);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_ISP_SetPubAttr failed with %#x!\n&amp;quot;, __FUNCTION__, s32Ret);
    return s32Ret;
}

/* 8. isp init */
s32Ret = HI_MPI_ISP_Init(IspDev);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_ISP_Init failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}

gbIspInited = HI_TRUE;

return HI_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
#sensor_register_callback() IQ调试相关&lt;br /&gt;
#这个函数在sensor驱动里面Z:\Hi3518E_V200R001C01SPC030\Hi3518E V200R001C01SPC030&lt;br /&gt;
#01.software\board\Hi3518E_SDK_V1.0.3.0\package\mpp\component\isp\sensor\ar0130目录的ar0130_cmos.c里面&lt;/p&gt;

&lt;p&gt;/* 2. register hisi ae lib */&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AE_LIB_NAME);
s32Ret = HI_MPI_AE_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AE_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自动曝光&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 3. register hisi awb lib */
stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AWB_LIB_NAME);
s32Ret = HI_MPI_AWB_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AWB_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自动白平衡&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 4. register hisi af lib */
stLib.s32Id = 0;
strcpy(stLib.acLibName, HI_AF_LIB_NAME);
s32Ret = HI_MPI_AF_Register(IspDev, &amp;amp;stLib);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_AF_Register failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自动对焦&lt;br /&gt;
#注册一下3A单元&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 5. isp mem init */
s32Ret = HI_MPI_ISP_MemInit(IspDev);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_ISP_Init failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#给ISP单元分配内存，传这个参数IspDev就可以了，内部自动会去分配内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 6. isp set WDR mode */
ISP_WDR_MODE_S stWdrMode;
stWdrMode.enWDRMode  = enWDRMode;
s32Ret = HI_MPI_ISP_SetWDRMode(0, &amp;amp;stWdrMode);    
if (HI_SUCCESS != s32Ret)
{
    printf(&amp;quot;start ISP WDR failed!\n&amp;quot;);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#设置宽动态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch(SENSOR_TYPE)
{
    case APTINA_9M034_DC_720P_30FPS:
    case APTINA_AR0130_DC_720P_30FPS:
        stPubAttr.enBayer               = BAYER_GRBG;
        stPubAttr.f32FrameRate          = 30;
        stPubAttr.stWndRect.s32X        = 0;
        stPubAttr.stWndRect.s32Y        = 0;
        stPubAttr.stWndRect.u32Width    = 1280;
        stPubAttr.stWndRect.u32Height   = 720;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#stPubAttr.enBayer               = BAYER_GRBG;  RGB原始信号的排列序列，查sensor的datasheet&lt;/p&gt;

&lt;h1 id=&#34;stpubattr-stwndrect-s32x-0&#34;&gt;stPubAttr.stWndRect.s32X        = 0;&lt;/h1&gt;

&lt;h1 id=&#34;stpubattr-stwndrect-s32y-0-图像区域的起始点-0-0&#34;&gt;stPubAttr.stWndRect.s32Y        = 0;   图像区域的起始点（0，0）&lt;/h1&gt;

&lt;p&gt;#ISP初始化以后ISP就已经准备好了&lt;br /&gt;
/* 8. isp init */&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s32Ret = HI_MPI_ISP_Init(IspDev);
if (s32Ret != HI_SUCCESS)
{
    printf(&amp;quot;%s: HI_MPI_ISP_Init failed!\n&amp;quot;, __FUNCTION__);
    return s32Ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#3518E内部ISP单元是隶属于VI模块的&lt;br /&gt;
#VI模块就包括3大部分，第一部分是与sensor对接的部分，第二部分是就是ISP，第三部分就是VI dev和channel部分。&lt;br /&gt;
#VI dev是采集图像的硬件单元，channel是与后端连接的多个出口，也是一个硬件单元。每一个出口就是一个channel。&lt;br /&gt;
#填充完后就设置进去HI_MPI_VI_SetDevAttr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s32Ret = HI_MPI_VI_SetDevAttr(ViDev, &amp;amp;stViDevAttr);
if (s32Ret != HI_SUCCESS)
{
    SAMPLE_PRT(&amp;quot;HI_MPI_VI_SetDevAttr failed with %#x!\n&amp;quot;, s32Ret);
    return HI_FAILURE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#获取WDR模式HI_MPI_ISP_GetWDRMode&lt;br /&gt;
if ( (SAMPLE_VI_MODE_BT1120_1080P != enViMode)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;&amp;amp;(SAMPLE_VI_MODE_BT1120_720P != enViMode) )
{
    s32Ret = HI_MPI_ISP_GetWDRMode(s32IspDev, &amp;amp;stWdrMode);
    if (s32Ret != HI_SUCCESS)
    {
        SAMPLE_PRT(&amp;quot;HI_MPI_ISP_GetWDRMode failed with %#x!\n&amp;quot;, s32Ret);
        return HI_FAILURE;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#使能dev&lt;br /&gt;
s32Ret = HI_MPI_VI_EnableDev(ViDev);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (s32Ret != HI_SUCCESS)
{
    SAMPLE_PRT(&amp;quot;HI_MPI_VI_EnableDev failed with %#x!\n&amp;quot;, s32Ret);
    return HI_FAILURE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#dev循环了一次，因为u32DevNum=1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/******************************************************
 step 4 : config &amp;amp; start vicap dev
******************************************************/
for (i = 0; i &amp;lt; u32DevNum; i++)
{
    ViDev = i;
    s32Ret = SAMPLE_COMM_VI_StartDev(ViDev, enViMode);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;%s: start vi dev[%d] failed!\n&amp;quot;, __FUNCTION__, i);
        return HI_FAILURE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vpss-video-process-sub-system&#34;&gt;VPSS(Video Process Sub-System)&lt;/h3&gt;

&lt;p&gt;#支持对一幅图像进行统一预处理，如去噪，去隔行等。&lt;br /&gt;
#什么是去隔行，就是把隔行转成逐行，因为以前的技术有隔行扫描，不过现在的大多数的sensor都是逐行扫描的了。&lt;br /&gt;
#然后再对各通道分别进行缩放，锐化等处理，最后输出多种不同分辨率的图像。&lt;br /&gt;
#从这句话可以看出，VI到VPSS是当通道输入，多通道输出是从VPSSz这里出去的。扩展通道是从VPSS这里出来的。&lt;br /&gt;
#具体的功能包括FRC(Frame Rate Control)、Crop、NR（Noise Reduce）、LDC（Lens Distortion Correction）&lt;br /&gt;
#Rotate、Cover/Overlay、Scale、Mirror/Flip、FishEye&lt;br /&gt;
#通过调用SYS模块的绑定接口这句话的意思，SYS模块就是MPP，绑定接口就是s32Ret = HI_MPI_SYS_Bind(&amp;amp;stSrcChn, &amp;amp;stDestChn);&lt;br /&gt;
#stSrcChn源头通道是VI，目的通道stDestChn是VPSS&lt;br /&gt;
#group是VPSS硬件在软件上的映射，如果只有一个group那就是VPSS硬件的1:1的映射，不用复用了&lt;br /&gt;
#group里面分了好多个channel；&lt;br /&gt;
#VI里面的channel和group里面的channel是不同的东西&lt;br /&gt;
#是VI这里的channel去绑定VPSS的gruop的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*** enSize[0] **/
if(s32ChnNum &amp;gt;= 1)
{
    VpssGrp = 0;
    VpssChn = 0;
    VencChn = 0;
    s32Ret = SAMPLE_COMM_VENC_Start(VencChn, enPayLoad[0],\
                                   gs_enNorm, enSize[0], enRcMode,u32Profile);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }

    s32Ret = SAMPLE_COMM_VENC_BindVpss(VencChn, VpssGrp, VpssChn);
    if (HI_SUCCESS != s32Ret)
    {
        SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
        goto END_VENC_1080P_CLASSIC_5;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#Profile指的是H.264编码的清晰度，分为baseline mainprofile hightprofile&lt;/p&gt;

&lt;p&gt;/******************************************&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; step 1:  Create Venc Channel
******************************************/
stVencChnAttr.stVeAttr.enType = enType;
switch(enType)
{
    case PT_H264:
    {
        stH264Attr.u32MaxPicWidth = stPicSize.u32Width;
        stH264Attr.u32MaxPicHeight = stPicSize.u32Height;
        stH264Attr.u32PicWidth = stPicSize.u32Width;/*the picture width*/
        stH264Attr.u32PicHeight = stPicSize.u32Height;/*the picture height*/
        stH264Attr.u32BufSize  = stPicSize.u32Width * stPicSize.u32Height;/*stream buffer size*/
        stH264Attr.u32Profile  = u32Profile;/*0: baseline; 1:MP; 2:HP;  3:svc_t */
        stH264Attr.bByFrame = HI_TRUE;/*get stream mode is slice mode or frame mode?*/
        stH264Attr.u32BFrameNum = 0;/* 0: not support B frame; &amp;gt;=1: number of B frames */
        stH264Attr.u32RefNum = 1;/* 0: default; number of refrence frame*/
        memcpy(&amp;amp;stVencChnAttr.stVeAttr.stAttrH264e, &amp;amp;stH264Attr, sizeof(VENC_ATTR_H264_S));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#stH264Attr.u32MaxPicWidth，stH264Attr.u32MaxPicHeight编码通道的最大宽和高，如果给到通道里面的图像比这个大就会被压缩，如果小就丢弃&lt;br /&gt;
#所有图像的宽高stH264Attr.u32PicWidth，stH264Attr.u32PicHeight就应该和最大宽和高设置一样大，这样是最好的，不用处理直接编码&lt;br /&gt;
#stH264Attr.u32BufSize过程中的一个buffer，以像素为单位&lt;/p&gt;

&lt;h1 id=&#34;svc-t是h-264的一个补充标准&#34;&gt;#svc_t是h.264的一个补充标准&lt;/h1&gt;

&lt;p&gt;pstPara = (SAMPLE_VENC_GETSTREAM_PARA_S*)p;&lt;br /&gt;
s32ChnTotal = pstPara-&amp;gt;s32Cnt;&lt;br /&gt;
#s32Cnt告诉你有几路，我们目前有三路&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/******************************************
 step 1:  check &amp;amp; prepare save-file &amp;amp; venc-fd
******************************************/
if (s32ChnTotal &amp;gt;= VENC_MAX_CHN_NUM)
{
    SAMPLE_PRT(&amp;quot;input count invaild\n&amp;quot;);
    return NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#总的通道数大于最大通道提醒输入无效&lt;br /&gt;
for (i = 0; i &amp;lt; s32ChnTotal; i++)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    /* decide the stream file name, and open file to save stream */
    VencChn = i;
    s32Ret = HI_MPI_VENC_GetChnAttr(VencChn, &amp;amp;stVencChnAttr);
    if(s32Ret != HI_SUCCESS)
    {
        SAMPLE_PRT(&amp;quot;HI_MPI_VENC_GetChnAttr chn[%d] failed with %#x!\n&amp;quot;, \
               VencChn, s32Ret);
        return NULL;
    }
    enPayLoadType[i] = stVencChnAttr.stVeAttr.enType;

    s32Ret = SAMPLE_COMM_VENC_GetFilePostfix(enPayLoadType[i], szFilePostfix);
    if(s32Ret != HI_SUCCESS)
    {
        SAMPLE_PRT(&amp;quot;SAMPLE_COMM_VENC_GetFilePostfix [%d] failed with %#x!\n&amp;quot;, \
               stVencChnAttr.stVeAttr.enType, s32Ret);
        return NULL;
    }
    sprintf(aszFileName[i], &amp;quot;stream_chn%d%s&amp;quot;, i, szFilePostfix);
    pFile[i] = fopen(aszFileName[i], &amp;quot;wb&amp;quot;);
    if (!pFile[i])
    {
        SAMPLE_PRT(&amp;quot;open file[%s] failed!\n&amp;quot;, 
               aszFileName[i]);
        return NULL;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#去get流就是跟VENC这边对接的，&lt;br /&gt;
#获取编码输出通道的一些信息HI_MPI_VENC_GetChnAttr&lt;/p&gt;

&lt;h1 id=&#34;enpayloadtype-i-stvencchnattr-stveattr-entype-这个拿出来就是h-264的类型&#34;&gt;enPayLoadType[i] = stVencChnAttr.stVeAttr.enType;这个拿出来就是H.264的类型&lt;/h1&gt;

&lt;p&gt;#SAMPLE_COMM_VENC_GetFilePostfix获取编码后文件名的后缀。比如.h264&lt;br /&gt;
#aszFileName[i]编码后文件名&lt;br /&gt;
#最后这个流就是写到一个文件里面去了pFile[i] = fopen(aszFileName[i], &amp;quot;wb&amp;quot;);一个裸流，裸流就是没有文件头，没有文件格式&lt;br /&gt;
#一般的播放器是播放不了，VLC是面向开发的，支持裸流播放。wb为二级制的形式写入。&lt;/p&gt;

&lt;p&gt;VencFd[i] = HI_MPI_VENC_GetFd(i);&lt;br /&gt;
#取流文件的访问接口，毕竟编码后的文件是封装在里面的，你不能直接去取的&lt;br /&gt;
#什么是流，流就是连续的，你去读只能读一段&lt;/p&gt;

&lt;p&gt;stStream.pstPack = (VENC_PACK_S*)malloc(sizeof(VENC_PACK_S) * stStat.u32CurPacks);&lt;br /&gt;
#通过malloc申请一段内存&lt;/p&gt;

&lt;p&gt;s32Ret = SAMPLE_COMM_VENC_SaveStream(enPayLoadType[i], pFile[i], &amp;amp;stStream);&lt;br /&gt;
#分配了一个payload，我们这是当然是h.264&lt;/p&gt;

&lt;p&gt;/******************************************************************************&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;funciton : save H264 stream&lt;br /&gt;
*****************************************************************************&lt;em&gt;/&lt;br /&gt;
HI_S32 SAMPLE_COMM_VENC_SaveH264(FILE&lt;/em&gt; fpH264File, VENC_STREAM_S *pstStream)&lt;br /&gt;
{&lt;br /&gt;
HI_S32 i;&lt;/p&gt;

&lt;p&gt;for (i = 0; i &amp;lt; pstStream-&amp;gt;u32PackCount; i++)&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fwrite(pstStream-&amp;gt;pstPack[i].pu8Addr+pstStream-&amp;gt;pstPack[i].u32Offset,
       pstStream-&amp;gt;pstPack[i].u32Len-pstStream-&amp;gt;pstPack[i].u32Offset, 1, fpH264File);

fflush(fpH264File);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;return HI_SUCCESS;&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#fwrite只是放到了内存&lt;br /&gt;
#fflush写到flash里面去了，确保断电不丢失，另一方面是内存有限&lt;/p&gt;

&lt;p&gt;/*******************************************************&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 step 2.6 : release stream
                *******************************************************/
                s32Ret = HI_MPI_VENC_ReleaseStream(i, &amp;amp;stStream);
                if (HI_SUCCESS != s32Ret)
                {
                    free(stStream.pstPack);
                    stStream.pstPack = NULL;
                    break;
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#写完了还要调用HI_MPI_VENC_ReleaseStream，海思内部的设计架构，不用考虑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*******************************************************
* step 3 : close save-file
*******************************************************/
for (i = 0; i &amp;lt; s32ChnTotal; i++)
{
    fclose(pFile[i]);
}

return NULL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#我们不想录像后，就关闭文件&lt;/p&gt;

&lt;p&gt;HI_VOID* SAMPLE_COMM_VENC_GetVencStreamProc(HI_VOID *p)&lt;br /&gt;
#这个函数是我们获取视频并且写成文件的一个主线程，这个线程一死，整个录像过程就掉了&lt;/p&gt;

&lt;p&gt;/******************************************&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; step 6: stream venc process -- get stream, then save it to file. 
 1.可以把这个码流打包成一个MP4存储到你的硬盘里面去，这就是录像。
 2.也可以分包，分成一个一个的视频包通过RTSP传出去。
 3.也可以作为一个裸流直接丢到流文件里面。

******************************************/
s32Ret = SAMPLE_COMM_VENC_StartGetStream(s32ChnNum);
if (HI_SUCCESS != s32Ret)
{
    SAMPLE_PRT(&amp;quot;Start Venc failed!\n&amp;quot;);
    goto END_VENC_1080P_CLASSIC_5;
}

printf(&amp;quot;please press twice ENTER to exit this sample\n&amp;quot;);
getchar();
getchar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#这个主线程在这里可以结束，两次回车就会结束，录像停止&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/******************************************
 step 7: exit process 
 刚好是个一个逆过程，要把场地收拾干净，
 就像一个栈，先进后出
******************************************/
SAMPLE_COMM_VENC_StopGetStream();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#主线程结束后，跳到这里，&lt;br /&gt;
HI_S32 SAMPLE_COMM_VENC_StopGetStream()&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (HI_TRUE == gs_stPara.bThreadStart)
{
    gs_stPara.bThreadStart = HI_FALSE;
    pthread_join(gs_VencPid, 0);
}
return HI_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
#gs_stPara.bThreadStart = HI_FALSE; 就把变量设置为FALSE，弄死&lt;br /&gt;
#回收线程 pthread_join(gs_VencPid, 0); 收尸&lt;br /&gt;
#整个程序结束&lt;/p&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VpssGrp = 0;
switch(s32ChnNum)
{
    case 3:
        VpssChn = 2;   
        VencChn = 2;
        SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
        SAMPLE_COMM_VENC_Stop(VencChn);
    case 2:
        VpssChn = 1;   
        VencChn = 1;
        SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
        SAMPLE_COMM_VENC_Stop(VencChn);
    case 1:
        VpssChn = 0;  
        VencChn = 0;
        SAMPLE_COMM_VENC_UnBindVpss(VencChn, VpssGrp, VpssChn);
        SAMPLE_COMM_VENC_Stop(VencChn);
        break;

}
SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_4:    //vpss stop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VpssGrp = 0;
switch(s32ChnNum)
{
    case 3:
        VpssChn = 2;
        SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
    case 2:
        VpssChn = 1;
        SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
    case 1:
        VpssChn = 0;
        SAMPLE_COMM_VPSS_DisableChn(VpssGrp, VpssChn);
    break;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_3:    //vpss stop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_COMM_VI_UnBindVpss(stViConfig.enViMode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_2:    //vpss stop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_COMM_VPSS_StopGroup(VpssGrp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_1:    //vi stop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_COMM_VI_StopVi(&amp;amp;stViConfig);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;END_VENC_1080P_CLASSIC_0:    //system exit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SAMPLE_COMM_SYS_Exit();

return s32Ret;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
#各种不同级别恢复原位的过程，比如VPSS死了，你得把你初始化的MPP初始化给恢复原位&lt;br /&gt;
#注意一个倒影的问题，前面是123，后面是321的一个过程&lt;/p&gt;

&lt;p&gt;==============================================================================================&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ORTP&lt;br /&gt;
#open RTP (RTP的一个开源实现)&lt;br /&gt;
#视频在网络上的传输主要有两种：&lt;br /&gt;
#（1）.基于下载：http or ftp 要播放的话，先从服务器上下载到本地，比如视频网站播放视频，&lt;/p&gt;

&lt;h1 id=&#34;下载的速度可以赶得上播放的速度那就是实时的-网速慢就在那里缓冲-网速快缓冲比播放提前&#34;&gt;下载的速度可以赶得上播放的速度那就是实时的，网速慢就在那里缓冲，网速快缓冲比播放提前。&lt;/h1&gt;

&lt;h1 id=&#34;基于下载的这种模式一般是为了保证视频的质量&#34;&gt;基于下载的这种模式一般是为了保证视频的质量。&lt;/h1&gt;

&lt;p&gt;#（2）.基于实时：RTP/RTSP/RTCP 主要用于视频监控的相关领域。还有直播&lt;/p&gt;

&lt;h1 id=&#34;这种应用一般都是为了保证时间上的同步的应用场景-如果网速不够-牺牲的是画面质量-网速快的时候&#34;&gt;这种应用一般都是为了保证时间上的同步的应用场景。如果网速不够，牺牲的是画面质量。网速快的时候&lt;/h1&gt;

&lt;h1 id=&#34;看到的是清晰实时的画面-网速慢的时候看到的是模糊实时的画面&#34;&gt;看到的是清晰实时的画面，网速慢的时候看到的是模糊实时的画面。&lt;/h1&gt;

&lt;p&gt;#RTP(Real-time Transport Protocol)  可以用来传输语音、视频流等&lt;br /&gt;
#RTSP(Real Time Streaming Protocol)专门用来传输视频流的&lt;br /&gt;
#RTCP(RTP Control Protocol)用来控制用的，传输方与接收方的一个协调，RTCP是RTP的一个补充，因为RTP只传输，不能控制。&lt;br /&gt;
#两种传输方式是没有好坏之分的，关键是你看的应用场景。&lt;/p&gt;

&lt;h1 id=&#34;toc_27&#34;&gt;#&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h.264的编码原理&lt;br /&gt;
#图像的冗余信息：空间冗余，时间冗余，&lt;br /&gt;
#视频编码的关键点：压缩比、算法的复杂度、还原度；求得一个平衡，压缩分为硬压缩，软压缩；3518E就是用了&lt;br /&gt;
#一个硬件单元DSP来压缩，属于硬压缩。&lt;br /&gt;
#H.264的2大组成部分：VCL和NAL  VCL关心的是视频的压缩，NAL关心的是这些被压缩后的视频流如何被网络传输到对方解码&lt;br /&gt;
#h.264编码相关的一些概念&lt;br /&gt;
#(1) 宏块 MB(macroblock) 表示的是一幅图像的一小块区域， 压缩都是以宏块为单位(不是以像素为单位)，因为一个宏块里面的像素是有相似性的&lt;br /&gt;
#(2) 片 slice 帧的一部分&lt;br /&gt;
#(3) 帧 frame 有时候帧只有一个slice，有时候又有多个slice&lt;br /&gt;
#像素组成宏块，宏块组成片，片组成帧，多个帧加起来组成一个序列，多个序列组成了一个码流&lt;br /&gt;
#(4) I帧（非参考帧，只和自己有关，可以理解为图像的第一帧，之前没有参考，做不了时间冗余，只能做帧内压缩，及空间压缩）&lt;br /&gt;
#(5) B帧（参考帧，相当于图像后面的帧，做了空间和时间冗余，压缩的时候前后帧都做了参考，可以这么理解，第二帧与第一帧非常相似，&lt;br /&gt;
#不用记录内容，记录差异就行，这样所占用的空间就小了，还原的时候前后帧都要参考，再把差异修正了就行，谁像就多参考些，&lt;br /&gt;
#因为在编码的时候前面后面的帧都已经出来了）&lt;br /&gt;
#(6) P帧（参考帧，只参考了前一帧，算法复杂度没那么高）&lt;br /&gt;
#I帧必须得有&lt;/p&gt;

&lt;h1 id=&#34;帧率-fps&#34;&gt;#帧率 fps&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NAL单元&lt;br /&gt;
#NAL关系的是VCL的输出的纯视频流如何被表达和封包以利于网络传输&lt;br /&gt;
#NAL部分出来的就是H.264的码流，这部分码流包括纯视频流和封包信息，封包的作用是利于网络传输和解码&lt;br /&gt;
#SODB :String Of Date Bits VCL的输出的纯视频流&lt;br /&gt;
#RBSP: Raw Byte Sequence Payload   在SODB基础上加上了封包（头尾信息）&lt;br /&gt;
#NALU: Network Abstraction Layer Units  h.264里面就是一个一个的NALU&lt;br /&gt;
#关系：SODB + RBSP trailing bits（头尾信息） = RBSP&lt;br /&gt;
#NAL header(1 byte) + RBSP = NALU&lt;br /&gt;
#做编码器的人关心的是VCL部分，做视频传输和解码播放的人关心的是NAL部分&lt;br /&gt;
#雷神作品：SpecialVH264.exe&lt;br /&gt;
#国外工具：Elecard StreamEye Tools&lt;br /&gt;
#二级制工具：winhex&lt;br /&gt;
#网络抓包工具：wireshark&lt;br /&gt;
#播放器：vlc&lt;br /&gt;
#海思平台编码出来的h.264码流都是一个个序列：包含1sps+1pps+1sei+1I帧+若干p帧&lt;br /&gt;
#相关概念&lt;br /&gt;
#序列 sequence ，每个sequence都有一个I帧，本sequence的I帧坏了顶多是丢弃本sequence，不会影响其他sequence.&lt;br /&gt;
#一秒钟一个sequence，每一秒钟的第一个帧都是I帧，往下就有 帧率-1个P帧，每秒钟的sequence数等于帧率。&lt;br /&gt;
#分隔符00 00 00 01在h.264的码流里面是有特殊含义的，表示有一个新的开始，分隔符不是有效数据，相当于房子的墙&lt;br /&gt;
#00 00 00 01后的第一个数据是SPS，长度为14个字节，向后数14个字节后，又遇到分隔符00 00 00 01，分隔符后面是PPS&lt;br /&gt;
#PPS长度为4个字节，然后是分隔符00 00 00 01，接下来是SEI，长度为5个字节，然后是分隔符00 00 00 01，接下来是IDR_SLICE（I帧），&lt;br /&gt;
#然后是分隔符00 00 00 01，接下来就是P帧，依次类推。&lt;/p&gt;

&lt;h1 id=&#34;如果码流数据有00-00-00-那么要转变成-00-00-03-00-避免和分隔符00-00-00-01冲突&#34;&gt;#如果码流数据有00 00 00 ，那么要转变成 00 00 03 00 避免和分隔符00 00 00 01冲突&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h.264中的profile和level&lt;br /&gt;
#profile是对视频压缩等级或档次的描述，profile越高，就说明采用了越高级的压缩特性，越高级的压缩算法。压缩结果就越好，压缩算法的实现对硬件要求就比较高。&lt;br /&gt;
#level是对视频本身特性的描述（码率、分辨率、fps）。Level越高，视频的码率、分辨率、fps越高。&lt;br /&gt;
#在同一个profile里面,level是可以不一样的，比如大家都用的是最基础的profile(Base line Profile)，最后得到的码率、分辨率、帧率也可以不一样。&lt;br /&gt;
#level指的是图像本身的一些参数，profile指的是图像压缩算法的一些参数。&lt;br /&gt;
#h.264 profile分为三个档次，分别为baseline profile（低配，硬件性能要求低）、main profile（主流）、high profile（高配，但是硬件性能要求比较高）。&lt;br /&gt;
#1280*720@30f对应的level是3.1&lt;/p&gt;

&lt;h1 id=&#34;程序中可以配置profile的&#34;&gt;#程序中可以配置profile的&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sequence&lt;br /&gt;
#一段h.264码流其实就是由多个sequence组成的&lt;br /&gt;
#一个sequence持续一秒&lt;br /&gt;
#每个sequence均有固定结构：1sps+1pps+1sei+1I帧+若干P帧&lt;br /&gt;
#p帧的个数等于fps-1&lt;br /&gt;
#sps和pps和sei描述该sequence的图像信息，这些信息有两个功能：网络传输和解码&lt;br /&gt;
#I帧是关键，丢了I帧整个sequence就废了，每个sequence有且只有1个I帧（这只针对海思平台）&lt;br /&gt;
#I帧越大则P帧可以越小，反之I帧越小则I帧会越大&lt;br /&gt;
#I比较大说明I帧包括的信息比较详细，说明I帧的压缩比例没那么高&lt;br /&gt;
#I帧越详细，P帧就越好参考，p帧就会越小。反之，I帧越小，说明I帧压缩的越狠，I帧本身就&lt;br /&gt;
#不是很详细，那么I帧就得内容多一些，否则你I帧也小，P帧也小，图像肯定就不清晰。&lt;br /&gt;
#I帧的大小取决于图像本身内容（图像比较丰富，可压缩的空间就比较小，反之，图像比较单一，可压缩的空间就比较大，I帧压缩与时间没有关系）和压缩算法&lt;br /&gt;
#的空间压缩部分&lt;br /&gt;
#P帧的大小取决于图像的变化剧烈程度，如果这一帧的相对于上一帧变化非常的小，那么这帧P帧就可以很小，反之，如果这一帧的相对于上一帧变化非常的大，&lt;br /&gt;
#那么这帧P帧就很大。&lt;br /&gt;
#视频码率就是数据传输时单位时间传送的数据位数，一般我们用单位是kbps。&lt;br /&gt;
#CBR和VBR下P帧的大小策略会不同，CBR时P帧大小基本恒定，VBR时变化比较剧烈。&lt;br /&gt;
#CRR下就是牺牲图像的清晰度，图像变化剧烈，清晰度就会下降，图像稳定，清晰度就会上升。&lt;/p&gt;

&lt;h1 id=&#34;vbr的情况下是保存图像的清晰度-如果图像变化剧烈-码率就会极大增加-网速吃紧&#34;&gt;#VBR的情况下是保存图像的清晰度，如果图像变化剧烈，码率就会极大增加，网速吃紧。&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;h2 id=&#34;rtsp&#34;&gt;RTSP&lt;/h2&gt;

&lt;p&gt;作者：taotongning&lt;br /&gt;
来源：CSDN&lt;br /&gt;
原文：&lt;a href=&#34;https://blog.csdn.net/taotongning/article/details/82427955&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/taotongning/article/details/82427955&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>golang env</title>
            <link>/language/golang/golang-env/</link>
            <pubDate>Thu, 28 Nov 2019 19:42:45 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/golang-env/</guid>
            <description>

&lt;h1 id=&#34;golang环境变量设置详解&#34;&gt;Golang环境变量设置详解&lt;/h1&gt;

&lt;p&gt;无论你是使用Windows,Linux还是Mac OS操作系统来开发Go应用程序，在安装好Go安装语言开发工具之后，都必须配置好Go语言开发所要求的 环境变量，才算初步完成Go开发环境的搭建。&lt;/p&gt;

&lt;p&gt;但对于一些初学者来说，可能不太明白Go语言中常用的 &lt;code&gt;环境变量(Environment variables)&lt;/code&gt; 的作用以及如何设置环境变量，今天我们来讲讲。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：Go提供的Windows操作系统安装包(.msi后缀)安装完成后，会自动配置几个常用的环境变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;常用环境变量&#34;&gt;常用环境变量&lt;/h2&gt;

&lt;p&gt;Go语言中可以设置的环境变量有很多，每个环境变量都有其作用，不过很多我们可能都用不到，一般需要了解也是最重要的有以下几个：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ go env //打印Go所有默认环境变量 $ go env GOPATH //打印某个环境变量的值&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;goroot&#34;&gt;GOROOT&lt;/h4&gt;

&lt;p&gt;环境变量 &lt;code&gt;GOROOT&lt;/code&gt; 表示Go语言的安装目录。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 中， &lt;code&gt;GOROOT&lt;/code&gt; 的默认值是 &lt;code&gt;C:/go&lt;/code&gt; ，而在 &lt;code&gt;Mac OS&lt;/code&gt; 或 &lt;code&gt;Linux&lt;/code&gt; 中 &lt;code&gt;GOROOT&lt;/code&gt; 的默认值是 &lt;code&gt;usr/loca/go&lt;/code&gt; ，如果将Go安装在其他目录中，而需要将GOROOT的值修改为对应的目录。&lt;/p&gt;

&lt;p&gt;另外， &lt;code&gt;GOROOT/bin&lt;/code&gt; 则包含Go为我们提供的工具链，因此，应该将 &lt;code&gt;GOROOT/bin&lt;/code&gt; 配置到环境变量PATH中，方便我们在全局中使用Go工具链。&lt;/p&gt;

&lt;h5 id=&#34;linux设置goroot演示&#34;&gt;Linux设置GOROOT演示&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;export GOROOT=~/go export PATH= $PATH : $GOROOT /bin&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;gopath&#34;&gt;GOPATH&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;注意， &lt;code&gt;GOPATH&lt;/code&gt; 的值不能与 &lt;code&gt;GOROOT&lt;/code&gt; 相同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;环境变量 &lt;code&gt;GOPATH&lt;/code&gt; 用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;类Unix&lt;/code&gt; (Mac OS或Linux)操作系统中 &lt;code&gt;GOPATH&lt;/code&gt; 的默认值是$home/go。而在Windows中GOPATH的默认值则为%USERPROFILE%\go(比如在Admin用户，其值为C:\Users\Admin\go)。&lt;/p&gt;

&lt;p&gt;当然，我们可以通过修改GOPATH来更换工作区，比如将工作设置 &lt;code&gt;opt/go&lt;/code&gt; 方式如下：&lt;/p&gt;

&lt;h5 id=&#34;linux设置gopath演示&#34;&gt;Linux设置GOPATH演示&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;export GOPATH=/opt/go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还有，可以在GOPATH中设置多个工作区，如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export GOPATH=/opt/go; $home /go&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;gopath的子目录&#34;&gt;GOPATH的子目录&lt;/h5&gt;

&lt;p&gt;上面的代码表示我们指定两个工作区，不过当我们使用 &lt;code&gt;go get&lt;/code&gt; 命令去获取远程库的时候，一般会安装到第一个工作区当中。&lt;/p&gt;

&lt;p&gt;按照Go开发规范，GOPATH目录下的每个工作一般分为三个子目录: &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;pkg&lt;/code&gt; , &lt;code&gt;bin&lt;/code&gt; ，所以我们看到的每个工作区是这样子的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bin/ hello # 可执行文件 outyet # 可执行文件 src/ github.com/golang/example/ .git/ hello/ hello.go # 命令行代码 outyet/ main.go # 命令行代码 main_test.go # 测试代码 stringutil/ reverse.go # 库文件 reverse_test.go # 库文件 golang.org/x/image/ .git/ bmp/ reader.go # 库文件 writer.go # 库文件&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src&lt;/code&gt; 目录放的是我们开发的源代码文件，其下面对应的目录称为 &lt;code&gt;包&lt;/code&gt; , &lt;code&gt;pkg&lt;/code&gt; 放的是编译后的库静态文件， &lt;code&gt;bin&lt;/code&gt; 放的是源代码编译后台的可执行文件。&lt;/p&gt;

&lt;h4 id=&#34;gobin&#34;&gt;GOBIN&lt;/h4&gt;

&lt;p&gt;环境变量 &lt;code&gt;GOBIN&lt;/code&gt; 表示我们开发程序编译后二进制命令的安装目录。&lt;/p&gt;

&lt;p&gt;当我们使用 &lt;code&gt;go install&lt;/code&gt; 命令编译和打包应用程序时，该命令会将编译后二进制程序打包GOBIN目录，一般我们将GOBIN设置为 &lt;code&gt;GOPATH/bin&lt;/code&gt; 目录。&lt;/p&gt;

&lt;h5 id=&#34;linux设置gobin演示&#34;&gt;Linux设置GOBIN演示&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;export GOBIN= $GOPATH /bin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码中，我们都是使用export命令设置环境变量的，这样设置只能在当前shell中有效，如果想一直有效，如在Linux中，则应该将环境变量添加到 &lt;code&gt;/etc/profile&lt;/code&gt; 等文件当中。&lt;/p&gt;

&lt;h2 id=&#34;交叉编译&#34;&gt;交叉编译&lt;/h2&gt;

&lt;p&gt;什么是交叉编译？所谓的交叉编译，是指在一个平台上就能生成可以在另一个平台运行的代码，例如，我们可以32位的Windows操作系统开发环境上，生成可以在64位Linux操作系统上运行的二进制程序。&lt;/p&gt;

&lt;p&gt;在其他编程语言中进行交叉编译可能要借助第三方工具，但在Go语言进行交叉编译非常简单，最简单只需要设置GOOS和GOARCH这两个环境变量就可以了。&lt;/p&gt;

&lt;h4 id=&#34;goos与goarch&#34;&gt;GOOS与GOARCH&lt;/h4&gt;

&lt;p&gt;GOOS的默认值是我们当前的操作系统， 如果windows，linux,注意mac os操作的上的值是darwin。 GOARCH则表示CPU架构，如386，amd64,arm等。&lt;/p&gt;

&lt;h5 id=&#34;获取goos和goarch的值&#34;&gt;获取GOOS和GOARCH的值&lt;/h5&gt;

&lt;p&gt;我们可以使用 &lt;code&gt;go env&lt;/code&gt; 命令获取当前GOOS和GOARCH的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ go env GOOS GOARCH&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;goos和goarch的取值范围&#34;&gt;GOOS和GOARCH的取值范围&lt;/h5&gt;

&lt;p&gt;GOOS和GOARCH的值成对出现，而且只能是下面列表对应的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;

&lt;h5 id=&#34;编译在64位linux操作系统上运行的目标程序&#34;&gt;编译在64位Linux操作系统上运行的目标程序&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;$ GOOS=linux GOARCH=amd64 go build main.go&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;编译arm架构android操作上的目标程序&#34;&gt;编译arm架构Android操作上的目标程序&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;$ GOOS=android GOARCH=arm GOARM=7 go build main.go&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境变量列表&#34;&gt;环境变量列表&lt;/h2&gt;

&lt;p&gt;虽然我们一般虽然配置的环境变量就那么几个，但其实Go语言是提供了非常多的环境变量，让我们可以自由地定制开发和编译器行为。&lt;/p&gt;

&lt;p&gt;下面是Go提供的所有的环境变量列表，一般可以划分为下面几大类，大概了解一下就可以了，因为有些环境变量我们可以永远都不会用到。&lt;/p&gt;

&lt;h4 id=&#34;通过环境变量&#34;&gt;通过环境变量&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GCCGO GOARCH GOBIN GOCACHE GOFLAGS GOOS GOPATH GOPROXY GORACE GOROOT GOTMPDIR&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;和cgo一起使用的环境变量&#34;&gt;和cgo一起使用的环境变量&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CC CGO_ENABLED CGO_CFLAGS CGO_CFLAGS_ALLOW CGO_CFLAGS_DISALLOW CGO_CPPFLAGS, CGO_CPPFLAGS_ALLOW, CGO_CPPFLAGS_DISALLOW CGO_CXXFLAGS, CGO_CXXFLAGS_ALLOW, CGO_CXXFLAGS_DISALLOW CGO_FFLAGS, CGO_FFLAGS_ALLOW, CGO_FFLAGS_DISALLOW CGO_LDFLAGS, CGO_LDFLAGS_ALLOW, CGO_LDFLAGS_DISALLOW CXX PKG_CONFIG AR&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;与系统架构体系相关的环境变量&#34;&gt;与系统架构体系相关的环境变量&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GOARM GO386 GOMIPS GOMIPS64&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;专用的环境变量&#34;&gt;专用的环境变量&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GCCGOTOOLDIR GOROOT_FINAL GO_EXTLINK_ENABLED GIT_ALLOW_PROTOCOL&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;其他环境变量&#34;&gt;其他环境变量&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;GOEXE GOHOSTARCH GOHOSTOS GOMOD GOTOOLDIR&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;

&lt;p&gt;环境变量的设置，可以影响我们开发和编译项目的过程与结果，所以还是很有必要了解一下的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mpp modules</title>
            <link>/hardware/hisilicon/hi3516-mpp-modules/</link>
            <pubDate>Thu, 28 Nov 2019 19:10:29 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-modules/</guid>
            <description>

&lt;p&gt;两种方法：&lt;/p&gt;

&lt;h3 id=&#34;直接通过内核编译&#34;&gt;直接通过内核编译&lt;/h3&gt;

&lt;p&gt;1，直接添加进内核。&lt;br /&gt;
a, 比如进入drivers/char/目录，把xxx.c文件拷贝到该目录&lt;br /&gt;
b, 修改drivers/char/Kconfig文件，自定义仿照其他选项，添加自己的选项XXX。&lt;br /&gt;
c, 修改drivers/char/Makefile文件，添加obj-$(CONFIG_XXX)   += xxx.o&lt;br /&gt;
d, 进入内核根目录，make menuconfig，进入device drivers-&amp;gt;character devices在这里面找到XXX选项，配置成“M”，也就是模块编译，会生成xxx.ko&lt;/p&gt;

&lt;h3 id=&#34;内核文件夹外部编译&#34;&gt;内核文件夹外部编译&lt;/h3&gt;

&lt;p&gt;2，随便建一个目录，写Makefile，这个Makefile里面，要指定内核源码根目录，并调用内核源码的Makefile，来编译当前目录的文件，类似一下格式，可在网上找一个Makefile来修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;
export KERNEL_ROOT?=$(SDK_PATH)/../../osdrv/opensource/kernel/$(KERNEL_NAME)$(POSTFIX)
export CC:=$(CROSS)gcc
export AR:=$(CROSS)ar
OSTYPE:=linux

TARGET := hi_mipi_tx
#*************************************************************************
# 支持文件夹多个c源文件
SRCS := mipi_tx.c \
        mipi_tx_hal.c 
		
INIT_FILE := ../init/$(OSTYPE)/mipi_tx_init.c
SRCS   += $(INIT_FILE)
#*************************************************************************

EXTRA_CFLAGS += -I./
EXTRA_CFLAGS += -I$(OSAL_ROOT)/include


ifeq ($(OSTYPE),liteos)
EXTRA_CFLAGS += $(CFLAGS)
endif

.PHONY: all clean
all: $(OSTYPE)_build
clean: $(OSTYPE)_clean

#############################################
$(TARGET)-objs = $(SRCS:%.c=%.o)
ifneq ($(KERNELRELEASE),)
    obj-m += $(TARGET).o
endif

linux_build:
	@$(MAKE) -C $(KERNEL_ROOT) M=$(PWD) modules

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>linux string strnicmp</title>
            <link>/language/clang/linux-string-strnicmp/</link>
            <pubDate>Thu, 28 Nov 2019 15:06:06 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/clang/linux-string-strnicmp/</guid>
            <description>

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
void main()
{
    char *input=&amp;quot;I am OldWolf&amp;quot;;
    char *str=&amp;quot;I am Oldwolf&amp;quot;;
    int cmp;

    printf(&amp;quot;原字符串分别为：\n%s\n%s\n\n&amp;quot;,str1,str2);

    res=strnicmp(*input, str, strlen(input));
    printf(&amp;quot;%d&amp;quot;,res);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef __HAVE_ARCH_STRNICMP
/**
 * strnicmp - Case insensitive(忽视大小写), length-limited string comparison
 * @s1: One string
 * @s2: The other string
 * @len: the maximum number of characters to compare
 */
int strnicmp(const char *s1, const char *s2, size_t len)
{
	/* Yes, Virginia, it had better be unsigned */
	unsigned char c1, c2;

	c1 = 0;	c2 = 0;
	if (len) {
		do {
			c1 = *s1; c2 = *s2;
			s1++; s2++;
                          //是否已到字符串的末尾或两字符串是否有空串,如果到了末尾或有空串,则比较完毕
			if (!c1)
				break;
			if (!c2)
				break;
                          //如果没有,且字符串相等,则继续比较下个字符
			if (c1 == c2)
				continue;
                          //如果不相同,则同时转换为小写字符再进行比较
			c1 = tolower(c1);
			c2 = tolower(c2);
                          //如果不相同,则比较完毕,否则继续
			if (c1 != c2)
				break;
		} while (--len);
	}
	return (int)c1 - (int)c2;
}
#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;strcmp&lt;br /&gt;
原型：int strcmp(char *s1,char * s2);&lt;br /&gt;
功能：比较字符串s1和s2。&lt;br /&gt;
说明：&lt;br /&gt;
当s1&lt;s2时，返回值&lt;0
当s1=s2时，返回值=0
当s1&gt;s2时，返回值&amp;gt;0&lt;br /&gt;
举例：&lt;br /&gt;
char *s1=&amp;quot;Hello, Programmers!&amp;quot;;&lt;br /&gt;
char *s2=&amp;quot;Hello, programmers!&amp;quot;;&lt;/p&gt;

&lt;h2 id=&#34;r-strcmp-s1-s2-r小于0-参见ascii表&#34;&gt;r=strcmp(s1,s2); //r小于0, 参见ascii表&lt;/h2&gt;

&lt;p&gt;stricmp,strcmpi&lt;br /&gt;
原型：int stricmp(char *s1,char * s2);&lt;br /&gt;
功能：比较字符串s1和s2，但不区分字母的大小写。&lt;br /&gt;
说明：strcmpi是到stricmp的宏定义，实际未提供此函数。&lt;br /&gt;
当s1&amp;lt;s2时，返回值&amp;lt;0&lt;br /&gt;
当s1=s2时，返回值=0&lt;/p&gt;

&lt;h2 id=&#34;当s1-s2时-返回值-0&#34;&gt;当s1&amp;gt;s2时，返回值&amp;gt;0&lt;/h2&gt;

&lt;p&gt;strncmp&lt;br /&gt;
原型：int strcmp(char *s1,char * s2，int n);&lt;br /&gt;
功能：比较字符串s1和s2的前n个字符。&lt;br /&gt;
说明：&lt;br /&gt;
当s1&amp;lt;s2时，返回值&amp;lt;0&lt;br /&gt;
当s1=s2时，返回值=0&lt;/p&gt;

&lt;h2 id=&#34;当s1-s2时-返回值-0-1&#34;&gt;当s1&amp;gt;s2时，返回值&amp;gt;0&lt;/h2&gt;

&lt;p&gt;strnicmp,strncmpi&lt;br /&gt;
原型：int strnicmp(char *s1,char * s2，int n);&lt;br /&gt;
功能：比较字符串s1和s2的前n个字符但不区分大小写。&lt;br /&gt;
说明：strncmpi是到strnicmp的宏定义&lt;br /&gt;
当s1&amp;lt;s2时，返回值&amp;lt;0&lt;br /&gt;
当s1=s2时，返回值=0&lt;/p&gt;

&lt;h2 id=&#34;当s1-s2时-返回值-0-2&#34;&gt;当s1&amp;gt;s2时，返回值&amp;gt;0&lt;/h2&gt;

&lt;p&gt;strcat&lt;br /&gt;
原型：char *strcat(char *dest,char *src);&lt;br /&gt;
功能：把src所指字符串添加到dest结尾处(覆盖dest结尾处的&#39;\0&#39;)并添加&#39;\0&#39;。&lt;br /&gt;
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。&lt;br /&gt;
返回指向dest的指针。&lt;br /&gt;
举例：&lt;br /&gt;
char d[20]=&amp;quot;Golden Global&amp;quot;;&lt;br /&gt;
char *s=&amp;quot; View&amp;quot;;&lt;/p&gt;

&lt;h2 id=&#34;strcat-d-s&#34;&gt;strcat(d,s);&lt;/h2&gt;

&lt;p&gt;strncat&lt;br /&gt;
原型：char *strncat(char *dest,char *src,int n);&lt;br /&gt;
功能：把src所指字符串的前n个字符添加到dest结尾处(覆盖dest结尾处的&#39;\0&#39;)并添加&#39;\0&#39;。&lt;br /&gt;
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。&lt;br /&gt;
返回指向dest的指针。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>linux string strsep</title>
            <link>/language/clang/linux-string-strsep/</link>
            <pubDate>Thu, 28 Nov 2019 14:40:23 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/clang/linux-string-strsep/</guid>
            <description>

&lt;p&gt;/* lib/string.c */&lt;/p&gt;

&lt;h3 id=&#34;strsep函数用于分割字符串&#34;&gt;strsep函数用于分割字符串&lt;/h3&gt;

&lt;p&gt;该函数同strtok函数类似，用来替换strtok函数&lt;/p&gt;

&lt;p&gt;char *strsep(char **s, const char *delim);&lt;/p&gt;

&lt;p&gt;s为指向欲分割的字符串，delim为分隔符，函数将返回分隔符前面的字符串，s将指向分隔符之后的字符串，实例如下：&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;string.h&gt;&lt;/p&gt;

&lt;p&gt;int main(void)&lt;br /&gt;
{&lt;br /&gt;
        char s[] = &amp;quot;hello world!&amp;quot;;&lt;br /&gt;
        char *p = s;&lt;br /&gt;
        char *d = &amp;quot; &amp;quot;;&lt;br /&gt;
        printf(&amp;quot;%s\n&amp;quot;, strsep(&amp;amp;p, d));&lt;br /&gt;
        printf(&amp;quot;%s\n&amp;quot;, p);&lt;/p&gt;

&lt;p&gt;        return 0;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;函数打印如下：&lt;/p&gt;

&lt;p&gt;hello&lt;br /&gt;
world!&lt;/p&gt;

&lt;p&gt;函数原型：&lt;br /&gt;
char *strtok(char *s, const char *delim);&lt;br /&gt;
char *strsep(char **s, const char *delim);&lt;/p&gt;

&lt;p&gt;       功能：strtok和strsep两个函数的功能都是用来分解字符串为一组字符串。s为要分解的字符串，delim为分隔符字符串。&lt;br /&gt;
       返回值：从s开头开始的一个个子串，当没有分割的子串时返回NULL。&lt;br /&gt;
       相同点：两者都会改变源字符串，想要避免，可以使用strdupa（由allocate函数实现）或strdup（由malloc函数实现）。&lt;/p&gt;

&lt;p&gt;strtok函数第一次调用时会把s字符串中所有在delim中出现的字符替换为NULL。然后通过依次调用strtok(NULL, delim)得到各部分子串。&lt;/p&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;p&gt;        对于strsep有如下例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
 
int main(void) {
	char source[] = &amp;quot;hello, world! welcome to china!&amp;quot;;
	char delim[] = &amp;quot; ,!&amp;quot;;
 
	char *s = strdup(source);
	char *token;

	for(token = strsep(&amp;amp;s, delim); token != NULL; token = strsep(&amp;amp;s, delim)) {
		printf(token);
		printf(&amp;quot;+&amp;quot;);
	}
	printf(&amp;quot;\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：hello++world++welcome+to+china++&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
 
int main(void) {
	char s[] = &amp;quot;hello, world! welcome to china!&amp;quot;;
	char delim[] = &amp;quot; ,!&amp;quot;;
 
	char *token;
    
	for(token = strtok(s, delim); token != NULL; token = strtok(NULL, delim)) {
		printf(token);
		printf(&amp;quot;+&amp;quot;);
	}
	printf(&amp;quot;\n&amp;quot;);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：hello+world+welcome+china+&lt;/p&gt;

&lt;p&gt;       为什么用strtok时子串中间只有一个“+”，而strsep却有多个&amp;quot;+&amp;quot;呢？文档中有如下的解释：&lt;/p&gt;

&lt;p&gt;One difference between strsep and strtok_r is that if the input string contains more&lt;br /&gt;
than one character from delimiter in a row strsep returns an empty string for each&lt;br /&gt;
pair of characters from delimiter. This means that a program normally should test&lt;br /&gt;
for strsep returning an empty string before processing it.&lt;/p&gt;

&lt;p&gt;       大意是：如果输入的串的有连续的多个字符属于delim，（此例source中的逗号+空格，感叹号+空格等就是这种情况），strtok会返回NULL，而strsep会返回空串&amp;quot;&amp;quot;。因而我们如果想用strsep函数分割字符串必须进行返回值是否是空串的判断。这也就解释了strsep的例子中有多个&amp;quot;+&amp;quot;的原因。&lt;/p&gt;

&lt;p&gt;       我们在自己的程序中最好尽量避免使用strtok，转而使用strsep。&lt;/p&gt;

&lt;p&gt;       下面的说明摘自于最新的Linux内核2.6.29，说明了strtok()已经不再使用，由速度更快的strsep()代替。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「yafeng_jiang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/yafeng_jiang/article/details/7109285&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/yafeng_jiang/article/details/7109285&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>海思Hi3516A（5）3D降噪</title>
            <link>/hardware/hisilicon/hi3516-mpp-vpss-3d/</link>
            <pubDate>Thu, 28 Nov 2019 14:17:01 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-vpss-3d/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://blog.51cto.com/shugenyin/1896821&#34; target=&#34;_blank&#34;&gt;海思Hi3516A（5）3D降噪-shugenyin的博客-51CTO博客&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;概述&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3D降噪算法是将前后两帧的图像进行对比处理，找出噪点位置，然后对其增益控制。3D数字降噪功能能够降低弱信号图像的噪波干扰。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数接口&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HI_S32 HI_MPI_VPSS_SetGrpParam(VPSS_GRP VpssGrp, VPSS_GRP_PARAM_S*pstVpssParam);&lt;/p&gt;

&lt;p&gt;参数名称    描述  输入/输出&lt;br /&gt;
VpssGrp VPSS GROUP号 输入&lt;br /&gt;
pstVpssParam    高级属性设置  输入&lt;br /&gt;
 VPSS_GRP_PARAM_S结构体：&lt;/p&gt;

&lt;p&gt;typedef struct hiVPSS_GRP_PARAM_S&lt;br /&gt;
{&lt;br /&gt;
HI_U32 u32Contrast;                  //保留&lt;br /&gt;
HI_S32 s32GlobalStrength;            //3DNR降噪强度，[0.1408]&lt;br /&gt;
HI_S32 s32IeStrength;                //图像纹理增强，[-1,100]&lt;br /&gt;
HI_S32 s32YSFStrength;               //亮度空域去噪强度，[-1,100]&lt;br /&gt;
HI_S32 s32YTFStrength;               //亮度时域去噪强度，[-1,15]&lt;br /&gt;
HI_S32 s32CSFStrength;               //色度空域去噪强度，[-1,255]&lt;br /&gt;
HI_S32 s32CTFStrength;               //色域时域去噪强度，[-1,32]&lt;br /&gt;
HI_S32 s32MotionLimen;               //运动阈值，表示NR强度，[-1,32]&lt;br /&gt;
}VPSS_GRP_PARAM_S;&lt;br /&gt;
空域降噪是对单帧进行采样，降噪会牺牲更多的细节；时域降噪是对前后帧进行分析，尽量保留画面细节，但是拍摄剧烈运动可能会有拖影。在实际应用中可根据不同的侧重点(细节、运动、亮度、色度)来调整VPSS_GRP_PARAM_S结构体的成员变量。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PQTools设置界面&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;wKiom1idpfqTyMAPAABzG2glDlQ699.jpg&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码设计&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在SDK包的mpp/tools目录下编写应用程序代码，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* File Name: vpss_attr_3dnr.c
   Author:    shugen.yin
   Date:      2017.2.10
   Function:  3DNR setting
   log:
*/

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;quot;hi_common.h&amp;quot;
#include &amp;quot;hi_comm_video.h&amp;quot;
#include &amp;quot;hi_comm_sys.h&amp;quot;
#include &amp;quot;hi_comm_vo.h&amp;quot;
#include &amp;quot;hi_comm_vi.h&amp;quot;
#include &amp;quot;hi_comm_vpss.h&amp;quot;
#include &amp;quot;hi_type.h&amp;quot;
#include &amp;quot;mpi_vb.h&amp;quot;
#include &amp;quot;mpi_sys.h&amp;quot;
#include &amp;quot;mpi_vi.h&amp;quot;
#include &amp;quot;mpi_vo.h&amp;quot;
#include &amp;quot;mpi_vpss.h&amp;quot;


#define CHECK_RET(express,name)\
    do{\
        if (HI_SUCCESS != express)\
        {\
            printf(&amp;quot;%s failed at %s: LINE: %d ! errno:%#x \n&amp;quot;, \
                   name, __FUNCTION__, __LINE__, express);\
            return HI_FAILURE;\
        }\
    }while(0)


HI_S32 main()
{
    HI_S32 s32Ret=0;
    HI_U8 u8Index = 0;
    VPSS_GRP VpssGrp = 0;
    VPSS_GRP_ATTR_S stVpssGrpAttr = {0};
    VPSS_GRP_PARAM_S stVpssGrpParam = {0};
	
   HI_S32 s32NrParam[4][8] = {	
	{0x0, 0x2f8, 0x0, 0x20, 0xc, 0x8, 0x6, 0x0},
	{0x0, 0x330, 0x0, 0x20, 0xc, 0x8, 0x6, 0x0},
	{0x0, 0x3ea, 0x0, 0x20, 0xc, 0x8, 0x6, 0x0},
	{0x0, 0x458, 0x0, 0x20, 0xc, 0xe, 0xc, 0x0}
    };
    
    s32Ret = HI_MPI_VPSS_GetGrpAttr(VpssGrp, &amp;amp;stVpssGrpAttr);
    CHECK_RET(s32Ret, &amp;quot;HI_MPI_VPSS_GetGrpAttr&amp;quot;);
    s32Ret = HI_MPI_VPSS_GetGrpParam(VpssGrp, &amp;amp;stVpssGrpParam);
    CHECK_RET(s32Ret, &amp;quot;HI_MPI_VPSS_GetGrpParam&amp;quot;);

	stVpssGrpAttr.bNrEn = 1;
	stVpssGrpParam.u32Contrast = s32NrParam[u8Index][0];
	stVpssGrpParam.s32GlobalStrength = s32NrParam[u8Index][1];
	stVpssGrpParam.s32IeStrength = s32NrParam[u8Index][2];
	stVpssGrpParam.s32YSFStrength = s32NrParam[u8Index][3];
	stVpssGrpParam.s32YTFStrength = s32NrParam[u8Index][4];
	stVpssGrpParam.s32CSFStrength = s32NrParam[u8Index][5];
	stVpssGrpParam.s32CTFStrength = s32NrParam[u8Index][6];
	stVpssGrpParam.s32MotionLimen = s32NrParam[u8Index][7];


    s32Ret = HI_MPI_VPSS_SetGrpAttr(VpssGrp, &amp;amp;stVpssGrpAttr);
	CHECK_RET(s32Ret, &amp;quot;HI_MPI_VPSS_SetGrpAttr&amp;quot;);
    s32Ret = HI_MPI_VPSS_SetGrpParam(VpssGrp, &amp;amp;stVpssGrpParam);
    CHECK_RET(s32Ret, &amp;quot;HI_MPI_VPSS_SetGrpParam&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;编译运行&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在mpp/tools目录下执行make命令，生成vpss_attr_3dnr可执行程序，将此可执行程序复制到目标板卡中，执行./vpss_attr_3dnr，3DNR算法模块开始工作。&lt;/p&gt;

&lt;p&gt;wKioL1idp9OghuwZAABV43Ma6gw211.jpg&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;最终结果&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在没有运行vpss_attr_3dnr时，视频显示结果如下图所示，画面有明显的弱噪声。&lt;/p&gt;

&lt;p&gt;wKiom1idqDfyGP4XAAIuqxmFpE4536.jpg&lt;/p&gt;

&lt;p&gt;运行vpss_attr_3dnr后，视频显示结果如下图所示，弱噪声得到明显抑制。&lt;/p&gt;

&lt;p&gt;wKioL1idqKuTDflcAAG9F9pBxF4044.jpg&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mpp HDR</title>
            <link>/hardware/hisilicon/hi3516-mpp-hdr/</link>
            <pubDate>Thu, 28 Nov 2019 14:11:44 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-hdr/</guid>
            <description>&lt;p&gt;&lt;strong&gt;1. HDR概述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HDR(High-Dynamic Range)算法根据不同曝光的图片，合成最终HDR图片，比一般图片具有更宽的动态范围和图像细节。&lt;/p&gt;

&lt;p&gt;一般HDR算法有两种：一种是基于不同曝光时间的连续几幅图片合现,这种方法实现简单，只要能调曝光的sensor都可以实合成一幅图片；第二种是基于同一行不同曝光，最终成一幅图片，这种方法需要sensor支持行间长短曝光。&lt;/p&gt;

&lt;p&gt;这里使用500万分辨率摄像头芯片实现行间长短曝光实现HDR算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. HDR模式传输方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在摄像头芯片中，视频信号通过MIPI接口传输，根据MIPI协议可将长短曝光行数据，通过两个virtual channel来传输。&lt;/p&gt;

&lt;p&gt;行间HDR数据读出时序如下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://s3.51cto.com/wyfs02/M00/8A/E4/wKioL1g-piSDdlSYAAAfJL22VJQ503.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s3.51cto.com/wyfs02/M00/8A/E4/wKioL1g-piSDdlSYAAAfJL22VJQ503.jpg&#34; alt=&#34;wKioL1g-piSDdlSYAAAfJL22VJQ503.jpg&#34; title=&#34;5035_short_long.jpg&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fram_long与Fram_short输出偏差为max short exposure。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;max long exposure={帧长}-max short exposure。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. sensor的库文件生成(.so)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Sensor的库文件需要在Linux服务器中的SDK包中编译得到，将生成的.so文件放到SDK包中的stream软件包中的Hi3516A_Stream_xxx/libs目录下。&lt;/p&gt;

&lt;p&gt;XXXX_sensor_ctl.c实现sensor的初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void sensor_init_5M_2lan_10bit_hdr()
{
	sensor_write_register(0x0100,0x00);sensor_write_register(0x363f,0x1c);
	sensor_write_register(0x3e03,0x03);sensor_write_register(0x3e08,0x00);
	sensor_write_register(0x3e09,0x10);sensor_write_register(0x3400,0x52);
	sensor_write_register(0x5000,0x21);sensor_write_register(0x5001,0x04);
	sensor_write_register(0x3627,0x02);sensor_write_register(0x320c,0x06);
	sensor_write_register(0x3f00,0xc6);sensor_write_register(0x3f01,0x04);
	sensor_write_register(0x3306,0x20);sensor_write_register(0x330b,0x38);
	sensor_write_register(0x4503,0xbb);sensor_write_register(0x3623,0x00);
	sensor_write_register(0x3622,0x0e);sensor_write_register(0x3630,0x34);
	sensor_write_register(0x3303,0x30);sensor_write_register(0x3309,0x30);
	sensor_write_register(0x331e,0x28);sensor_write_register(0x331f,0x28);
	sensor_write_register(0x3320,0x2c);sensor_write_register(0x3321,0x2c);
	sensor_write_register(0x3322,0x2c);sensor_write_register(0x3323,0x2c);
	sensor_write_register(0x5001,0x05);sensor_write_register(0x3902,0x05);
	sensor_write_register(0x3909,0x02);sensor_write_register(0x3907,0x00);
	sensor_write_register(0x3908,0x40);sensor_write_register(0x3416,0x00);
	sensor_write_register(0x3621,0x18);
	sensor_write_register(0x3627,0x04);sensor_write_register(0x3333,0x00);
	sensor_write_register(0x3334,0xf0);sensor_write_register(0x3662,0x82);
	sensor_write_register(0x3e09,0x50);sensor_write_register(0x3908,0x00);
	sensor_write_register(0x3620,0x62);sensor_write_register(0x5000,0x21);
	sensor_write_register(0x3e09,0xf0);sensor_write_register(0x3400,0x52);
	sensor_write_register(0x3638,0x84);sensor_write_register(0x3637,0x82);
	sensor_write_register(0x363f,0x0c);sensor_write_register(0x3622,0x02);
	sensor_write_register(0x330b,0x3c);sensor_write_register(0x363a,0x1c);
	sensor_write_register(0x3c00,0x41);sensor_write_register(0x3e01,0x10);
	sensor_write_register(0x3e05,0x00);sensor_write_register(0x3e06,0xf0);
	sensor_write_register(0x3221,0x80);sensor_write_register(0x4816,0x11);
	sensor_write_register(0x3e04,0x03);sensor_write_register(0x6000,0x21);
	sensor_write_register(0x320e,0x0f); //max inttime
	sensor_write_register(0x320f,0x80); //max inttime
	sensor_write_register(0x3e15,0x00); //max short exposure
	sensor_write_register(0x3e16,0x40); //max short exposure
	sensor_write_register(0x3c00,0x00); //[2]: 0  mipi-&amp;gt;fifo
	sensor_write_register(0x303f,0x02); //[7]: 0  sel pll_pclk
	sensor_write_register(0x3031,0x0a); //[3:0] 10bit
	sensor_write_register(0x3018,0x33); //[7:5]  sel lane=reg+1
	sensor_write_register(0x3c03,0x10); //fifo for 4lane
	sensor_write_register(0x3030,0x04);
	sensor_write_register(0x303d,0x01);sensor_write_register(0x303b,0x02);
	sensor_write_register(0x303c,0x08);sensor_write_register(0x3650,0x37);
	sensor_write_register(0x363f,0x0c);sensor_write_register(0x3300,0x10);
	sensor_write_register(0x3654,0x45);sensor_write_register(0x3902,0x45);
	sensor_write_register(0x3909,0x00);sensor_write_register(0x390a,0x00);
	sensor_write_register(0x3400,0x53);sensor_write_register(0x3039,0x10);
	sensor_write_register(0x303a,0x18);sensor_write_register(0x330a,0x01);
	sensor_write_register(0x330b,0x40);sensor_write_register(0x3306,0x80);
	sensor_write_register(0x3308,0x08);sensor_write_register(0x3416,0x20);
	sensor_write_register(0x320c,0x04);sensor_write_register(0x3907,0x03);
	sensor_write_register(0x3626,0x30); //0909
	sensor_write_register(0x5000,0x21);sensor_write_register(0x330b,0xa0);
	sensor_write_register(0x3630,0x24); //0x14
	sensor_write_register(0x3620,0x48);sensor_write_register(0x3f05,0xf0);
	sensor_write_register(0x320c,0x05);sensor_write_register(0x3e09,0x10);
	sensor_write_register(0x320d,0xa0); //25fps
	sensor_write_register(0x3c00,0x41); //fifo configsensor_write_register(0x3622,0x02);
	sensor_write_register(0x3638,0x83);sensor_write_register(0x3306,0x90);
	sensor_write_register(0x3f05,0xe0);sensor_write_register(0X3620,0X42);
	sensor_write_register(0x363a,0x14);sensor_write_register(0x3416,0x11);
	sensor_write_register(0x3334,0xa0);sensor_write_register(0x3333,0x90);
	sensor_write_register(0x3620,0x46); //0x66  gain&amp;lt;2
	sensor_write_register(0x3303,0x48);sensor_write_register(0x3309,0x48);
	sensor_write_register(0x3627,0x08);
	sensor_write_register(0x335d,0x00);sensor_write_register(0x330e,0x10);
	sensor_write_register(0x303c,0x08); //half mipi speed
	sensor_write_register(0x363c,0xc3);
	sensor_write_register(0x3010,0xe0); //close dvp out
	sensor_write_register(0x300f,0xff);sensor_write_register(0x300e,0x0f);
	sensor_write_register(0x3635,0x38);sensor_write_register(0x3636,0x38);
	sensor_write_register(0x363f,0x80);sensor_write_register(0x3631,0x02);
	sensor_write_register(0x3637,0x82);sensor_write_register(0x3035,0xca);
	sensor_write_register(0x3300,0x30);sensor_write_register(0x330b,0x60);
	sensor_write_register(0x3f04,0x03);sensor_write_register(0x3f05,0x30);
	sensor_write_register(0x3633,0x1e);sensor_write_register(0x3630,0x1c);
	sensor_write_register(0x3622,0x06);sensor_write_register(0x0100,0x01);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;XXXX_cmos.c主要实现ISP需要的回调函数，传递参数，包括ISP、AE、AWB等。还需将变量genSensorMode赋值为WDR_MODE_2To1_LINE，以选择行间HDR模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//ISP function
HI_S32 cmos_init_sensor_exp_function(ISP_SENSOR_EXP_FUNC_S *pstSensorExpFunc)
{
    memset(pstSensorExpFunc, 0, sizeof(ISP_SENSOR_EXP_FUNC_S));

    pstSensorExpFunc-&amp;gt;pfn_cmos_sensor_init = sensor_init;
    pstSensorExpFunc-&amp;gt;pfn_cmos_sensor_exit = sensor_exit;
    pstSensorExpFunc-&amp;gt;pfn_cmos_sensor_global_init = sensor_global_init;
    pstSensorExpFunc-&amp;gt;pfn_cmos_set_p_w_picpath_mode = cmos_set_p_w_picpath_mode;
    pstSensorExpFunc-&amp;gt;pfn_cmos_set_wdr_mode = cmos_set_wdr_mode;

    pstSensorExpFunc-&amp;gt;pfn_cmos_get_isp_default = cmos_get_isp_default;
    pstSensorExpFunc-&amp;gt;pfn_cmos_get_isp_black_level = cmos_get_isp_black_level;
    pstSensorExpFunc-&amp;gt;pfn_cmos_set_pixel_detect = cmos_set_pixel_detect;
    pstSensorExpFunc-&amp;gt;pfn_cmos_get_sns_reg_info = cmos_get_sns_regs_info;

    return 0;
}

//AE function
HI_S32 cmos_init_ae_exp_function(AE_SENSOR_EXP_FUNC_S *pstExpFuncs)
{
    memset(pstExpFuncs, 0, sizeof(AE_SENSOR_EXP_FUNC_S));

    pstExpFuncs-&amp;gt;pfn_cmos_get_ae_default    = cmos_get_ae_default;
    pstExpFuncs-&amp;gt;pfn_cmos_fps_set           = cmos_fps_set;
    pstExpFuncs-&amp;gt;pfn_cmos_slow_framerate_set= cmos_slow_framerate_set;    
    pstExpFuncs-&amp;gt;pfn_cmos_inttime_update    = cmos_inttime_update;
    pstExpFuncs-&amp;gt;pfn_cmos_gains_update      = cmos_gains_update;
    pstExpFuncs-&amp;gt;pfn_cmos_again_calc_table  = cmos_again_calc_table;
    pstExpFuncs-&amp;gt;pfn_cmos_get_inttime_max   = cmos_get_inttime_max; 

    return 0;
}

//AWB function
HI_S32 cmos_init_awb_exp_function(AWB_SENSOR_EXP_FUNC_S *pstExpFuncs)
{
    memset(pstExpFuncs, 0, sizeof(AWB_SENSOR_EXP_FUNC_S));

    pstExpFuncs-&amp;gt;pfn_cmos_get_awb_default = cmos_get_awb_default;

    return 0;
}

HI_U8 gu8SensorImageMode = SENSOR_5M_25FPS_MODE;
WDR_MODE_E genSensorMode = WDR_MODE_2To1_LINE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与一般sensor设置曝光不同，HDR行间模式需要行间交替实现曝光时间设置，也是在XXXX_cmos.c中实现，具体函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static HI_VOID cmos_inttime_update(HI_U32 u32IntTime)
{
    static HI_BOOL bFirst = HI_TRUE;

    if (WDR_MODE_2To1_LINE == genSensorMode)
    {
        if (bFirst) //short exposure
        {
            au32WDRIntTime[0] = u32IntTime;
            g_stSnsRegsInfo.astI2cData[4].u32Data = (u32IntTime &amp;gt;&amp;gt; 4) &amp;amp; 0xFF; ;
            g_stSnsRegsInfo.astI2cData[5].u32Data = (u32IntTime&amp;lt;&amp;lt;4) &amp;amp; 0xF0;
            bFirst = HI_FALSE;
        }
        else //long exposure 
        {
            au32WDRIntTime[1] = u32IntTime;
            g_stSnsRegsInfo.astI2cData[0].u32Data = (u32IntTime &amp;gt;&amp;gt; 4) &amp;amp; 0xFF; ;
            g_stSnsRegsInfo.astI2cData[1].u32Data = (u32IntTime&amp;lt;&amp;lt;4) &amp;amp; 0xF0;
            bFirst = HI_TRUE;
        }
    }
    else
    {
        g_stSnsRegsInfo.astI2cData[0].u32Data = (u32IntTime &amp;gt;&amp;gt; 4) &amp;amp; 0xFF; ;
        g_stSnsRegsInfo.astI2cData[1].u32Data = (u32IntTime&amp;lt;&amp;lt;4) &amp;amp; 0xF0;
        bFirst = HI_TRUE;
    }

    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; &lt;strong&gt;修改stream软件包的.ini文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[sensor]
Sensor_type   =XXXX                   ;sensor name
Mode          =2                        ;WDR_MODE_NONE = 0
                                        ;WDR_MODE_BUILT_IN = 1
                                        ;WDR_MODE_2To1_LINE = 2
                                        ;WDR_MODE_2To1_FRAME = 3
                                        ;WDR_MODE_2To1_FRAME_FULL_RATE =4 ...etc
DllFile   =libs/libsns_XXXX_2lan.so        ;sensor lib path

[mode]                               
input_mode =0                           ;INPUT_MODE_MIPI = 0
                                        ;INPUT_MODE_SUBLVDS = 1
                                        ;INPUT_MODE_LVDS = 2 ...etc

dev_attr = 0                             ;mipi_dev_attr_t = 0
                                        ;lvds_dev_attr_t = 1
                                        ;NULL =2

[mipi]    
;----------only for mipi_dev---------               
data_type = 1                         ;raw data type: 8/10/12/14 bit
                                        ;RAW_DATA_8BIT = 0
                                        ;RAW_DATA_10BIT = 1
                                        ;RAW_DATA_12BIT = 2 
                                        ;RAW_DATA_14BIT = 3 
lane_id = 0| 1 | -1 | -1 |-1|-1|-1|-1|        ;lane_id: -1 - disable

[isp_p_w_picpath]
Isp_x      =0
Isp_y      =0
Isp_W      =2560
Isp_H      =1920
Isp_FrameRate=25
Isp_Bayer  =3   ;BAYER_RGGB=0, BAYER_GRBG=1, BAYER_GBRG=2, BAYER_BGGR=3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;****&lt;strong&gt;5. 运行stream软件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运行stream软件包中的HiIspTool.sh脚本，通过以太网卡与上位机的PQTools建立通信。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd Hi3516A_Stream_V1.0.5.0
./HiIspTools.sh -a -p XXXX_5m_2lan.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;**6. &lt;strong&gt;运行PQ Tools&lt;/strong&gt;**&lt;/p&gt;

&lt;p&gt;双击PQ Tools图片，弹出如下对话框，设置IP地址。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://s2.51cto.com/wyfs02/M00/8A/E9/wKiom1g-rQOzEBwkAABXGsymKlU653.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s2.51cto.com/wyfs02/M00/8A/E9/wKiom1g-rQOzEBwkAABXGsymKlU653.jpg&#34; alt=&#34;wKiom1g-rQOzEBwkAABXGsymKlU653.jpg&#34; title=&#34;pqtools.jpg&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在下拉菜单中选择TTP_Stream.exe选项.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://s2.51cto.com/wyfs02/M01/8A/E9/wKiom1g-rWbxTn5iAAD8w5OOHLU056.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s2.51cto.com/wyfs02/M01/8A/E9/wKiom1g-rWbxTn5iAAD8w5OOHLU056.jpg&#34; alt=&#34;wKiom1g-rWbxTn5iAAD8w5OOHLU056.jpg&#34; title=&#34;pqt0.jpg&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 结果对比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正常光照下的图片，日光灯显示模糊。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://s2.51cto.com/wyfs02/M02/8A/E5/wKioL1g-rbyybcZhAAG1y_7YTJg874.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s2.51cto.com/wyfs02/M02/8A/E5/wKioL1g-rbyybcZhAAG1y_7YTJg874.jpg&#34; alt=&#34;wKioL1g-rbyybcZhAAG1y_7YTJg874.jpg&#34; title=&#34;5035_normal.jpg&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打开灯板后，无法捕捉宽动态范围的的场景，盒中的水果不能正常显示(偏黑),灯板的LED阵列无法识别，背景也非常昏暗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://s5.51cto.com/wyfs02/M00/8A/E9/wKiom1g-rqmB3J0xAAE6o8J6aow423.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s5.51cto.com/wyfs02/M00/8A/E9/wKiom1g-rqmB3J0xAAE6o8J6aow423.jpg&#34; alt=&#34;wKiom1g-rqmB3J0xAAE6o8J6aow423.jpg&#34; title=&#34;5035_normal2.jpg&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开启行间HDR功能后，盒中中的水果可以清晰辨认，灯板的LED阵列也可清晰辨认，背景可见度有很大提升。  ****&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://s4.51cto.com/wyfs02/M02/8A/E5/wKioL1g-r37RrK1bAAGhutXZO2Q040.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://s4.51cto.com/wyfs02/M02/8A/E5/wKioL1g-r37RrK1bAAGhutXZO2Q040.jpg&#34; alt=&#34;wKioL1g-r37RrK1bAAGhutXZO2Q040.jpg&#34; title=&#34;5035_hdr2.jpg&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>记录一次Hi3518E新添sensor的过程</title>
            <link>/hardware/hisilicon/hi3516-camera-sensor/</link>
            <pubDate>Thu, 28 Nov 2019 13:39:29 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-camera-sensor/</guid>
            <description>

&lt;p&gt;记录一次Hi3518E新添sensor的过程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;向sensor原厂要这些.ini和驱动，海思SDK是不会提供的&lt;/code&gt;&lt;br /&gt;
mask地址设置时要注意&lt;/p&gt;

&lt;p&gt;使用的sensor是海思列表没有支持的SC2235，主要需要了解到这个sensor的配置已经地址（需要向sensor原厂要驱动sc2235_cmos.c sc2235_sensor_ctl.c  sc2235_1080p_line.ini vpss_attr_2235.c）编译为.so .a以供测试代码调用。&lt;/p&gt;

&lt;p&gt;首先在ko加载时就要添加自己的sensor，./load3518e -a -sensor sc2235 -osmem 32 -total 64&lt;br /&gt;
在load3518e 脚本中的函数insert_sns()中添加自己sensor对应的地址。&lt;br /&gt;
否则会报错“Invalid sensor type”&lt;/p&gt;

&lt;p&gt;问题1：&lt;br /&gt;
Unknown symbol in module, or unknown parameter(rmmod 执行失败，请忽视错误，开机第一次加载ko，会先删除rmmode，为空肯定报错)&lt;br /&gt;
operation not permitted&lt;br /&gt;
load3518e执行失败，ko插入失败&lt;br /&gt;
第一反应肯定是linux版本不匹配，嗯，事实上并不是，很可能是OS和MMZ的地址重叠了。&lt;br /&gt;
需要看你DDR内存大小，海思教程中的DDR是128MB的，如果你一样，那就跟着教程走就ok&lt;br /&gt;
不幸的是，我们的DDR是64MB，那么你可以参照下面的修改&lt;br /&gt;
setenv bootargs &#39;mem=32M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 mtdparts=hi_sfc:1M(boot),3M(kernel),12M(rootfs)&#39;&lt;br /&gt;
setenv bootcmd &#39;sf probe 0;sf read 0x82000000 0x100000 0x300000;bootm 0x82000000&#39;&lt;br /&gt;
saveenv&lt;br /&gt;
上面的修改就够了，以后的都按照默认走，我也顺带贴出来&lt;br /&gt;
SNS_TYPE=ar0230             # sensor type&lt;/p&gt;

&lt;p&gt;mem_total=64;               # 64M, total mem&lt;br /&gt;
mem_start=0x80000000;       # phy mem start&lt;/p&gt;

&lt;p&gt;os_mem_size=32;             # 32M, os mem&lt;br /&gt;
mmz_start=0x82000000;       # mmz start addr&lt;br /&gt;
mmz_size=32M;               # 32M, mmz size&lt;/p&gt;

&lt;p&gt;MMZ地址肯定是从82000000开始的，OS最开始是从bootm 0x82000000启动的，但是启动后会回盖到0x80000000的 ，所以不用担心0x82000000重叠，正如文档所述，正常运行后的地址分配如图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DDR:                                                           

-----|-------|  0x80000000   # Memory managed by OS.              
32M  | OS    |                                                
     |       |                                                
-----|-------|  0x82000000   # Memory managed by MMZ block anonymous.         
32 M | MMZ   |                                                
     |       |                                                
-----|-------|  0x84000000   # Memory managed by MMZ block jpeg.                       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一切顺利的话，lsmod会有如下显示:&lt;/p&gt;

&lt;p&gt;Module                  Size  Used by    Tainted: P&lt;br /&gt;
hi_mipi                22587  0&lt;br /&gt;
hi3518e_adec            6546  0&lt;br /&gt;
hi3518e_aenc           46989  0&lt;br /&gt;
hi3518e_ao            105952  0&lt;br /&gt;
hi3518e_ai            109706  1 hi3518e_aenc&lt;br /&gt;
hi3518e_aio            28363  0&lt;br /&gt;
acodec                  8242  0&lt;br /&gt;
piris                   3220  0&lt;br /&gt;
pwm                     2471  0&lt;br /&gt;
sensor_i2c              1501  0&lt;br /&gt;
hi3518e_ive            76660  0&lt;br /&gt;
hi3518e_jpege          51824  0&lt;br /&gt;
hi3518e_h264e         172210  0&lt;br /&gt;
hi3518e_chnl           33659  0&lt;br /&gt;
hi3518e_venc          216283  2 hi3518e_jpege,hi3518e_h264e&lt;br /&gt;
hi3518e_rc             62388  0&lt;br /&gt;
hifb                   72068  0&lt;br /&gt;
hi3518e_vou           168985  1 hifb&lt;br /&gt;
hi3518e_vpss          261330  0&lt;br /&gt;
hi3518e_viu           246389  1 hi3518e_vpss&lt;br /&gt;
hi3518e_isp           105606  4 piris,sensor_i2c,hi3518e_vpss,hi3518e_viu&lt;br /&gt;
hi3518e_vgs           127198  0&lt;br /&gt;
hi3518e_region         66722  0&lt;br /&gt;
hi3518e_tde           121855  2 hifb,hi3518e_region&lt;br /&gt;
hi3518e_sys            62048  2 hi3518e_vpss,hi3518e_viu&lt;br /&gt;
hi3518e_base           58109 21 hi3518e_adec,hi3518e_aenc,hi3518e_ao,hi3518e_ai,hi3518e_aio,acodec,hi3518e_ive,hi3518e_jpege,hi3518e_h264e,hi3518e_chnl,hi3518e_venc,hi3518e_rc,hifb,hi3518e_vou,hi3518e_vpss,hi3518e_viu,hi3518e_isp,hi3518e_vgs,hi3518e_region,hi3518e_tde,hi3518e_sys&lt;br /&gt;
hi_media                5801  6 hi_mipi,acodec,pwm,hifb,hi3518e_tde,hi3518e_base&lt;br /&gt;
mmz                    22400  6 hi3518e_ao,hi3518e_jpege,hi3518e_h264e,hi3518e_tde,hi3518e_sys,hi3518e_base&lt;br /&gt;
rtl8188eu             692341  0&lt;/p&gt;

&lt;p&gt;问题1：&lt;br /&gt;
由于是新sensor，跑海思自带的测试代码肯定会提示“This sensor type is not surpport!”&lt;br /&gt;
解决方案：&lt;br /&gt;
添加新sensor的枚举类型 到typedef enum sample_vi_mode_e {}SAMPLE_VI_MODE_E；&lt;br /&gt;
并根据自己sensor的参数正确命名。&lt;/p&gt;

&lt;p&gt;问题2：&lt;br /&gt;
最棘手的问题，get venc stream time out, exit thread&lt;br /&gt;
既然是新添加sensor，那么能出现这个超时问题一定就是视频摄入有问题了，最主要的结构在sample_common_vi.c 的combo_dev_attr_t结构体。&lt;br /&gt;
你要对照sensor厂商给的ini配置，参照其他厂商的形式为你的sensor写一个此结构体的初始化代码。当然我们的是CMOS3V3的，直接使用如下初始化结构：&lt;br /&gt;
combo_dev_attr_t MIPI_CMOS3V3_ATTR =&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* input mode */
.input_mode = INPUT_MODE_CMOS_33V,
{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;执行sample_venc之后，选择一个选项，h264的流就出现在执行目录下了，直接用vlc打开。&lt;br /&gt;
如果想要转为网络的rtsp流，那需要改sample代码将这些流重新打包，并使用rtsp流发布出来。&lt;/p&gt;

&lt;h3 id=&#34;最后贴一张成像图-但是泛紫-现在正准备在isp调试下-帖子继续更新&#34;&gt;最后贴一张成像图，但是泛紫，现在正准备在ISP调试下，帖子继续更新。&lt;/h3&gt;

&lt;p&gt;应该是mask地址设错了&lt;/p&gt;

&lt;p&gt;mask地址吗？地址是写在ini的，sample没有导入ini，把ini转化为结构体combo_dev_attr_t的初始化了。还是不清楚问题咋改&lt;/p&gt;

&lt;p&gt;掩码查一下，原理都一样的。&lt;/p&gt;

&lt;p&gt;谢谢楼上两位，结贴了，掩码在sample_comm_vi.c中你添加的sensor的VI_DEV_ATTR_S 结构体中，我的结构体是：&lt;/p&gt;

&lt;p&gt;掩码低十位 0x 3ff 0000&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;VI_DEV_ATTR_S DEV_ATTR_SC2235_DC_720P_BASE =
{
    /* interface mode */
    VI_MODE_DIGITAL_CAMERA,
    /* multiplex mode */
    VI_WORK_MODE_1Multiplex,
    /* r_mask    g_mask    b_mask*/
    //{0xFFF0000,    0x0},
    //{0xFF00000,    0x0},
    {0x3FF0000,    0x0},
    /* progessive or interleaving */
    VI_SCAN_PROGRESSIVE,
    /*AdChnId*/
    {-1, -1, -1, -1},
    /*enDataSeq, only support yuv*/
    VI_INPUT_DATA_YUYV,

     /* synchronization information */
    {
    /*port_vsync   port_vsync_neg     port_hsync        port_hsync_neg        */
    VI_VSYNC_PULSE, VI_VSYNC_NEG_HIGH, VI_HSYNC_PULSE,VI_HSYNC_NEG_HIGH,VI_VSYNC_NORM_PULSE,VI_VSYNC_VALID_NEG_HIGH,   
   
    /*hsync_hfb    hsync_act    hsync_hhb*/
    {0,            1280,        0,
    /*vsync0_vhb vsync0_act vsync0_hhb*/
     0,            720,        0,
    /*vsync1_vhb vsync1_act vsync1_hhb*/
     0,            0,            0}
    },
    /* use interior ISP */
    VI_PATH_ISP,
    /* input data type */
    VI_DATA_TYPE_RGB,
    /* bRevert */
    HI_FALSE,
    /* stDevRect */
    {200, 20, 1280, 720}
};

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mmz</title>
            <link>/hardware/hisilicon/hi3516-mmz/</link>
            <pubDate>Thu, 28 Nov 2019 11:38:59 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mmz/</guid>
            <description>&lt;p&gt;Hi3518EV200学习记录之运行mpp/sample/sample_venc（ov9712）&lt;br /&gt;
Linux环境：Ubuntu10.04&lt;/p&gt;

&lt;p&gt;SDK版本：（Hi3518E_SDK_V1.0.3.0.tgz）Hi3518EV200R001C01SPC030&lt;/p&gt;

&lt;p&gt;一、Hi3518E_SDK_V1.0.3.0.tgz解压后默认sensor为ar0230，为了适配ov9712，需要做如下修改：&lt;/p&gt;

&lt;p&gt;1、mpp/ko/load3518e中：&lt;/p&gt;

&lt;p&gt;原来配置如下：&lt;/p&gt;

&lt;p&gt;SNS_TYPE=ar0230             # sensor type&lt;/p&gt;

&lt;p&gt;mem_total=64;               # 64M, total mem&lt;br /&gt;
mem_start=0x80000000;       # phy mem start&lt;/p&gt;

&lt;p&gt;os_mem_size=32;             # 32M, os mem&lt;br /&gt;
mmz_start=0x82000000;       # mmz start addr&lt;br /&gt;
mmz_size=32M;               # 32M, mmz size&lt;/p&gt;

&lt;p&gt;修改后配置如下：&lt;/p&gt;

&lt;p&gt;SNS_TYPE=ov9712             # sensor type&lt;/p&gt;

&lt;p&gt;mem_total=64;               # 64M, total mem&lt;br /&gt;
mem_start=0x80000000;       # phy mem start&lt;/p&gt;

&lt;p&gt;os_mem_size=32;             # 32M, os mem&lt;br /&gt;
mmz_start=0x82000000;       # mmz start addr&lt;br /&gt;
mmz_size=32M;               # 32M, mmz size&lt;/p&gt;

&lt;p&gt;2、mpp/sample/Makefile.param中&lt;/p&gt;

&lt;p&gt;原来配置如下：&lt;/p&gt;

&lt;p&gt;CHIP_ID ?= CHIP_HI3516C_V200&lt;br /&gt;
#CHIP_ID ?= CHIP_HI3518E_V200&lt;br /&gt;
#CHIP_ID ?= CHIP_HI3518E_V201&lt;/p&gt;

&lt;p&gt;################# select sensor type for your sample ####################&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_9M034_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;SENSOR_TYPE ?= SONY_IMX222_DC_1080P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= SONY_IMX222_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0130_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= PANASONIC_MN34222_MIPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0230_HISPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV9712_DC_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9732_DC_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9750_MIPI_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9752_MIPI_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV2718_MIPI_1080P_25FPS&lt;/p&gt;

&lt;p&gt;修改后配置如下：&lt;/p&gt;

&lt;p&gt;#CHIP_ID ?= CHIP_HI3516C_V200&lt;br /&gt;
CHIP_ID ?= CHIP_HI3518E_V200&lt;br /&gt;
#CHIP_ID ?= CHIP_HI3518E_V201&lt;/p&gt;

&lt;p&gt;################# select sensor type for your sample ####################&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_9M034_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= SONY_IMX222_DC_1080P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= SONY_IMX222_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0130_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= PANASONIC_MN34222_MIPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= APTINA_AR0230_HISPI_1080P_30FPS&lt;/p&gt;

&lt;p&gt;SENSOR_TYPE ?= OMNIVISION_OV9712_DC_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV9732_DC_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9750_MIPI_720P_30FPS&lt;br /&gt;
#SENSOR_TYPE ?= OMNIVISION_OV9752_MIPI_720P_30FPS&lt;/p&gt;

&lt;p&gt;#SENSOR_TYPE ?= OMNIVISION_OV2718_MIPI_1080P_25FPS&lt;/p&gt;

&lt;p&gt;二、运行load3518e加载mpp所需的ko&lt;/p&gt;

&lt;p&gt;mount -t nfs 192.168.1.6:/nfsroot/ /nfsroot -o nolock&lt;/p&gt;

&lt;p&gt;cd /nfsroot/hi3518e/mpp/ko&lt;br /&gt;
&lt;code&gt;./load3518e -a -sensor ov9712 -osmem 32 -total 64&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;加载mmz.ko出错、OS和MMZ内存重叠了。错误原因：&lt;/p&gt;

&lt;p&gt;设置boot启动参数时如下&lt;/p&gt;

&lt;p&gt;setenv bootargs &#39;mem=64M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 mtdparts=hi_sfc:1M(boot),3M(kernel),12M(rootfs)&#39;&lt;br /&gt;
setenv bootcmd &#39;sf probe 0;sf read 0x82000000 0x100000 0x300000;bootm 0x82000000&#39;&lt;br /&gt;
sa&lt;/p&gt;

&lt;p&gt;其中 mem=64M，为OS内存，DDR总内存64M，而1中分配OS内存32M，MMZ内存32M。&lt;/p&gt;

&lt;p&gt;修改uboot启动参数如下：&lt;/p&gt;

&lt;p&gt;setenv bootargs &#39;mem=32M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 mtdparts=hi_sfc:1M(boot),3M(kernel),12M(rootfs)&#39;&lt;br /&gt;
setenv bootcmd &#39;sf probe 0;sf read 0x82000000 0x100000 0x300000;bootm 0x82000000&#39;&lt;br /&gt;
sa&lt;/p&gt;

&lt;p&gt;重启后再次运行，可以成功加载load3518e。&lt;/p&gt;

&lt;p&gt;三、编译mpp/sample/venc/sample_venc并运行&lt;/p&gt;

&lt;p&gt;Linux主机端：make&lt;/p&gt;

&lt;p&gt;板卡端：&lt;/p&gt;

&lt;p&gt;cd ../sample/venc&lt;/p&gt;

&lt;p&gt;./sample_venc 0&lt;/p&gt;

&lt;p&gt;起初会报错 system init failed，调用SAMPLE_COMM_SYS_Init进行SAMPLE_COMM_SYS_Init出错，追溯下去是HI_MPI_VB_Init出错，返回值是0xA002800C，分配内存失败，原因是没有进行一中2的修改，默认CHIP_HI3516C_V200的g_u32BlkCnt是10，所以VB分配出错。&lt;/p&gt;

&lt;p&gt;可以成功获取h264码流文件，使用播放器播放可以出画面，只是白色区域偏粉，原因VI掩码设置与硬件不匹配，硬件使用的是D0~D9，修改如下：&lt;/p&gt;

&lt;p&gt;VI_DEV_ATTR_S DEV_ATTR_OV9732_DC_720P_BASE ={&lt;br /&gt;
...&lt;br /&gt;
{0x03FF0000,    0x0},//{0xFFC0000,    0x0},//D2~D11&lt;br /&gt;
...&lt;br /&gt;
};&lt;/p&gt;

&lt;p&gt;到此，可以成功的运行ov9712的sample_venc demo。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 intro</title>
            <link>/hardware/hisilicon/hi3516-intro/</link>
            <pubDate>Wed, 27 Nov 2019 14:50:07 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-intro/</guid>
            <description>&lt;p&gt;1.本人拿到的 HI3516CV500DMEB VER.A 单板，只有 uboot 2016.11.&lt;br /&gt;
2.该板子所拥有的硬件资源如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-&amp;gt;1.SPI nor flash ,16MB, 64KB（blocksize） ,nor flash型号为：n25q128a13
  hisi-sfc hisi_spi_nor.0: n25q128a13 (Chipsize 16 Mbytes, Blocksize 64KiB)

-&amp;gt;2.DDE 好像也是16M.
 hisilicon # `bdinfo`
  arch_number = 0x00001F40
  boot_params = 0x82000100
  DRAM bank   = 0x00000000
  -&amp;gt; start    = 0x80000000
  -&amp;gt; size    = 0x10000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt;3.没有nand,emmc 等其他存储设备。&lt;/p&gt;

&lt;p&gt;3.该板子其他的软件打印信息：&lt;/p&gt;

&lt;p&gt;-&amp;gt;1.hisilicon # base&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Base Address: 0x00000000
  hisilicon # bdinfo
  arch_number = 0x00001F40
  boot_params = 0x82000100
  DRAM bank   = 0x00000000
  -&amp;gt; start    = 0x80000000
  -&amp;gt; size    = 0x10000000
  eth0name   = eth0
  ethaddr    = aa:aa:aa:aa:aa:aa
  current eth = eth0
  ip_addr    = 192.168.1.10
  baudrate   = 115200 bps
  TLB addr    = 0x8FFF0000
  relocaddr   = 0x8FF30000
  reloc off   = 0x0D730000
  irq_sp     = 0x8FE8FEE0
  sp start    = 0x8FE8FED0
  Early malloc usage: 70 / 2000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt;2.hisilicon # getinfo bootmode&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  spi

  hisilicon # getinfo nand
  no find nand                             //表明没有nand .

  hisilicon # getinfo spi                  //spi nor flash 16M
  Block:64KB Chip:16MB*1
  ID:0x20 0xBA 0x18
  Name:&amp;quot;N25QL128A&amp;quot;

  hisilicon # getinfo version
  version: U-Boot 2016.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt;3.hisilicon # version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  U-Boot 2016.11 (Aug 31 2018 - 17:14:28 +0800)hi3516cv500
  arm-himix200-linux-gcc (HC&amp;amp;C V100R002C00B020_20180814) 6.3.0
  GNU ld (GNU Binutils) 2.29
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt;4.hisilicon # print&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  arch=arm
  baudrate=115200
  board=hi3516cv500
  board_name=hi3516cv500
  bootargs=mem=128M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 rw mtdparts=hi_sfc:1M(boot),4M(kernel),11M(rootfs)
  bootcmd=sf probe 0;sf read 0x82000000 0x100000 0x400000;bootm 0x82000000
  bootdelay=2
  cpu=armv7
  ethact=eth0
  ethaddr=aa:aa:aa:aa:aa:aa
  gatewayip=192.168.1.1
  ipaddr=192.168.1.10
  netmask=255.255.255.0
  serverip=192.168.1.141
  soc=hi3516cv500
  stderr=serial
  stdin=serial
  stdout=serial
  vendor=hisilicon
  verify=n

  Environment size: 539/262140 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.uboot的启动打印信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System startup

U-Boot 2016.11 (Aug 31 2018 - 17:14:28 +0800)hi3516cv500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DRAM:  256 MiB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Relocation Offset is: 0d730000
Relocating to 8ff30000, new gd at 8fe8fef0, sp at 8fe8fed0
SPI Nor:  Check Flash Memory Controller v100 ... Found
SPI Nor ID Table Version 1.0
SPI Nor(cs 0) ID: 0x20 0xba 0x18
Block:64KB Chip:16MB Name:&amp;quot;N25QL128A&amp;quot;
SPI Nor total size: 16MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NAND:  0 MiB&lt;br /&gt;
   In:   serial&lt;br /&gt;
   Out:  serial&lt;br /&gt;
   Err:  serial&lt;br /&gt;
   Net:  eth0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hit any key to stop autoboot:  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.hi3516烧写内核和跟文件系统的命令如下：&lt;br /&gt;
   (可参考：Hi3516CV500╱Hi3516DV300 SDK 安装及升级使用说明.pdf)&lt;br /&gt;
   (但要注意：参考文件是以nand为存储器来举例的，但我们的板子是spi nor flash.所以烧写命令可能不同)&lt;br /&gt;
   -&amp;gt;烧写内核：(/Hi3516CV500_SDK_V2.0.0.1/osdrv/pub/hi3516cv500_spi_smp_image_glibc/uImage_hi3516cv500_smp)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.mw.b 82000000 ff 400000
  2.tftp 82000000 uImage_hi3516cv500_smp
  3.sf probe
  4.sf erase 100000 400000
  5.sf write 82000000 100000 400000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt;烧写跟文件系统：(/Hi3516CV500_SDK_V2.0.0.1/osdrv/pub/rootfs_glibc.tgz)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.mw.b 82000000 ff 800000 （注意：最后的这个数字范围可以是500000~800000，原因：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟文件系统为4.1M,所以最小500000，800000是因为实际测试，最大就是这个值）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2.tftp 82000000 rootfs_hi3516cv500_64k.jffs2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意：选jffs2,是因为bootargs已经规定了；选择64K,这是因为spi nor flash的block块大小是64KB）.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  3.sf probe
  4.sf erase 500000 B00000  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(注意：最后一个数字，是可以变得，我估计只要大于4.1M就行。但这个B00000我实际是可用的，其他没试过。)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  5.sf write 82000000 500000 B00000 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意：最后一个数字，是可以变得，我估计只要大于4.1M就行。但这个B00000我实际是可用的，其他没试过。）&lt;br /&gt;
   （以上命令中我们使用的是 sf 命令。但参考中使用的是nand 命令。那是因为存储器不同造成的。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nfs 挂载 rootfs_glibc：
先解压 /Hi3516CV500_SDK_V2.0.0.1/osdrv/pub/rootfs_glibc.tgz
然后用 nfs 挂载 rootfs_glibc 目录
把 /Hi3516CV500_SDK_V2.0.0.1/smp/a7_linux/mpp 目录中的 ko 和 lib 拷到
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/home/nsc/workspace/rootfs_glibc/ko&lt;br /&gt;
   /home/nsc/workspace/rootfs_glibc/usr/lib&lt;/p&gt;

&lt;p&gt;一定要把这个文件的执行权限改了，否则会出现驱动加载失败，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;导致用例程序调用 HI_MPI_SYS_Exit API时 open err 错误！
$cd /home/nsc/workspace/rootfs_glibc/ko
$ sudo chmod 777 load3516cv500

$ sudo gedit /home/nsc/workspace/rootfs_glibc/etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在最后加入如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /ko
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;./load3516cv500 -i -sensor0 imx327&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.板子烧写地址空间说明：&lt;br /&gt;
   |   1M   |   4M     |   11M    |  （spi nor flash 总共16M）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;|  boot  |  kernel  |  rootfs   |&lt;/p&gt;

&lt;p&gt;7.因为spi nor flash 只有16M,不够mpp的相关文件存放，所以在开发阶段，&lt;br /&gt;
使用nfs 远程挂在根文件系统。等到开发完毕，我只使用nfs方式挂在mpp相关文件。&lt;/p&gt;

&lt;p&gt;8.nfs 远程挂在文件夹形式的根文件系统：&lt;br /&gt;
   原bootargs为：（这是告诉内核如何从硬件设备中启动rootfs；或者怎么启动rootfs）&lt;br /&gt;
   bootargs=mem=128M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 rw mtdparts=hi_sfc:1M(boot),4M(kernel),11M(rootfs)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原bootcmd为： （这是告诉uboot 怎么启动内核，从哪里/设备 中读取内核源码，进行启动）
bootcmd=sf probe 0;sf read 0x82000000 0x100000 0x400000;bootm 0x82000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们只远程挂在根文件系统，所以，我们只需要修改bootargs 就可以。&lt;br /&gt;
   修改后的bootargs为：(一下是设置命令)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setenv bootargs root=/dev/nfs rw nfsroot=192.168.1.141:/work/rootfs_hi/rootfs_glibc ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttyAMA0,115200 mem=64M

注意：
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;bootargs 一定要加上mem=64M。否则内核起不起来。（我猜想海思因为内存要做两用，所以他在内核启动前会校验是否设置的系统的内存分配。否则不启动）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为内核启动需要知道内存是怎么被分配的，就是 系统运行需要多少，mpp视频处理需要多少。这里mem=64M，指的是系统运行需要多少。设置一个就行。因为这里是rootfs启动需要的，所以不需要设置mpp需要的内存。&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么这里是64M,这是因为，这里要和mpp/ko/load3516cv500 文件中的os_mem_size的值一样，或者说只要这两个值一样就行，但因为load3516cv500中设置成了64M,我们懒的该，所以也使用64M.&lt;br /&gt;
(而且这是海思分配的，人家考虑的是比较全面的。所以我们按照人家的来就行。)&lt;br /&gt;
#DDR start:0x80000000, kernel start:0x80000000, OS(64M); MMZ start:0x84000000&lt;br /&gt;
mem_total=256                # 256M, total mem&lt;br /&gt;
mem_start=0x80000000         # phy mem start&lt;br /&gt;
os_mem_size=64               # 64M, os mem&lt;br /&gt;
mmz_start=0x84000000;        # mmz start addr&lt;br /&gt;
mmz_size=192M;               # 192M, mmz size&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-&amp;gt;将mpp/ko 目录拷贝到 rootfs 的根目录下（也就是/ko）.&lt;br /&gt;
-&amp;gt;将mpp/lib/* 目录下的.so动态库文件拷贝到 rootfsd的/usr/lib/目录下，这样系统会首先自动在这个文件里搜素到他需要的动态库。（当然我们也可以将lib存放的目录设置为系统自动搜素目录）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A. 在rootfs 中的 /etc/profile(这是系统执行登录的操作文件) 的文件末尾加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-&amp;gt;1.vi /etc/profile  添加内容如下：
     cd /ko  (我们将ko目录放到根目录下)
     ./load3516cv500 -i -sensor0 imx327
     cd -
-&amp;gt;2.修改 /ko/load3516cv500文件的文件权限，增加可执行权限：
     chmod 777 load3516cv500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B. reboot 或者重新上电重启，就ok.&lt;/p&gt;

&lt;p&gt;C.制作新的jffs2文件系统：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo osdrv/pub/bin/pc/mkfs.jffs2  -d osdrv/pub/rootfs_glibc -l -e 0x10000 -o osdrv/pub/rootfs_glibc_64k.jffs2
疑问： -l 什么意思？？ -e 0x10000 什么意思？？   
-l, --little-endian     指定使用小端格式
-e, --eraseblock=SIZE   设定擦除块的大小为(默认: 64KiB = 0x10000) 这里的值需要和Flash器件保持一致，在uboot启动时log信息里面有
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D.直接在sample 的某个目录下 make,比如 ：venc ，直接在它下面make ,就可以得到 一个可以执行程序，拿到 板子中直接运行就行。&lt;/p&gt;

&lt;p&gt;E.vi /etc/profile 末尾添加：&lt;br /&gt;
sleep 1&lt;br /&gt;
mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.1.141:/work/rootfs_hi  /mnt&lt;/p&gt;

&lt;p&gt;cd /root&lt;br /&gt;
./loadmpp.sh&lt;br /&gt;
cd -&lt;/p&gt;

&lt;p&gt;vi loadmpp.sh&lt;br /&gt;
#!/bin/sh&lt;br /&gt;
cd /mnt/mpp/ko&lt;br /&gt;
./load3516cv500 -i -sensor0 imx327 (这个可能有变，尝试之后，不行在换另一个。)&lt;br /&gt;
cd -&lt;/p&gt;

&lt;p&gt;F.因为spi nor flash 供 16M,而且没有其他的存储设备，所以接下来的MPP 和 lib部署，我选择 nfs 远程挂载的方式。&lt;/p&gt;

&lt;p&gt;mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.1.141:/work/rootfs_hi  /mnt&lt;/p&gt;

&lt;p&gt;这是hi3519的。&lt;br /&gt;
cd /root&lt;br /&gt;
./nfsroot&lt;br /&gt;
echo &amp;quot;------nfsroot is over------&amp;quot;&lt;br /&gt;
cd /root/ko&lt;/p&gt;

&lt;p&gt;./load3519v101 -a -sensor0 imx274 -osmem 64&lt;br /&gt;
echo &amp;quot;------ko is over---------&amp;quot;&lt;br /&gt;
cd /root&lt;/p&gt;

&lt;p&gt;telnetd&amp;amp;&lt;br /&gt;
~onfig eth0 192.168.1.40&lt;br /&gt;
#mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.1.59:/export/nfsroot /mnt&lt;br /&gt;
mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.1.141:/work/rootfs /mnt&lt;/p&gt;

&lt;p&gt;telnetd&amp;amp;&lt;br /&gt;
~&lt;/p&gt;

&lt;p&gt;setenv bootargs root=/dev/nfs rw nfsroot=192.168.1.141:/work/rootfs_hi/rootfs_glibc ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off init=/linuxrc console=ttyAMA0,115200 mem=128M&lt;/p&gt;

&lt;p&gt;bootargs=mem=128M console=ttyAMA0,115200 root=/dev/mtdblock2 rootfstype=jffs2 rw mtdparts=hi_sfc:1M(boot),4M(kernel),11M(rootfs)&lt;br /&gt;
bootcmd=sf probe 0;sf read 0x82000000 0x100000 0x400000;bootm 0x82000000&lt;/p&gt;

&lt;p&gt;osdrv/pub/bin/pc/mkfs.jffs2 -d 根文件系统路径  -l -e 0x10000 -o xxx/xx/rootfs_uclibc_64k.jffs2&lt;/p&gt;

&lt;p&gt;F.在 Ubuntu 下用 tar -zxf 解压：&lt;br /&gt;
 Hi3516CV500R001C02SPC001/01.software/board/Hi3516CV500_SDK_V2.0.0.1.tgz&lt;br /&gt;
  arm-himix200-linux.tgz&lt;/p&gt;

&lt;p&gt;进入 Hi3516CV500_SDK_V2.0.0.1 目录&lt;br /&gt;
  切换成 root 用户，执行解包脚本&lt;br /&gt;
  $sudo su&lt;br /&gt;
  #source sdk.unpack&lt;/p&gt;

&lt;p&gt;进入 osdrv 目录，按 readme_cn.txt 来&lt;br /&gt;
  1)下载 linux-4.9.37.tar.gz 并拷贝到 osdrv/opensource/kernel 目录中&lt;br /&gt;
  2)修改 Makefile 文件并执行 make all&lt;br /&gt;
   CHIP?=hi3516cv500&lt;/p&gt;

&lt;p&gt;进入 arm-himix200-linux 目录&lt;br /&gt;
  $chmod +x arm-himix200-linux.install&lt;br /&gt;
  #sudo ./arm-himix200-linux.install&lt;/p&gt;

&lt;p&gt;注：&lt;br /&gt;
  1)出错：/bin/sh: 1: pushd: not found&lt;br /&gt;
  $ sudo dpkg-reconfigure dash&lt;br /&gt;
  选择No&lt;/p&gt;

&lt;p&gt;2)出错：zlib.h 没有此文件或目录&lt;br /&gt;
  $ sudo apt install zlib1g-dev&lt;/p&gt;

&lt;p&gt;3)出错：&amp;quot;mkimage&amp;quot; command not found - U-Boot images will not be built&lt;br /&gt;
  在 /etc/bash.bashrc 中添加&lt;br /&gt;
  &lt;code&gt;export PATH=/home/nsc/workspace/Hi3516CV500_SDK_V2.0.0.1/osdrv/opensource/uboot/u-boot-2016.11/tools:$PATH&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>python telnet</title>
            <link>/language/python/python-telnet/</link>
            <pubDate>Wed, 27 Nov 2019 11:28:08 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/python/python-telnet/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import logging
import telnetlib
import time


class TelnetClient():
    def __init__(self,):
        self.tn = telnetlib.Telnet()

    # 此函数实现telnet登录主机
    def login(self,host_ip,username,password):
        try:
            # self.tn = telnetlib.Telnet(host_ip,port=23)
            self.tn.open(host_ip,port=23)
        except:
            logging.warning(&#39;%s网络连接失败&#39;%host_ip)
            return False

        # 等待login出现后输入用户名，最多等待10秒
        self.tn.read_until(b&#39;login: &#39;,timeout=5)
        self.tn.write(username.encode(&#39;ascii&#39;) + b&#39;\n&#39;)
        # 等待Password出现后输入用户名，最多等待10秒
        self.tn.read_until(b&#39;Password: &#39;,timeout=10)
        self.tn.write(password.encode(&#39;ascii&#39;) + b&#39;\n&#39;)
        # 延时两秒再收取返回结果，给服务端足够响应时间
        time.sleep(.001)
        # 获取登录结果
        # read_very_eager()获取到的是的是上次获取之后本次获取之前的所有输出
        command_result = self.tn.read_very_eager().decode(&#39;ascii&#39;)
        if &#39;Login incorrect&#39; not in command_result:
            logging.warning(&#39;%s登录成功&#39;%host_ip)
            return True
        else:
            logging.warning(&#39;%s登录失败，用户名或密码错误&#39;%host_ip)
            return False

    # 此函数实现执行传过来的命令，并输出其执行结果
    def exec(self,command):
        # 执行命令
        self.tn.write(command.encode(&#39;ascii&#39;)+b&#39;\n&#39;)
        time.sleep(.1)
        # 获取命令结果
        command_result = self.tn.read_very_eager().decode(&#39;ascii&#39;)
        logging.warning(&#39;命令执行结果：\n%s&#39; % command_result)

    # 退出telnet
    def logout(self):
        self.tn.write(b&amp;quot;exit\n&amp;quot;)

if __name__ == &#39;__main__&#39;:
    host_ip = &#39;192.168.100.10&#39;
    username = &#39;root&#39;
    password = &#39;&#39;
    command = &#39;whoami&#39;
    client = TelnetClient()
    # 如果登录结果返加True，则执行命令，然后退出
    if client.login(host_ip,username,password):
        client.exec(command)
        client.exec(&amp;quot;echo \&amp;quot;a1b2c3d4\&amp;quot;&amp;gt;/etc/machine-id&amp;quot;)
        client.exec(&amp;quot;cat /etc/machine-id&amp;quot;)
        client.logout()
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>快速计算平方根倒数</title>
            <link>/ai/math/fast_inverse_sqrt/</link>
            <pubDate>Wed, 27 Nov 2019 10:00:14 CST</pubDate>
            <author>rinetd</author>
            <guid>/ai/math/fast_inverse_sqrt/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/w450468524/article/details/52529901&#34; target=&#34;_blank&#34;&gt;【学习笔记】快速平方根倒数算法 - w450468524的专栏 - CSDN博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;很以前久，看《DOOM 启示录》的时候就看到，当年卡马克大神在《雷神之锤》中使用了一个神奇的数字，能够通过位操作快速计算平方根倒数 y=1x√y=1xy=\frac{1}{\sqrt{x}}。但是当时并没有深究，这两天偶然看到了&lt;a href=&#34;http://blog.jobbole.com/105295/&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;，终于将我这个多年的 “未解之谜” 解开了，特此做下笔记，图片取自原文。&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;首先是这个神奇算法的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float fast_inverse_sqrt(float x)
{
    float half_x = 0.5 * x;
    int i = *((int *)&amp;amp;x); // 以整数方式读取X
    i = 0x5f3759df - (i&amp;gt;&amp;gt;1); // 神奇的步骤
    x = *((float *)&amp;amp;i); // 再以浮点方式读取i
    x = x*(1.5 - (half_x * x * x)); // 牛顿迭代一遍提高精度
    return x;
} 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中最最重要的就是第二步，通过这个神奇的步骤，能够得到 x 平方根倒数的近似值。前后穿插着用整型读取浮点数等等，实在是不知所云。但实际上，其中包含着很有意思的数学背景（每次一提到数学，我就觉得好方）。&lt;/p&gt;

&lt;h3 id=&#34;背后的数学&#34;&gt;背后的数学&lt;/h3&gt;

&lt;p&gt;首先来重新温习一下机组里面的浮点数基础知识（机组 60 分默默飘过）。&lt;/p&gt;

&lt;h4 id=&#34;单精度浮点数&#34;&gt;单精度浮点数&lt;/h4&gt;

&lt;p&gt;单精度浮点数有 32bit，包括 1 位符号位 s，8 位指数位 e，23 位尾数位 m（赞一下 CSDN 的 markdown 编辑器的 latex 数学公式的功能~)：&lt;/p&gt;

&lt;p&gt;s e⋯e⏟8 m⋯m⏟23se⋯e⏟8m⋯m⏟23\qquad s \space \underbrace{e\cdots e}&lt;em&gt;8\space \underbrace{m\cdots m}&lt;/em&gt;{23}&lt;/p&gt;

&lt;p&gt;其表示的数值为：(1+m′)2e′(1+m′)2e′(1+m&#39;)2^{e&#39;}，这里的 m’代表尾数部分的数值，m’只包含小数位，即 m′=0.m⋯m⏟23m′=0.m⋯m⏟23m&#39;=0.\underbrace{m\cdots m}_{23 }，e’则是指数部分的数值，只有整数位，e′=e⋯e⏟8−Be′=e⋯e⏟8−Be&#39;=\underbrace{e\cdots e}_8-B。为了表示负的指数，指数部分要减去一个偏移量 B。&lt;br /&gt;
再规定 M 表示以整数方式解释尾数二进制位的值，E 表示相同的方式解释指数部分的值。可以得到以下的转换关系：&lt;/p&gt;

&lt;p&gt;m′=MLL=223m′=MLL=223\qquad m&#39;=\frac{M}{L}\qquad L=2^{23}&lt;br /&gt;
e′=E−BB=127e′=E−BB=127\qquad e&#39;=E-B\qquad B=127&lt;/p&gt;

&lt;p&gt;那么对于一个浮点数的二进制位 s e⋯e⏟8 m⋯m⏟23se⋯e⏟8m⋯m⏟23s \space \underbrace{e\cdots e}&lt;em&gt;8\space \underbrace{m\cdots m}&lt;/em&gt;{23}以整数方式解读的话，其值就为：I=EL+MI=EL+MI=EL+M（因为平方根输入只能为正，所以默认 s 为 0）。&lt;/p&gt;

&lt;h4 id=&#34;平方根倒数近似计算&#34;&gt;平方根倒数近似计算&lt;/h4&gt;

&lt;p&gt;下面开始进入正题：&lt;br /&gt;
对于输入 x，我们要计算的是 y=1x√y=1xy=\frac{1}{\sqrt{x}}，将该式子两边取对数：log2(y)=−12log2(x)log2⁡(y)=−12log2⁡(x)\log_2(y)=-\frac{1}{2}\log_2(x)。然后我们将 x，y 都替换为浮点数表示形式：&lt;/p&gt;

&lt;p&gt;log2((1+m′y)2e′y)=−12log2((1+m′x)2e′x)log2⁡((1+my′)2ey′)=−12log2⁡((1+mx′)2ex′)\qquad \log_2((1+m&#39;_y)2^{e&#39;_y})=-\frac{1}{2}\log_2((1+m&#39;_x)2^{e&#39;_x})&lt;br /&gt;
log2(1+m′y)+e′y=−12(log2(1+m′x)+e′x)log2⁡(1+my′)+ey′=−12(log2⁡(1+mx′)+ex′)\qquad \log_2(1+m&#39;_y)+e&#39;_y=-\frac{1}{2}(\log_2(1+m&#39;_x)+{e&#39;_x})&lt;/p&gt;

&lt;p&gt;观察发现，上式等号两边均有 log2(1+v)log2⁡(1+v)\log_2(1+v)形式的式子，v 的范围是 0 到 1，而该式在这个定义域内的函数图像非常接近一条直线：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7cc829d3gw1f7hdhlvnlcj20go0abjrq.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因此我们近似的用 x+σx+σx+\sigma替换得到：&lt;/p&gt;

&lt;p&gt;m′y+σ+e′y=−12(m′x+σ+e′x)my′+σ+ey′=−12(mx′+σ+ex′)\qquad m&#39;_y+\sigma+e&#39;_y=-\frac{1}{2}(m&#39;_x+\sigma+{e&#39;_x})&lt;/p&gt;

&lt;p&gt;σσ\sigma为预先计算的一个常数。接下来将数值转为整形方式读取二进制位的形式：&lt;/p&gt;

&lt;p&gt;MyL+σ+Ey−B=−12(MxL+σ+Ex−B)MyL+σ+Ey−B=−12(MxL+σ+Ex−B)\qquad \frac{M_y}{L}+\sigma+E_y-B=-\frac{1}{2}(\frac{M_x}{L}+\sigma+E_x-B)&lt;/p&gt;

&lt;p&gt;移项合并后得到：&lt;/p&gt;

&lt;p&gt;32L(σ−B)+My+LEy=−12(Mx+LEx)32L(σ−B)+My+LEy=−12(Mx+LEx)\qquad \frac{3}{2}L(\sigma-B)+M_y+LE_y=-\frac{1}{2}(M_x+LE_x)&lt;/p&gt;

&lt;p&gt;恰好我们又发现，在等式的两边都含有以整数方式解释浮点数的表示 I=M+LEI=M+LEI=M+LE，进一步化简有：&lt;/p&gt;

&lt;p&gt;Iy=−12Ix+κκ=32L(B−σ)Iy=−12Ix+κκ=32L(B−σ)\qquad I_y=-\frac{1}{2}I_x + \kappa\qquad \kappa=\frac{3}{2}L(B-\sigma)&lt;/p&gt;

&lt;p&gt;由此，我们得到了一个比较有用的近似公式，κκ\kappa便是神奇的数字 &lt;strong&gt;&lt;em&gt;0x5f3759df&lt;/em&gt;&lt;/strong&gt; 。该公式表明计算 x 的平方根倒数时，我们只需要用整型方式读取 x，再代入上式计算得到结果的整形解释值，然后再用浮点数方式读取即可！我当时就震惊了。&lt;/p&gt;

&lt;h4 id=&#34;牛顿迭代提高精度&#34;&gt;牛顿迭代提高精度&lt;/h4&gt;

&lt;p&gt;经过上一步，我们有了初步的近似结果，为了进一步提高精度，我们再用牛顿迭代法计算一次。牛顿迭代法描述的是，给定连续函数 f(x)，对于方程 f(x)=0，确定任意初始的 x0x0x_0，我们可以通过下面这个迭代式计算得到其解：&lt;/p&gt;

&lt;p&gt;xn+1=xn−f(xn)f′(xn)xn+1=xn−f(xn)f′(xn)\qquad x_{n+1}=x_n-\frac{f(x_n)}{f&#39;(x_n)}&lt;/p&gt;

&lt;p&gt;我们要计算的式子为 y=1x0√，x0y=1x0，x0y=\frac{1}{\sqrt{x_0}}，x_0为已知（这个 x0x0x_0是指输入，不是牛顿迭代的初始值），将其转换为关于 y 的方程就是 f(y)=1y2−x0=0f(y)=1y2−x0=0f(y)=\frac{1}{y^2}-x_0=0，根据牛顿迭代可得：&lt;/p&gt;

&lt;p&gt;yn+1=yn−1y2n−x0−2y3nyn+1=yn−1yn2−x0−2yn3\qquad y_{n+1}=y_n-\frac{\frac{1}{y_n^2}-x_0}{\frac{-2}{y&lt;em&gt;n^3}}&lt;br /&gt;
yn+1=32yn−12x0y3nyn+1=32yn−12x0yn3\qquad y&lt;/em&gt;{n+1}=\frac{3}{2}y_n-\frac{1}{2}x_0y_n^3&lt;/p&gt;

&lt;p&gt;也就是最后一步的代码了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/7cc829d3gw1f7he4zmuy7j20go0abaac.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;更多讨论&#34;&gt;更多讨论&lt;/h4&gt;

&lt;p&gt;上述推导过程中可以看出，不同次方根在我们的计算中仅仅是作为一个因子而存在的，因此将该近似算法完全可以推广到其他次方根的情况下。另外，对于 64 位浮点数，我们也可以采用完全相同的推导过程来得到相似的结果。这只是一个近似算法，它与真实计算值之间的偏差与神奇数字的取值有很微妙的关系，&lt;a href=&#34;http://www.cnblogs.com/saaav/p/5807736.html&#34; target=&#34;_blank&#34;&gt;这篇博客&lt;/a&gt;对这个问题进行了一些讨论。&lt;/p&gt;

&lt;p&gt;真是神奇的算法！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 tool mkjffs2</title>
            <link>/hardware/hisilicon/hi3516-tool-mkjffs2/</link>
            <pubDate>Tue, 26 Nov 2019 19:28:48 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-tool-mkjffs2/</guid>
            <description>

&lt;p&gt;apt-get install mtd-utils&lt;br /&gt;
命令使用实例：&lt;br /&gt;
&lt;code&gt;mkfs.jffs2  -s 0x1000 -e 0x40000 -p 0x500000 -d  rootfs/ -o  jffs2.img&lt;/code&gt;&lt;br /&gt;
说明：&lt;br /&gt;
-s 0x1000 页大小0x1000   4k&lt;br /&gt;
-e 0x40000 块大小0x40000  256k&lt;br /&gt;
-p 0x500000 jffs2分区总空间0x500000即5M&lt;br /&gt;
当然生成的jffs2.img并没有一下子分配5M,还是实际大小0xc0000&lt;/p&gt;

&lt;p&gt;//制作烧录文件系统&lt;br /&gt;
&lt;code&gt;osdrv/pub/bin/pc/mkfs.jffs2 -d osdrv/pub/rootfs_uclibc_3516dv300 -l -e 0x10000 -o osdrv/pub/rootfs_hi3516dv300_64k.jffs2&lt;/code&gt;&lt;br /&gt;
-l, --little-endian     指定使用小端格式&lt;br /&gt;
-e, --eraseblock=SIZE   设定擦除块的大小为(默认: 64KiB = 0x10000)&lt;/p&gt;

&lt;p&gt;mkfs.jffs2使用方法&lt;br /&gt;
选项含义(man a mkfs.jffs2)&lt;/p&gt;

&lt;p&gt;mkfs.jffs2: Usage: mkfs.jffs2 [OPTIONS]&lt;br /&gt;
Make a JFFS2 file system image from an existing directory tree&lt;br /&gt;
Options:&lt;br /&gt;
-p, --pad[=SIZE]       用16進制來表示所要輸出檔案的大小，也就是root.jffs2的size。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                   很重要的是, 為了不浪費flash空間, 這個值最好符合flash driver所規劃的區塊大小。
                                   如果不足则使用0xff来填充补满。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-r, -d, --root=DIR      指定要做成image的源資料夾.(默认：当前文件夹)&lt;br /&gt;
-s, --pagesize=SIZE     节点页大小(默认: 4KiB)&lt;br /&gt;
-e, --eraseblock=SIZE   设定擦除块的大小为(默认: 64KiB)&lt;br /&gt;
-c, --cleanmarker=SIZE Size of cleanmarker (default 12)&lt;br /&gt;
-m, --compr-mode=MODE   Select compression mode (default: priortiry)&lt;br /&gt;
-x, --disable-compressor=COMPRESSOR_NAME&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      Disable a compressor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-X, --enable-compressor=COMPRESSOR_NAME&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      Enable a compressor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-y, --compressor-priority=PRIORITY:COMPRESSOR_NAME&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      Set the priority of a compressor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-L, --list-compressors Show the list of the avaiable compressors&lt;br /&gt;
-t, --test-compression Call decompress and compare with the original (for test)&lt;br /&gt;
-n, --no-cleanmarkers   指明不添加清楚标记（nand flash 有自己的校检块，存放相关的信息。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      如果挂载后会出现类似：
                      CLEANMARKER node found at 0x0042c000 has totlen 0xc != normal 0x0
                      的警告，则加上-n 就会消失。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-o, --output=FILE       指定輸出image檔案的文件名.(default: stdout)&lt;br /&gt;
-l, --little-endian     指定使用小端格式&lt;br /&gt;
-b, --big-endian        指定使用大端格式&lt;br /&gt;
-D, --devtable=FILE     Use the named FILE as a device table file&lt;br /&gt;
-f, --faketime          Change all file times to &#39;0&#39; for regression testing&lt;br /&gt;
-q, --squash            Squash permissions and owners making all files be owned by root&lt;br /&gt;
-U, --squash-uids       将所有文件的拥有者设为root用户&lt;br /&gt;
-P, --squash-perms      Squash permissions on all files&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  --with-xattr        stuff all xattr entries into image
  --with-selinux      stuff only SELinux Labels into jffs2 image
  --with-posix-acl    stuff only POSIX ACL entries into jffs2 image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-h, --help              显示这些文字&lt;br /&gt;
-v, --verbose           Verbose operation&lt;br /&gt;
-V, --version           显示版本&lt;br /&gt;
-i, --incremental=FILE Parse FILE and generate appendage output for it&lt;/p&gt;

&lt;p&gt;生成的rootfs.img可通过u-boot直接烧写至nand flash：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          nand erase 0x200000 0x3e00000//擦写
          tftp 0x30000000 rootfs.img//下载
          nand write.jffs2 0x200000 $(filesize)//烧入
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;二-在linux的pc上挂载jffs2根文件系统映像&#34;&gt;（二） 在linux的PC上挂载jffs2根文件系统映像&lt;/h2&gt;

&lt;p&gt;因为jffs2是构建于MTD设备上的文件系统，所以无法通过loop设备来挂载，但是可以通过mtdram设备来挂载。mtdram是在用RAM实现的MTD设备，可以通过mtdblock设备来访问。使用mtdram设备很简单，只要加载mtdram和mtdblock两个内核模块即可。这两个内核模块一般的linux内核发行版都有编译好的，直接用modprobe命令加载。&lt;br /&gt;
下面是具体步骤：&lt;/p&gt;

&lt;p&gt;(1).加载mtdblock内核模块&lt;br /&gt;
&lt;code&gt;modprobe mtdblock&lt;/code&gt;&lt;br /&gt;
(2).加载mtdram内核模块，将该设备的大小指定为jffs2根文件系统映像的大小，块擦除大小（即flash的块大小）指定为制作该jffs2根文件系统时“-e”参数指定的大小，缺省为64KB。下面两个参数的单位都是KB。&lt;br /&gt;
&lt;code&gt;modprobe mtdram total_size=5120 erase_size=256&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(3).这时将出现MTD设备/dev/mtdblock0，使用dd命令将jffs2根文件系统拷贝到/dev/mtdblock0设备中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dd if=jffs2.img of=/dev/mtdblock0&lt;/code&gt;&lt;br /&gt;
(4).将保存了jffs2根文件系统的MTD设备挂载到指定的目录上。&lt;br /&gt;
&lt;code&gt;mount -t jffs2 /dev/mtdblock0 /mnt/mtd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这之后就可以到/mnt/mtd目录查看、修改挂载的jffs2根文件系统了，修改后的jffs2根文件系统可以通过dd命令拷贝为一个jffs2的映像文件&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
