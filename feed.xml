<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈 on 时光小栈</title><link>/</link><language>zh-CN</language><author>rinetd</author><rights>Copyright (c) 2015, rinetd; all rights reserved.</rights><updated>Tue, 17 Mar 2020 16:13:32 CST</updated><item><title>stm8 adc</title><link>/hardware/stm8/stm8-adc/</link><pubDate>Tue, 17 Mar 2020 16:13:32 CST</pubDate><author>rinetd</author><guid>/hardware/stm8/stm8-adc/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void InitADC(void)
{
//PD6 set as FloatingInput
PD_DDR &amp;amp;= 0xBF;//1011 1111
PD_CR1 &amp;amp;= 0xBF;
PD_CR2 &amp;amp;= 0xBF;
ADC_CR1 = 0x01;//first time open ADC£¬second time convert ADC data
ADC_CSR = 0X06;//choose channel AIN6
ADC_CR2 = 0X00;//left arrange (default)
}
unsigned int GetADC(void)
{
volatile unsigned int adcValue;
volatile unsigned char tmp = 100;
ADC_CR1 |= 0x01;//first time open ADC
while(tmp--);
ADC_CR1 |= 0x01;//second time convert ADC data
while((ADC_CSR &amp;amp; 0x80) == 0);//waitting for convert finish
ADC_CSR &amp;amp;= 0xEF;//clear the flag of End Of Convert
adcValue = (unsigned int)ADC_DRH;
adcValue = adcValue &amp;lt;&amp;lt; 2;
adcValue |= ADC_DRL;
// 默认左对齐
return(adcValue * 5000UL / 1023UL);//10Î»·Ö±æÂÊÎª1023£¬¼´Vdd/1023*ADC
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;[uptk/STM8S003-](https://github.com/uptk/STM8S003-)
#define nop4() _asm(&amp;quot;nop&amp;quot;);_asm(&amp;quot;nop&amp;quot;);_asm(&amp;quot;nop&amp;quot;);_asm(&amp;quot;nop&amp;quot;);
void ADC_init(void)
{
ADC_CR1 = 0;//fadc = fmaster/2 = 8M,single mode,off
ADC_CR2 = (1&amp;lt;&amp;lt;3)|(0&amp;lt;&amp;lt;1);//right align
ADC_CSR = 0;
// ADC_TDRL = (1&amp;lt;&amp;lt;6)|(1&amp;lt;&amp;lt;3);
}
u16 ADC_get_val(u8 ch)
{
u16 sum,min = 0xffff,max = 0,cnt;
u8 try_cnt;
ADC_CSR = (ADC_CSR &amp;amp; 0x70)|ch;
ADC_CR1 |= 1;
nop4();//32 cycle for establish
nop4();
nop4();
nop4();
nop4();
nop4();
nop4();
nop4();
for(cnt = 0,sum = 0;cnt &amp;lt; 10;cnt++){
u16 tmp;
ADC_CR1 |= 1;
#ifndef DEBUG
while(!(ADC_CSR &amp;amp; 0x80));
#else
try_cnt = 100;
while((!(ADC_CSR &amp;amp; 0x80))&amp;amp;&amp;amp;(try_cnt--));
if(!try_cnt){
//BUG_ON();
if(!(error.flag &amp;amp; ERR_ADC)){
error.flag |= ERR_ADC;
}
}
#endif
ADC_CSR &amp;amp;= 0x7f;
tmp = ADC_DRL;
tmp |= (ADC_DRH&amp;amp;3)&amp;lt;&amp;lt;8;
sum += tmp;
if(min &amp;gt; tmp)
min = tmp;
if(max &amp;lt; tmp)
max = tmp;
}
ADC_CR1 &amp;amp;= ~1;
return (sum - min - max)/8;
}
````
```cpp
\#include &amp;quot;IOSTM8S105K4.h&amp;quot;
\#define u16 unsigned int
\#define u8 unsigned char
void System_Init(void){
CLK_SWR = 0xE1; //选择高速内部时钟HSI为主时钟
CLK_ICKR |= 0x01; //高速内部HSI时钟使能while(!(CLK_ICKR&amp;amp;0x02)); //等待内部高速HSI就绪
CLK_CKDIVR = 0x18; // Fhsi = Fhsi = Fcpu = Fmaster = 2MHz
}
/*延时xms函数@ HSI 2MHz*/
void delay_ms(u16 xms){
u16 i,j;
for(i=xms;i&amp;gt;0;i--)
for(j=330;j&amp;gt;0;j--)
{
asm(&amp;quot;nop&amp;quot;);
}
}
void Gpio_Init(void){
/*PE5设置为推挽输出*/
PE_DDR|=0x20;
PE_CR1|=0x20;
PE_CR2|=0x00; //最大为10MHz
}
/*ADC初始化*/
void Adc_Init(void){
/*PB0 设置为悬浮输入*/
PB_DDR &amp;amp;=0xFE; //PB0输入模式
PB_CR1 &amp;amp;=0xFE; //PB0浮空输入
PB_CR2 &amp;amp;=0xFE; //PB0禁止外部中断
/*开启ADC时钟*/
CLK_PCKENR2 |= 0x08; //开启ADC时钟 ADC时钟默认是开启的，可不设置
/*设置ADC时钟、转换模式、数据对齐格式和通道*/
ADC_CR1 = 0x00; //ADC时钟1MHz，单次转换，关闭ADC 默认如此
ADC_CR2 = 0x00; //数据左对齐，禁止外部触发，禁止扫描模式 默认如此
ADC_CSR = 0x00; //选择通道0 AIN0 默认如此
}
/*获取10位的ADC转换结果*/
u16 Get_Adc_Result(void){
u8 ADC_H,ADC_L;
u16 ADC_temp;
ADC_CR1 |= 0x01; //启动ADC 启动ADC电源
delay_ms(1); //延时1ms 等待ADC启动
ADC_CR1 |= 0x01; //再次启动ADC转换
while((ADC_CSR&amp;amp;0x80) == 0); //等待ADC转换结束
ADC_H = ADC_DRH; //左对齐 先读高八位
ADC_L = ADC_DRL; //读取低位值
ADC_temp = (ADC_H &amp;lt;&amp;lt; 8) +ADC_L; //两个八位数据合并成一个16位数据
return ADC_temp; //返回10位ADC转换结果
}
int main( void ){
u16 temp;
System_Init();
Gpio_Init();
Adc_Init();
while (1)
{
temp = Get_Adc_Result();
if(temp&amp;gt;=800) //如果ADC转换结果大于800
{
PE_ODR = 0x00; //PE5口的LED点亮
}
else PE_ODR = 0xFF; //否则PE5口的LED不点亮
delay_ms(800); //延时800ms
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想学会如何在STM8上使用ADC这个功能，我们先得了解单片机中ADC究竟是什么。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//ADC通道号定义
#define ADC_Chanel0 (unsigned char)0x00
#define ADC_Chanel1 (unsigned char)0x01
#define ADC_Chanel2 (unsigned char)0x02
#define ADC_Chanel3 (unsigned char)0x03
#define ADC_Chanel4 (unsigned char)0x04
#define ADC_Chanel5 (unsigned char)0x05
#define ADC_Chanel6 (unsigned char)0x06
#define ADC_Chanel7 (unsigned char)0x07
//*************************************
// 函数名称：Init_AD
// 函数功能：对AD初始化,开启或关闭ADC电路
// 入口参数：ADC电路使能参数
// 出口参数：无
/***************************************/
void Init_AD(uint8 Mode)
{
uint16 i ;
if(Mode == ENB) //启动ADC电路
{
// F/4 转换时间分频 Fadc = Fmaster/ADC_CR1[4..6]
// [000 F/2] [001 F/3] [010 F/4]
ADC_CR1 = (ADC_CR1 &amp;amp; 0X8F) | 0X00 ; //f/2
// 数据左对齐
ADC_CR2 &amp;amp;= ~0X08 ;
// 启动ADC
ADC_CR1 |= 0X01 ;
// 等待AD电路稳定
for(i=0;i&amp;lt;500;i++) ;
ADC_CSR &amp;amp;= ~0X80 ; //转换结束标志清0
return ;
}
else
{
ADC_CR1 &amp;amp;= ~0X01; //关闭ADC电路
return ;
}
}
//*************************************
// 函数名称：AdcSwitch
// 函数功能: 在单通道模式下转换某一通道的AD值
// 在(扫描模式下)连续转化1-Chanel的AD值
// 入口参数：要转换的AD通道号
// 出口参数：无
/***************************************/
void AdcSwitch(uint8 Chanel)
{
//选择转换通道
ADC_CSR = (ADC_CSR &amp;amp; 0XF0) | Chanel;
// 启动ADC
ADC_CR1 |= 0X01 ;
//等待转换
while(!(ADC_CSR &amp;amp; 0X80));
ADC_CSR &amp;amp;= ~0X80 ;
return ;
}
//*************************************
// 函数名称：Adc_Mode_Scan
// 函数功能: ADC扫描模式设置函数
// 入口参数：扫描模式开启参数
// 出口参数：无
/***************************************/
void Adc_Mode_Scan(uint8 Value)
{
if(Value == ENB)
{
ADC_CR2 |= 0X02 ;
}
else
{
ADC_CR2 &amp;amp;= ~0X02 ;
}
}
//---应用实例-----
//ADC初始化设置
Init_AD(ENB); //初始化ADC电路并开启电路
// Adc_Mode_Scan(OFF) ;//ADC扫描模式使能
//ADC 转换
AdcSwitch(ADC_Chanel3) ;//转换通道3
TmpH = ADC_DRH ; //取转换结果
TmpL = ADC_DRL ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ADC是模拟信号转成数值信号，单片机只能识别TTL电平，其实就是 1 或者 0 ，但是如果我们给它一个3.3V电压，单片机就无法识别，，若想使用单片机读取出来得时候，它必须将模拟量变成数字量。&lt;/p&gt;
&lt;p&gt;了解完后，我们就开始讲解了。&lt;/p&gt;
&lt;p&gt;编译环境：&lt;/p&gt;
&lt;p&gt;我的编译环境是IAR，这款软件是现在STM8的主流平台，比较推荐。不过我打算等到STCubeMX更新出比较方便的版本后再去使用Keil5，因为我在用STM32的时候就是利用Keil5，的确很方便，你们也可以学着用一下。&lt;/p&gt;
&lt;p&gt;主芯片：&lt;/p&gt;
&lt;p&gt;我的主芯片是STM8S系列中的003，其中STM8S的003、005、和103、105，配置一样（外设和CPU频率，FLASH），在代码相同的情况下均可进行烧写。&lt;/p&gt;
&lt;p&gt;库文件的添加：&lt;/p&gt;
&lt;p&gt;我们的工程可以在IAR的例程中复制，操作过程：打开STM8S_StdPeriph_Lib（这是一个官方的库文件，下载IAR STM8包的时候就携带，里面有库文件和相对应的例程），将Libraries文件复制到你工程所在的文件下，并将里面的库函数添加到你的IAR工程列表当中，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/0e5588bbbaeade6cdf46a4a9ec52d731.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;添加完成后，有可能你会看到一些C文件会有红色的小点报错，这是因为你选的芯片上没有该功能，你需要将其删掉才能不报错。&lt;/p&gt;
&lt;p&gt;添加成功后，我们需要将头文件添加进来，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/8d76ac405ea21f52250e01ba6b9a7319.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;你们也可以跟我一样，将不同功能的函数分开写成C文件和H文件，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/b8eeee129f5f70cead857214b69e180c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;代码编写：&lt;/p&gt;
&lt;p&gt;首先，我们需要配置一下内部晶振，并且初始化你所要使用的GPIO、串口。其次，配置ADC，最后对ADC读取函数的进行一个调用，获取ADC值，再用Uart输出。&lt;/p&gt;
&lt;p&gt;晶振配置：&lt;/p&gt;
&lt;p&gt;将所有的晶振幅值都写成枚举，这样的话可以直接通过在主函数调用再传参改变它的晶振大小。&lt;/p&gt;
&lt;pre class=&#34;hljs objectivec&#34;&gt;
1 void Clk_Config(uint8_t SYS_CLOCK) 2{ 3 switch(SYS_CLOCK) 4 { 5 case SYS_CLOCK_2MHZ : CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV8); break; 6 case SYS_CLOCK_4MHZ : CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV4); break; 7 case SYS_CLOCK_8MHZ : CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV2); break; 8 case SYS_CLOCK_16MHZ: CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1); break; 9 default: break; 10 }
11 }
&lt;/pre&gt;
&lt;p&gt;GPIO配置：&lt;/p&gt;
&lt;p&gt;这里将一些所要用到基础的的引角初始化，特殊的GPIO口我们就另外再说。&lt;/p&gt;
&lt;pre class=&#34;hljs java&#34;&gt;
1 void MX_GPIO_Init(void)2 {3 //LED
4 GPIO_Init(Led_Opt_GPIO_Port,Led_Opt_Pin, GPIO_MODE_OUT_PP_HIGH_FAST);5
6 }
&lt;/pre&gt;
&lt;p&gt;Uart配置：&lt;/p&gt;
&lt;p&gt;在STM8S003中，Uart只有 Uart1 可用，所以在这里就只使用这个。将Uart的发送、接收引角在Uart初始化函数里面初始，主要的配置参数为：115200波特率、1个停止位、无奇偶校验位、同步模式禁用、SLK PIN禁用、发送和接收都开启。&lt;/p&gt;
&lt;p&gt;调用UART1_ITConfig( )函数令Uart开启中断。&lt;/p&gt;
&lt;pre class=&#34;hljs java&#34;&gt;
1 void MX_UART1_Init(void) 2 { 3 UART1_DeInit(); 4 GPIO_Init(Uart_TX_GPIO_Port, Uart_TX,GPIO_MODE_OUT_PP_HIGH_FAST); 5 GPIO_Init(Uart_RX_GPIO_Port, Uart_RX,GPIO_MODE_IN_PU_IT); 6 UART1_Init(115200,UART1_WORDLENGTH_8D,UART1_STOPBITS_1,UART1_PARITY_NO,UART1_SYNCMODE_CLOCK_DISABLE,UART1_MODE_TXRX_ENABLE); 7 UART1_ITConfig(UART1_IT_RXNE_OR,ENABLE); 8 UART1_Cmd(ENABLE);//启用串口
9
10 enableInterrupts(); 11 }
&lt;/pre&gt;
&lt;p&gt;ADC:&lt;/p&gt;
&lt;p&gt;STM8SF003这款芯片能用的是5个AD采样通道，分别为为AIN2~AIN6。其一个通道AIN7，但在官方手册中我没找到有对其描述的，感兴趣的朋友可以去察看芯片的英文手册进行研究，也许会找到和我不一样的结果。&lt;/p&gt;
&lt;p&gt;在ADC头文件中，我将ADC1所有的ADC1_CHANNEL（ADC通道）都进行枚举，以方便调用。&lt;/p&gt;
&lt;pre class=&#34;hljs java&#34;&gt;
1 /* Enum ----------------------------------------------------------------------\*/
2
3 enum ADC1_CHANNEL 4 { //bit 8 7 6 5 4 3 2 1
5
6 ADC1_CHANNEL2 = 0x01, // 0 0 0 0 0 0 0 1
7 ADC1_CHANNEL3 = 0x02, // 0 0 0 0 0 0 1 0
8 ADC1_CHANNEL4 = 0x04, // 0 0 0 0 0 1 0 0
9 ADC1_CHANNEL5 = 0x08, // 0 0 0 0 1 0 0 0
10 ADC1_CHANNEL6 = 0x10 // 0 0 0 1 0 0 0 0
11
12 };
&lt;/pre&gt;
&lt;p&gt;在ADC.C文件中，我分为了多个函数，降低他们的耦合性，也方便理解。&lt;/p&gt;
&lt;p&gt;首先是ADC中引角的初始化，将你所选通道的引角进行初始化，没有选到的就不进行初始化。&lt;/p&gt;
&lt;pre class=&#34;hljs markdown&#34;&gt;
1/\*\****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\***\* 2\* Function Name : MX_ADC_GPIO_Init 3\* Description : ADC GPIO Init 4 \* Input : ADC1_CHANNEL 5 \* Output : None 6 \* Return : None 7 \*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\****\*/
8
9 void MX_ADC_GPIO_Init(uint8_t ADC1_CHANNEL)10 {11 switch(ADC1_CHANNEL)12 {13 case ADC1_CHANNEL2: GPIO_Init(ADC_Opt_GPIOC_Port,ADC_channe2_Pin,GPIO_MODE_IN_PU_NO_IT);break;14 case ADC1_CHANNEL3: GPIO_Init(ADC_Opt_GPIOD_Port,ADC_channe3_Pin,GPIO_MODE_IN_PU_NO_IT);break;15 case ADC1_CHANNEL4: GPIO_Init(ADC_Opt_GPIOD_Port,ADC_channe4_Pin,GPIO_MODE_IN_PU_NO_IT);break; 16 case ADC1_CHANNEL5: GPIO_Init(ADC_Opt_GPIOD_Port,ADC_channe5_Pin,GPIO_MODE_IN_PU_NO_IT);break;17 case ADC1_CHANNEL6: GPIO_Init(ADC_Opt_GPIOD_Port,ADC_channe6_Pin,GPIO_MODE_IN_PU_NO_IT);break;18 } 19
20 }
&lt;/pre&gt;
&lt;p&gt;然后是ADC1的选择通道初始化：ADC连续读取，所选的通道，二分频，外部转换触发，外部触发器不开启，数据右对齐，施密特触发，不开启。（注意：STMS8003中的串口使用了PD5和PD6，与ADC1中通道5、通道6发生冲突，故不可使用。如需使用，请将串口的TX\RX引角更改换为其它的引角。）&lt;/p&gt;
&lt;pre class=&#34;hljs markdown&#34;&gt;
1/\*\****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\***\* 2\* Function Name : MX_ADC1_CHANNEL_Init 3 \* Description : ADC CHANNEL Init 4 \* Input : ADC1_CHANNEL 5\* Output : None 6 \* Return : None 7 \*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\****\*/
8
9 void MX_ADC1_CHANNEL_Init(uint8_t ADC1_CHANNEL)10 {11 switch(ADC1_CHANNEL)12 {13 case ADC1_CHANNEL2: 14 {15 ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_2, 16 ADC1_PRESSEL_FCPU_D2, ADC1_EXTTRIG_TIM, DISABLE, 17 ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL2, DISABLE);break;18 }19 case ADC1_CHANNEL3:20 {21 ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_3, 22 ADC1_PRESSEL_FCPU_D2, ADC1_EXTTRIG_TIM, DISABLE, 23 ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL3, DISABLE);break;24 }25 case ADC1_CHANNEL4:26 {27 ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_4, 28 ADC1_PRESSEL_FCPU_D2, ADC1_EXTTRIG_TIM, DISABLE, 29 ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL4, DISABLE);break;30 } 31 case ADC1_CHANNEL5:32 {33 ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_5, 34 ADC1_PRESSEL_FCPU_D2, ADC1_EXTTRIG_TIM, DISABLE, 35 ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL5, DISABLE);break;36 }37 case ADC1_CHANNEL6:38 {39 ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS, ADC1_CHANNEL_6, 40 ADC1_PRESSEL_FCPU_D2, ADC1_EXTTRIG_TIM, DISABLE, 41 ADC1_ALIGN_RIGHT, ADC1_SCHMITTTRIG_CHANNEL6, DISABLE);break;42 }43 } 44 }
&lt;/pre&gt;
&lt;p&gt;这里就是将所有的ADC初始化进行一个统一的一个归类。&lt;/p&gt;
&lt;pre class=&#34;hljs markdown&#34;&gt;
1/\*\****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\***\* 2 \* Function Name : MX_ADC1_Init 3 \* Description : ADC Init 4 \* Input : ADC1_CHANNEL 5 \* Output : None 6 \* Return : None 7 \*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\****\*/
8 void MX_ADC1_Init(uint8_t ADC1_CHANNEL) 9 { 10 //初始化GPIO
11 MX_ADC_GPIO_Init(ADC1_CHANNEL);12
13 //初始化ADC1所有寄存器
14 ADC1_DeInit();15
16 //配置ADC1寄存器中的参数
17 MX_ADC1_CHANNEL_Init(ADC1_CHANNEL);18
19 //使能ADC1
20 ADC1_Cmd(ENABLE);21
22 //ADC1转换开始
23 ADC1_StartConversion();24 }
&lt;/pre&gt;
&lt;p&gt;最后就是数据获取，可以选择直接获取数据，也可以获取十次数据后取平均数。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;ADC获取的值是AD值，需要将其进行代入公式中才能得到电压值。&lt;/p&gt;
&lt;p&gt;Vin = (ADC * Vref) / 1024&lt;/p&gt;
&lt;p&gt;VCC很明显可以使用万用表先测出来，1024是因为STM8S这款的AD是10位精度。&lt;/p&gt;
&lt;p&gt;我这里测试的VCC是3.35V，VCC另外一个意思就是单片机的供给电源。&lt;/p&gt;
&lt;pre class=&#34;hljs markdown&#34;&gt;
1/\*\****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\***\* 2\* Function Name : MX_ADC1_Get_Data 3\* Description : get VCC data 4\* Input : None 5 \* Output : None 6 \* Return : fVCC 7 \*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\****\*/
8 float MX_ADC1_Get_Data(void) 9 {10 int iADC1_Value;11 float fVCC;12
13 //读取转换结果
14 iADC1_Value = ADC1_GetConversionValue();15 fVCC = (iADC1_Value * 3.350)/1024;16 return fVCC;17
18 }19
20
21 /\*\****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\***\*22 \* Function Name : MX_ADC1_Get_Average_Data23 \* Description : Get VCC ten times average data. 24 \* Input : None25 \* Output : None26 \* Return : fAverage_VCC27 \*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\*****\****\*/
28 float MX_ADC1_Get_Average_Data(void)29 {30 int i;31 float fAverage_VCC = 0.0;32
33 for(i=0;i&lt;10;i++)34 {35 fAverage_VCC += MX_ADC1_Get_Data();36 }37 fAverage_VCC /= 10;38 39 return fAverage_VCC;40 41 }
&lt;/pre&gt;
&lt;p&gt;将上面需要用到的函数在主函数中调用打印即可。&lt;/p&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;我用的调试仪器是可调式电源，可通过旋钮控制电压的输出大小。&lt;/p&gt;
&lt;p&gt;当没有输出电压时，打印的值为0V.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/db6885e281442282e62442e615642c6b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当可调式电源输出的电压值为3.3V，串口助手上打印的也是3.3V。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/eb4e38b17ea626010bfeec5d05abd05f.png&#34; alt=&#34;&#34; /&gt;&lt;img src=&#34;https://image.520mwx.com/static/40431ffc241f7a6082ba55d53519a77c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当可调式电源输出的电压值为24V，串口助手上打印的也是24V。&lt;/p&gt;
&lt;p&gt;注意：请不要将24V电源直接通入单片机中，我是自己设置了一条电路进行测试的。ADC的最大输入电压是3.3V，为了安全起见，请不要超过该值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image.520mwx.com/static/cdd27ebd75872f4b224c67e7069548d1.jpg&#34; alt=&#34;&#34; /&gt;&lt;img src=&#34;https://image.520mwx.com/static/f9cdd926c78f16740a14c75a186a76b1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;基于STM8的ADC读取说明到此结束，感谢大家观看。&lt;/p&gt;</description></item><item><title>stm8</title><link>/hardware/stm32/stm8/</link><pubDate>Tue, 17 Mar 2020 15:36:01 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/stm8/</guid><description>&lt;p&gt;&lt;a href=&#34;https://github.com/fifteenhex/openebdmini.git&#34; target=&#34;_blank&#34;&gt;https://github.com/fifteenhex/openebdmini.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hashsum0/STM8S_SDCC.git&#34; target=&#34;_blank&#34;&gt;https://github.com/hashsum0/STM8S_SDCC.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jjflash65/stm8s103&#34; target=&#34;_blank&#34;&gt;jjflash65/stm8s103: STM8S103F3P6 - Hardwareanbindung und Demoprogramme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/yuxiao/stm8s_lib.git&#34; target=&#34;_blank&#34;&gt;https://github.com/yuxiao/stm8s_lib.git&lt;/a&gt;&lt;/p&gt;</description></item><item><title>clang setbit clearbit</title><link>/language/clang/clang-setbit-clearbit/</link><pubDate>Tue, 17 Mar 2020 14:31:44 CST</pubDate><author>rinetd</author><guid>/language/clang/clang-setbit-clearbit/</guid><description>
&lt;p&gt;/include/linux/bitops.h&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define SET_BIT(x, n) (x |= (1 &amp;lt;&amp;lt; n))
#define CLR_BIT(x, n) (x &amp;amp;= ~(1 &amp;lt;&amp;lt; n))
#define GET_BIT(x, n) ((x &amp;gt;&amp;gt; n) &amp;amp; 0x01)
#define set_bit(register_8, bit) (register_8 |= (1 &amp;lt;&amp;lt; bit))
#define clear_bit(register_8, bit) (register_8 &amp;amp;= ~(1 &amp;lt;&amp;lt; bit))
#define toggle_bit(register_8, bit) (register_8 ^= (1 &amp;lt;&amp;lt; bit))
#define set_bit(reg,bit) reg|=(1&amp;lt;&amp;lt;bit) //pondra en 1 el bit elegido de la variable elegida.
#define clr_bit(reg,bit) reg&amp;amp;=~(1&amp;lt;&amp;lt;bit) //pondra en 0 el bit elegido de la variable elegida.
#define tog_bit(reg,bit) reg^=(1&amp;lt;&amp;lt;bit) //toggleara el bit elegido de la variable elegida.
#define set_output(ddr,bit) ddr|=(1&amp;lt;&amp;lt;bit) //setea salida.
#define set_input(ddr,bit) ddr&amp;amp;=~(1&amp;lt;&amp;lt;bit) //setea entrada.
#define get_bit(ddr,bit) ((ddr&amp;gt;&amp;gt;bit)&amp;amp;1) //devuelve el bit elegido de la variable elegida (para if).
#define clr_reg(reg) reg&amp;amp;=0 //limpia el registro elegido.
#define set_reg(reg) reg|=255
#define led4_out set_output(DDRD,4)
#define led5_out set_output(DDRD,5)
#define led6_out set_output(DDRD,6)
#define led7_out set_output(DDRD,7)
#define led4_off set_bit(PORTD,4)
#define led5_off set_bit(PORTD,5)
#define led6_off set_bit(PORTD,6)
#define led7_off set_bit(PORTD,7)
#define HIGH 1
#define LOW 0
#define TRUE 1
#define FALSE 0
#define ON 1
#define OFF 0
#define TOGGLE 2
#define ENABLE 1
#define DISABLE 0
#define ENABLED 1
#define DISABLED 0
#define NO 0
#define YES 1
#define PRESSED 1
#define STOP 0
#define FORWARD 1
#define REVERSE 2
#define SPIN_RIGHT 3
#define SPIN_LEFT 4
#define set_bit(var, pin) var |= 1&amp;lt;&amp;lt;(unsigned char) pin
#define clear_bit(var, pin) var &amp;amp;= ~(1&amp;lt;&amp;lt;(unsigned char)pin)
#define test_bit(var, pin) ((var &amp;amp; (1&amp;lt;&amp;lt;(unsigned char) pin)) &amp;gt;&amp;gt; pin)
#define toggle_bit(var, pin) var ^= 1&amp;lt;&amp;lt;(unsigned char) pin
#define clr_bit(var, pin) clear_bit(var,pin)
#define tog_bit(var, pin) toggle_bit(var,pin)
#define tst_bit(var, pin) var &amp;amp; (1&amp;lt;&amp;lt;(unsigned char) pin)
//#define set_bit(var, pin) var |= 1&amp;lt;&amp;lt;(unsigned char) pin
//#define clr_bit(var, pin) var &amp;amp;= ~(1&amp;lt;&amp;lt;(unsigned char)pin)
//#define tog_bit(var, pin) var ^= 1&amp;lt;&amp;lt;(unsigned char) pin
#define input_bit(var, pin) var &amp;amp;= ~(1&amp;lt;&amp;lt;(unsigned char) pin)
#define output_bit(var, pin) var |= 1&amp;lt;&amp;lt;(unsigned char) pin
#define digital_read(pin) pin_value(pin + 8)
#define quit() while(1)
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;contect&#34;&gt;contect&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/* Handy macros for GPIO */
#define CONCAT(a, b) a##_##b
#define PORT(a, b) CONCAT(a , b)
#define LED_PORT PD
#define LED_PIN PIN3
/* GPIO setup */
// Set pin data direction as output
PORT(LED_PORT, DDR) |= LED_PIN; // i.e. PB_DDR |= (1 &amp;lt;&amp;lt; 5);
// Set pin as &amp;quot;Push-pull&amp;quot;
PORT(LED_PORT, CR1) |= LED_PIN; // i.e. PB_CR1 |= (1 &amp;lt;&amp;lt; 5);
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>smt8 sdcc</title><link>/hardware/stm32/smt8-sdcc/</link><pubDate>Tue, 17 Mar 2020 11:39:17 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/smt8-sdcc/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://github.com/EMBEDONIX/stm8&#34; target=&#34;_blank&#34;&gt;https://github.com/EMBEDONIX/stm8&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/roshbaby/stm8s-sdcc&#34; target=&#34;_blank&#34;&gt;roshbaby/stm8s-sdcc: STM8S Standard Peripheral Library Ported to SDCC for multiple STM8 targets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/TG9541/stm8ef/wiki/STM8S-Programming&#34; target=&#34;_blank&#34;&gt;STM8S Programming · TG9541/stm8ef Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.nubix.de/index.php/2018/09/18/stm8-development-with-eclipse-and-macos/&#34; target=&#34;_blank&#34;&gt;STM8 development with Eclipse and macOS – nubix-Weblog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;setup-eclipse&#34;&gt;Setup Eclipse&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eclipse.org/downloads/&#34; target=&#34;_blank&#34;&gt;Eclipse&lt;/a&gt; can be configured to allow development of C++ firmware cod for the STM8 with editing, flashing and &lt;del&gt;debugging&lt;/del&gt;. There are some steps that are critical to get Eclipse to work with the STM8 board.&lt;/p&gt;
&lt;h4 id=&#34;1-install-homebrew-on-mac&#34;&gt;1. Install HomeBrew on Mac&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;HomeBrew is used to comfortably install necessary tools over the command line&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;only needed to be installed if not installed yet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;maybe ‘brew doctor’ shows errors that have to be fixed before using HomeBrew&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ruby -e &amp;quot;$(curl -fsSL &lt;a href=&#34;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/a&gt;&lt;br /&gt;
brew update&lt;br /&gt;
brew doctor&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ruby -e &amp;quot;$(curl -fsSL &lt;a href=&#34;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;brew update&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;brew doctor&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ruby -e &amp;quot;$(curl -fsSL &lt;a href=&#34;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&#34; target=&#34;_blank&#34;&gt;https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/a&gt;&lt;br /&gt;
brew update&lt;br /&gt;
brew doctor&lt;/p&gt;
&lt;h4 id=&#34;2-setup-of-programmer-st-link-v2&#34;&gt;2. Setup of Programmer ST-Link/V2&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.st.com/en/development-tools/st-link-v2.html&#34; target=&#34;_blank&#34;&gt;ST-LINK/V2&lt;/a&gt; is a programmer and debugger for STM8 and STM32&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;can be installed with HomeBrewn&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;brew install autoconf automake pkg-config libusb libusb-compat stlink&lt;br /&gt;
st-util -h&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brew install autoconf automake pkg-config libusb libusb-compat stlink&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;st-util -h&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;brew install autoconf automake pkg-config libusb libusb-compat stlink&lt;br /&gt;
st-util -h&lt;/p&gt;
&lt;h2 id=&#34;stop&#34;&gt;Stop!&lt;/h2&gt;
&lt;p&gt;st-util does not recognize the DISCOVERY board and has problems using it. A quick research shows that the tool only supports the SWD-mode for STM32-MCU’s. The STM8-MCU’s need the SWIM-mode. This mode is only usable with the tool stm8-flash that is not well-maintained. This tool does not allow debugging at the moment. Conclusion: &lt;strong&gt;Debugging of STM8 code is not usable under Linux or Mac OS X.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-install-sdcc-cross-compiler&#34;&gt;3. Install SDCC Cross-Compiler&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sdcc.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;SDCC is a free cross-complier&lt;/a&gt; for multiple microcontrollers &lt;a href=&#34;http://www.colecovision.eu/stm8/compilers.shtml&#34; target=&#34;_blank&#34;&gt;with great compatibility and able to generate excellent results&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;brew install sdcc&lt;br /&gt;
sdcc -v&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brew install sdcc&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sdcc -v&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;brew install sdcc&lt;br /&gt;
sdcc -v&lt;/p&gt;
&lt;h4 id=&#34;4-install-stm8flash-https-github-com-vdudouyt-stm8flash&#34;&gt;4. Install &lt;a href=&#34;https://github.com/vdudouyt/stm8flash&#34; target=&#34;_blank&#34;&gt;STM8Flash&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;git clone &lt;a href=&#34;https://github.com/vdudouyt/stm8flash.git&#34; target=&#34;_blank&#34;&gt;https://github.com/vdudouyt/stm8flash.git&lt;/a&gt;&lt;br /&gt;
cd stm8flash&lt;br /&gt;
make&lt;br /&gt;
make install&lt;br /&gt;
cd ..&lt;br /&gt;
rm -R stm8flash&lt;br /&gt;
stm8flash&lt;/p&gt;
&lt;h4 id=&#34;5-test-if-the-stm8l-discovery-board-is-responding&#34;&gt;5. Test if the STM8L-DISCOVERY board is responding&lt;/h4&gt;
&lt;p&gt;stm8flash -c stlinkv2 -p stm8l152?6 -r test.ihx&lt;/p&gt;
&lt;p&gt;stm8flash -c stlinkv2 -p stm8s003f3 -r blinky.ihx&lt;/p&gt;
&lt;p&gt;stm8flash -c &lt;stlink|stlinkv2|espstlink&gt; -p &lt;partname&gt; [-s flash|eeprom|0x8000] [-r|-w|-v] &lt;filename&gt;&lt;br /&gt;
The supported file types are Intel Hex, Motorola S-Record and Raw Binary. The type is detected by the file extension.&lt;/p&gt;
&lt;p&gt;Flash examples:&lt;/p&gt;
&lt;p&gt;./stm8flash -c stlinkv2 -p stm8s003f3 -r blinky.ihx&lt;br /&gt;
./stm8flash -c stlinkv2 -p stm8s003f3 -w blinky.ihx&lt;/p&gt;
&lt;p&gt;EEPROM examples:&lt;/p&gt;
&lt;p&gt;./stm8flash -c stlinkv2 -p stm8s003f3 -s eeprom -r ee.bin # 读取文件&lt;br /&gt;
./stm8flash -c stlinkv2 -p stm8s003f3 -s eeprom -w ee.bin # 写入文件&lt;br /&gt;
./stm8flash -c stlinkv2 -p stm8s003f3 -s eeprom -v ee.bin # 验证文件&lt;/p&gt;
&lt;h3 id=&#34;修改opt选项&#34;&gt;修改OPT选项&lt;/h3&gt;
&lt;p&gt;echo &amp;quot;00 00 ff 02 fd 00 ff 00 ff 00 ff&amp;quot; | xxd -r -p &amp;gt; option_bytes.bin&lt;br /&gt;
stm8flash -c stlinkv2 -p stm8s003f3 -s opt -w option_bytes.bin&lt;br /&gt;
stm8flash -c stlinkv2 -p stm8s003f3 -s flash -w voliera.ihx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;export PATH := $(PATH):$(HOME)/local/sdcc/bin
MCU = stm8s003f3
ARCH = stm8
F_CPU ?= 2000000
TARGET ?= main.ihx
#LIBDIR = ../../inc
INCDIR = ../../inc
SRCDIR = ../../src
SRCS := $(wildcard *.c $(SRCDIR)/*.c)
ASRCS := $(wildcard *.s $(SRCDIR)/*.s)
OBJS = $(SRCS:.c=.rel)
OBJS += $(ASRCS:.s=.rel)
CC = sdcc
LD = sdld
AS = sdasstm8
OBJCOPY = sdobjcopy
ASFLAGS = -plosgff
CFLAGS = -m$(ARCH) -p$(MCU) --std-sdcc11
CFLAGS += -DF_CPU=$(F_CPU)UL -I. -I$(INCDIR)
CFLAGS += --stack-auto --noinduction --use-non-free
## Extra optimization rules - use with care
#CFLAGS += --peep-file $(LIBDIR)/util/extra.def
LDFLAGS = -m$(ARCH) -l$(ARCH) --out-fmt-ihx
all: $(TARGET) size
$(TARGET): $(OBJS)
$(CC) $(LDFLAGS) $(OBJS) -o $@
%.rel: %.c
$(CC) $(CFLAGS) $(INCLUDE) -c $&amp;lt; -o $@
%.rel: %.s
$(AS) $(ASFLAGS) $&amp;lt;
size:
@$(OBJCOPY) -I ihex --output-target=binary $(TARGET) $(TARGET).bin
@echo &amp;quot;----------&amp;quot;
@echo &amp;quot;Image size:&amp;quot;
@stat -L -c %s $(TARGET).bin
flash: $(TARGET)
stm8flash -c stlinkv2 -p $(MCU) -w $(TARGET)
clean:
rm -f *.map *.asm *.rel *.ihx *.o *.sym *.lk *.lst *.rst *.cdb *.bin
.PHONY: clean all flash
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>stm8 cube</title><link>/hardware/stm32/stm8-cube/</link><pubDate>Tue, 17 Mar 2020 10:52:30 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/stm8-cube/</guid><description>
&lt;p&gt;3.2.2Installing STM8CubeMX from command lineThere&lt;/p&gt;
&lt;h3 id=&#34;install-on-macos&#34;&gt;INSTALL on macos&lt;/h3&gt;
&lt;p&gt;nteractive modeTo perform interactive installation, type the following command:java –jar SetupSTM8CubeMX-1.0.0.exe –cons&lt;/p&gt;
&lt;p&gt;Figure 3. STM8Cube Installation WizardYou can then launch the installation just by typing the following command:&lt;br /&gt;
&lt;code&gt;java –jar SetupSTM8CubeMX-1.0.0.exe auto-install.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Uninstalling STM8CubeMX on MacOSTo uninstall STM8CubeMX on MacOS, use the following command line:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar &amp;lt;STM8CubeMX installation path&amp;gt;/Uninstaller/uninstaller&lt;/code&gt;&lt;/p&gt;</description></item><item><title>macos stm32 stlink arm gcc embeded</title><link>/hardware/stm32/macos-stm32-stlink-arm-gcc-embeded/</link><pubDate>Mon, 16 Mar 2020 21:09:18 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/macos-stm32-stlink-arm-gcc-embeded/</guid><description>
&lt;blockquote&gt;
&lt;p&gt;macOS 开发 MCU，基本上就是 Ecllipse + GNU ARM GCC + OpenOCD这套（&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgnu-mcu-eclipse.github.io%2F&#34; target=&#34;_blank&#34;&gt;GNU MCU Eclipse&lt;/a&gt;）组合，虽然已经很不错了，但是用了 JetBrain 家的 IDE 后，发现 CLion 还是比 Eclipse 好用不少，，，&lt;br /&gt;
所以，如果你有STM32的评估板，然后加上&lt;code&gt;CLion(及插件) + GNU ARM GCC + OpenOCD&lt;/code&gt;这套组合，至少在写代码层面上，是最爽的。&lt;br /&gt;
目前，还只支持&lt;code&gt;st-link&lt;/code&gt;，相信后面JLink啥的也会很快跟上，到时候就可以扔掉 Keil了。&lt;br /&gt;
装完后，结合STM32CubeMX生成代码后，可以用 make 编译 和 st-flash 下载，也可以用 CLion(CMake) 编译和 OpenOCD下载，在线仿真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;安装编译器：&lt;code&gt;arm-gcc-none-eabi-gcc&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ ~ brew cask install gcc-arm-embedded
==&amp;gt; Satisfying dependencies
==&amp;gt; Downloading https://developer.arm.com/-/media/Files/downloads/gnu-rm/7-2017q4/gcc-arm-none-eabi-7-2017-q4-major-mac.tar.bz2
######################################################################## 100.0%
==&amp;gt; Verifying checksum for Cask gcc-arm-embedded
==&amp;gt; Installing Cask gcc-arm-embedded
==&amp;gt; Linking Binary &#39;arm-none-eabi-strip&#39; to &#39;/usr/local/bin/arm-none-eabi-strip&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-ar&#39; to &#39;/usr/local/bin/arm-none-eabi-ar&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-as&#39; to &#39;/usr/local/bin/arm-none-eabi-as&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-c++&#39; to &#39;/usr/local/bin/arm-none-eabi-c++&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-c++filt&#39; to &#39;/usr/local/bin/arm-none-eabi-c++filt&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-cpp&#39; to &#39;/usr/local/bin/arm-none-eabi-cpp&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-elfedit&#39; to &#39;/usr/local/bin/arm-none-eabi-elfedit&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-g++&#39; to &#39;/usr/local/bin/arm-none-eabi-g++&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcc&#39; to &#39;/usr/local/bin/arm-none-eabi-gcc&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcc-ar&#39; to &#39;/usr/local/bin/arm-none-eabi-gcc-ar&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcc-nm&#39; to &#39;/usr/local/bin/arm-none-eabi-gcc-nm&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcc-ranlib&#39; to &#39;/usr/local/bin/arm-none-eabi-gcc-ranlib&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcov&#39; to &#39;/usr/local/bin/arm-none-eabi-gcov&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gcov-tool&#39; to &#39;/usr/local/bin/arm-none-eabi-gcov-tool&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gdb&#39; to &#39;/usr/local/bin/arm-none-eabi-gdb&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gdb-py&#39; to &#39;/usr/local/bin/arm-none-eabi-gdb-py&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-gprof&#39; to &#39;/usr/local/bin/arm-none-eabi-gprof&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-ld&#39; to &#39;/usr/local/bin/arm-none-eabi-ld&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-ld.bfd&#39; to &#39;/usr/local/bin/arm-none-eabi-ld.bfd&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-nm&#39; to &#39;/usr/local/bin/arm-none-eabi-nm&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-objcopy&#39; to &#39;/usr/local/bin/arm-none-eabi-objcopy&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-objdump&#39; to &#39;/usr/local/bin/arm-none-eabi-objdump&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-ranlib&#39; to &#39;/usr/local/bin/arm-none-eabi-ranlib&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-readelf&#39; to &#39;/usr/local/bin/arm-none-eabi-readelf&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-size&#39; to &#39;/usr/local/bin/arm-none-eabi-size&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-strings&#39; to &#39;/usr/local/bin/arm-none-eabi-strings&#39;.
==&amp;gt; Linking Binary &#39;arm-none-eabi-addr2line&#39; to &#39;/usr/local/bin/arm-none-eabi-addr2line&#39;.
gcc-arm-embedded was successfully installed!
➜ ~ arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for Arm Embedded Processors 7-2017-q4-major) 7.2.1 20170904 (release) [ARM/embedded-7-branch revision 255204]
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
➜ ~ which arm-none-eabi-gcc
/usr/local/bin/arm-none-eabi-gcc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgist.github.com%2Fjoegoggins%2F7763637&#34; target=&#34;_blank&#34;&gt;How I installed GCC ARM on my Mac 10.9 Mac Book Pro&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装下载调试器：&lt;code&gt;st-link&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ u-boot-2016.05 brew install stlink
Updating Homebrew...
==&amp;gt; Auto-updated Homebrew!
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/stlink-1.4.0.el_capitan.bottle.tar.gz
######################################################################## 100.0%
==&amp;gt; Pouring stlink-1.4.0.el_capitan.bottle.tar.gz
/usr/local/Cellar/stlink/1.4.0: 27 files, 702KB
➜ u-boot-2016.05 st-info --version
v1.4.0
➜ ~ st-info --flash
0x80000
➜ ~ st-info --version
v1.4.0
➜ ~ st-info --flash
➜ ~ st-info --chipid
0x0433
➜ ~ st-info --serial
303636454646343934393531373835
➜ ~ st-flash
invalid command line
stlinkv1 command line: ./st-flash [--debug] [--reset] [--format &amp;lt;format&amp;gt;] [--flash=&amp;lt;fsize&amp;gt;] {read|write} /dev/sgX &amp;lt;path&amp;gt; &amp;lt;addr&amp;gt; &amp;lt;size&amp;gt;
stlinkv1 command line: ./st-flash [--debug] /dev/sgX erase
stlinkv2 command line: ./st-flash [--debug] [--reset] [--serial &amp;lt;serial&amp;gt;] [--format &amp;lt;format&amp;gt;] [--flash=&amp;lt;fsize&amp;gt;] {read|write} &amp;lt;path&amp;gt; &amp;lt;addr&amp;gt; &amp;lt;size&amp;gt;
stlinkv2 command line: ./st-flash [--debug] [--serial &amp;lt;serial&amp;gt;] erase
stlinkv2 command line: ./st-flash [--debug] [--serial &amp;lt;serial&amp;gt;] reset
Use hex format for addr, &amp;lt;serial&amp;gt; and &amp;lt;size&amp;gt;.
fsize: Use decimal, octal or hex by prefix 0xXXX for hex, optionally followed by k=KB, or m=MB (eg. --flash=128k)
Format may be &#39;binary&#39; (default) or &#39;ihex&#39;, although &amp;lt;addr&amp;gt; must be specified for binary format only.
./st-flash [--version]
➜ ~ st-flash erase
st-flash 1.4.0
2017-12-31T17:30:22 INFO src/common.c: Loading device parameters....
2017-12-31T17:30:22 INFO src/common.c: Device connected is: F4 device (Dynamic Efficency), id 0x10006433
2017-12-31T17:30:22 INFO src/common.c: SRAM size: 0x18000 bytes (96 KiB), Flash: 0x80000 bytes (512 KiB) in pages of 16384 bytes
Mass erasing......
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;新建跑马灯例程：&lt;a href=&#34;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.st.com%2Fen%2Fdevelopment-tools%2Fstm32cubemx.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;STM32CubeMX&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.1 下载安装 STM32CubeMX 后，&lt;code&gt;New Project&lt;/code&gt;新建 &lt;a href=&#34;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.st.com%2Fen%2Fevaluation-tools%2Fnucleo-f401re.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;NUCLEO-F401RE&lt;/code&gt;&lt;/a&gt; 工程，选择板子或者芯片型号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-29f3a4503c81ba28.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;选择板子或者芯片型号&lt;/p&gt;
&lt;p&gt;3.2 &lt;code&gt;Boards List&lt;/code&gt;中选中的板子，双击打开配置界面，根据 &lt;a href=&#34;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.st.com%2Fcontent%2Fccc%2Fresource%2Ftechnical%2Fdocument%2Fuser_manual%2F98%2F2e%2Ffa%2F4b%2Fe0%2F82%2F43%2Fb7%2FDM00105823.pdf%2Ffiles%2FDM00105823.pdf%2Fjcr%3Acontent%2Ftranslations%2Fen.DM00105823.pdf&#34; target=&#34;_blank&#34;&gt;UM1724 文档&lt;/a&gt; 的 6.4 小节可以看到，LED2为 PA5。如果之前是选择的板子，那么Cube就已经帮你设定好了；如果选择的时芯片，那么自己标记一下就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-0c5ecaeaed685add.png?imageMogr2/auto-orient/strip|imageView2/2/w/866/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;LD2&lt;/p&gt;
&lt;p&gt;3.2 保存配置，并生成工程和代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-56fe47a3be0cbd1a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;选择 Makefile&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-4339defc776e9f94.png?imageMogr2/auto-orient/strip|imageView2/2/w/902/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;工程文件结构&lt;/p&gt;
&lt;p&gt;3.3 进入工程所在根目录，&lt;code&gt;make&lt;/code&gt;工程，并修复 Cube 的自动生成的一些 Makefile 的错误。&lt;/p&gt;
&lt;p&gt;错误一：没有指定 &lt;code&gt;arm-none-eabi-gcc&lt;/code&gt;完整路径，提示找不到编译器&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ 0_blinking make
mkdir build
/arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -DUSE_HAL_DRIVER -DSTM32F401xE -IInc -IDrivers/STM32F4xx_HAL_Driver/Inc -IDrivers/STM32F4xx_HAL_Driver/Inc/Legacy -IDrivers/CMSIS/Device/ST/STM32F4xx/Include -IDrivers/CMSIS/Include -Og -Wall -fdata-sections -ffunction-sections -g -gdwarf-2 -MMD -MP -MF&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -MT&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -Wa,-a,-ad,-alms=build/stm32f4xx_hal_gpio.lst Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c -o build/stm32f4xx_hal_gpio.o
/bin/sh: /arm-none-eabi-gcc: No such file or directory
make: *** [build/stm32f4xx_hal_gpio.o] Error 127
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修复一：添加 &lt;code&gt;BINPATH&lt;/code&gt;路径，可以用&lt;code&gt;which arm-none-eabi-gcc&lt;/code&gt; 查看确认&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#######################################
# binaries
#######################################
BINPATH = /usr/local/bin/
PREFIX = arm-none-eabi-
CC = $(BINPATH)/$(PREFIX)gcc
AS = $(BINPATH)/$(PREFIX)gcc -x assembler-with-cpp
CP = $(BINPATH)/$(PREFIX)objcopy
AR = $(BINPATH)/$(PREFIX)ar
SZ = $(BINPATH)/$(PREFIX)size
HEX = $(CP) -O ihex
BIN = $(CP) -O binary -S
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误二：多次引用源代码，导致链接时重复&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ 0_blinking make
/usr/local/bin//arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -DUSE_HAL_DRIVER -DSTM32F401xE -IInc -IDrivers/STM32F4xx_HAL_Driver/Inc -IDrivers/STM32F4xx_HAL_Driver/Inc/Legacy -IDrivers/CMSIS/Device/ST/STM32F4xx/Include -IDrivers/CMSIS/Include -Og -Wall -fdata-sections -ffunction-sections -g -gdwarf-2 -MMD -MP -MF&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -MT&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -Wa,-a,-ad,-alms=build/stm32f4xx_hal_gpio.lst Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c -o build/stm32f4xx_hal_gpio.o
············
build/stm32f4xx_hal_msp.o: In function `HAL_MspInit&#39;:
/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/stm32f4xx_hal_msp.c:50: multiple definition of `HAL_MspInit&#39;
build/stm32f4xx_hal_msp.o:/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/stm32f4xx_hal_msp.c:50: first defined here
build/main.o: In function `_Error_Handler&#39;:
/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:222: multiple definition of `_Error_Handler&#39;
build/main.o:/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:222: first defined here
build/main.o: In function `SystemClock_Config&#39;:
/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:113: multiple definition of `SystemClock_Config&#39;
build/main.o:/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:113: first defined here
build/main.o: In function `main&#39;:
/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:68: multiple definition of `main&#39;
build/main.o:/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/main.c:68: first defined here
build/stm32f4xx_it.o: In function `SysTick_Handler&#39;:
/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/stm32f4xx_it.c:52: multiple definition of `SysTick_Handler&#39;
build/stm32f4xx_it.o:/Users/linjinhui/workplace/stm32f401re/0_blinking/Src/stm32f4xx_it.c:52: first defined here
collect2: error: ld returned 1 exit status
make: *** [build/0_blinking.elf] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修复二：去除&lt;code&gt;C_SOURCES&lt;/code&gt;中重复的源文件（注：去除后面那个多出来的，具体是&lt;code&gt;stm32f4xx_it.c&lt;/code&gt;，&lt;code&gt;stm32f4xx_hal_msp.c&lt;/code&gt;，&lt;code&gt;main.c&lt;/code&gt;），修改完如下&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;######################################
# source
######################################
# C sources
C_SOURCES = \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c \
Src/stm32f4xx_it.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rcc_ex.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_tim.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rcc.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_cortex.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma_ex.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_tim_ex.c \
Src/stm32f4xx_hal_msp.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c \
Src/main.c \
Src/system_stm32f4xx.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash_ramfunc.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c \
Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_flash_ex.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次&lt;code&gt;make&lt;/code&gt;，成功在&lt;code&gt;build&lt;/code&gt;子目录下编译出文件显示如下：&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ 0_blinking make
/usr/local/bin//arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -DUSE_HAL_DRIVER -DSTM32F401xE -IInc -IDrivers/STM32F4xx_HAL_Driver/Inc -IDrivers/STM32F4xx_HAL_Driver/Inc/Legacy -IDrivers/CMSIS/Device/ST/STM32F4xx/Include -IDrivers/CMSIS/Include -Og -Wall -fdata-sections -ffunction-sections -g -gdwarf-2 -MMD -MP -MF&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -MT&amp;quot;build/stm32f4xx_hal_gpio.d&amp;quot; -Wa,-a,-ad,-alms=build/stm32f4xx_hal_gpio.lst Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_gpio.c -o build/stm32f4xx_hal_gpio.o
.............
/usr/local/bin//arm-none-eabi-size build/0_blinking.elf
text data bss dec hex filename
4280 12 1572 5864 16e8 build/0_blinking.elf
/usr/local/bin//arm-none-eabi-objcopy -O ihex build/0_blinking.elf build/0_blinking.hex
/usr/local/bin//arm-none-eabi-objcopy -O binary -S build/0_blinking.elf build/0_blinking.bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;st-flash&lt;/code&gt;下载跑马灯：&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ 0_blinking st-flash write ./build/0_blinking.bin 0x8000000
st-flash 1.4.0
2018-01-07T22:49:52 INFO src/common.c: Loading device parameters....
2018-01-07T22:49:52 INFO src/common.c: Device connected is: F4 device (Dynamic Efficency), id 0x10006433
2018-01-07T22:49:52 INFO src/common.c: SRAM size: 0x18000 bytes (96 KiB), Flash: 0x80000 bytes (512 KiB) in pages of 16384 bytes
2018-01-07T22:49:52 INFO src/common.c: Attempting to write 4204 (0x106c) bytes to stm32 address: 134217728 (0x8000000)
Flash page at addr: 0x08000000 erased
2018-01-07T22:49:52 INFO src/common.c: Finished erasing 1 pages of 16384 (0x4000) bytes
2018-01-07T22:49:52 INFO src/common.c: Starting Flash write for F2/F4/L4
2018-01-07T22:49:52 INFO src/flash_loader.c: Successfully loaded flash loader in sram
enabling 32-bit flash writes
size: 4204
2018-01-07T22:49:52 INFO src/common.c: Starting verification of write complete
2018-01-07T22:49:52 INFO src/common.c: Flash written and verified! jolly good!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哦，没反应，忘了翻转了，还有，另外不要忘了跳冒要接好，，，&lt;br /&gt;
修改&lt;code&gt;main&lt;/code&gt;函数中&lt;code&gt;while(1)&lt;/code&gt;，翻转起来：&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
/* USER CODE END WHILE */
/* USER CODE BEGIN 3 */
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
HAL_Delay(500);
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
HAL_Delay(500);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次编译和下载，闪起来了，，，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在线仿真调试 IDE：&lt;code&gt;CLion&lt;/code&gt;+&lt;code&gt;OpenOCD&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5.1 安装 OpenOCD：&lt;code&gt;brew install openocd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜ ~ brew install openocd --enable_ft2232_libftdi --enable_stlink
Updating Homebrew...
==&amp;gt; Auto-updated Homebrew!
Updated 4 taps (caskroom/cask, caskroom/versions, homebrew/core, homebrew/science).
==&amp;gt; New Formulae
opencascade
Warning: open-ocd: this formula has no --enable_ft2232_libftdi option so it will be ignored!
Warning: open-ocd: this formula has no --enable_stlink option so it will be ignored!
==&amp;gt; Downloading https://homebrew.bintray.com/bottles/open-ocd-0.10.0.el_capitan.bottle.1.tar.gz
######################################################################## 100.0%
==&amp;gt; Pouring open-ocd-0.10.0.el_capitan.bottle.1.tar.gz
/usr/local/Cellar/open-ocd/0.10.0: 632 files, 4.7MB
➜ ~ which openocd
/usr/local/bin/openocd
➜ ~ openocd
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
http://openocd.org/doc/doxygen/bugs.html
embedded:startup.tcl:60: Error: Can&#39;t find openocd.cfg
in procedure &#39;script&#39;
at file &amp;quot;embedded:startup.tcl&amp;quot;, line 60
Error: Debug Adapter has to be specified, see &amp;quot;interface&amp;quot; command
embedded:startup.tcl:60: Error:
in procedure &#39;script&#39;
at file &amp;quot;embedded:startup.tcl&amp;quot;, line 60
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.2 CLion 及其插件&lt;/p&gt;
&lt;p&gt;如果要Debug，则需要重新用Cube生成&lt;code&gt;SW4STM32&lt;/code&gt;，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-ddb9c38ad839cd7b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;SW4STM32&lt;/p&gt;
&lt;p&gt;安装 &lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.jetbrains.com%2Fclion%2F&#34; target=&#34;_blank&#34;&gt;CLion&lt;/a&gt; 及其插件&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felmot%2Fclion-embedded-arm&#34; target=&#34;_blank&#34;&gt;clion-embedded-arm&lt;/a&gt;后，导入刚才 Cube 生成的工程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-03c5185fcb983e3a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;导入工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-baa51b873a074633.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;勾选文件&lt;/p&gt;
&lt;p&gt;CLion 会自动生成 &lt;code&gt;CMakeLists.txt&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-a2f4a43eb08b3534.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;p&gt;用插件生成&lt;code&gt;CMakeLists.txt&lt;/code&gt;来替换原来的&lt;code&gt;CMakeLists.txt&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-cb61aba0c518f0d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1050/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-84141089092e8fcd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;p&gt;此时，选择&lt;code&gt;Run&lt;/code&gt;-&amp;gt;&lt;code&gt;Build&lt;/code&gt;显示编译成功如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-9c78303c2608c0aa.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;p&gt;配置 OpenOCD 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-bccd8e902ceb65be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenOCD目前一定要符合完整结构，见 &lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felmot%2Fclion-embedded-arm%2Fissues%2F59&#34; target=&#34;_blank&#34;&gt;Issue&lt;/a&gt; 那么之前安装的不就没啥用了，汗，不过作者也在重新考虑是否需要完整的目录结构，因为好多人碰到这个问题了。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;去掉自带的 GDB，否则提示错误格式，见&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Felmot%2Fclion-embedded-arm%2Fissues%2F70&#34; target=&#34;_blank&#34;&gt;Issue&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;macOS和Linux下，Toolchains选项和CMake选项默认不用修改，Windows需要安装 MinGW 或者 Cygwin。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后，就可以愉快的 Debug 在线仿真了，，，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/26219-81a44deaf6391f40.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Debug&lt;/p&gt;
&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.jetbrains.com%2Fhelp%2Fclion%2Fembedded-development.html&#34; target=&#34;_blank&#34;&gt;Embedded Development &lt;/a&gt; ：2019.01 CLion 官方支持，配合下面的插件，按官方提示即可安装成功&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fplugins.jetbrains.com%2Fplugin%2F10115-openocd--stm32cubemx-support-for-arm-embedded-development&#34; target=&#34;_blank&#34;&gt;OpenOCD +​ STM32CubeMX support for ARM embedded development&lt;/a&gt;：插件，安装更加简答&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fblog.jetbrains.com%2Fclion%2F2016%2F06%2Fclion-for-embedded-development%2F&#34; target=&#34;_blank&#34;&gt;CLion for embedded development&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://links.jianshu.com/go?to=https%3A%2F%2Fblog.jetbrains.com%2Fclion%2F2017%2F12%2Fclion-for-embedded-development-part-ii%2F&#34; target=&#34;_blank&#34;&gt;CLion for Embedded Development Part II&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>stm clock</title><link>/hardware/stm32/stm-clock/</link><pubDate>Mon, 16 Mar 2020 11:29:02 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/stm-clock/</guid><description>&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/64348776&#34; target=&#34;_blank&#34;&gt;STM32单片机学习笔记 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、 AHB系统总线分为APB1（36MHz）和APB2（72MHz），其中2&amp;gt;1，意思是APB2接高速设备&lt;/p&gt;
&lt;p&gt;2、 Stm32f10x.h相当于reg52.h（里面有基本的位操作定义），另一个为stm32f10x_conf.h专门控制外围器件的配置，也就是开关头文件的作用&lt;/p&gt;
&lt;p&gt;3、 HSE Osc（High Speed External Oscillator）高速外部晶振，一般为8MHz，HSI RC（High Speed InternalRC）高速内部RC，8MHz&lt;/p&gt;
&lt;p&gt;4、 LSE Osc（Low Speed External Oscillator）低速外部晶振，一般为32.768KHz，LSI RC（Low Speed InternalRC）低速内部晶振，大概为40KHz左右，提供看门狗时钟和自动唤醒单元时钟源&lt;/p&gt;
&lt;p&gt;5、 SYSCLK时钟源有三个来源：HSI RC、HSE OSC、PLL&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-b3a3b3c247b1889748be98b24385cc49_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;6、 MCO[2：0]可以提供4源不同的时钟同步信号,PA8&lt;/p&gt;
&lt;p&gt;7、 GPIO口貌似有两个反向串联的二极管用作钳位二极管。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-c537c572e6749d68efcc7c732f76aa1a_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;8、 总线矩阵采用轮换算法对系统总线和DMA进行仲裁&lt;/p&gt;
&lt;p&gt;9、 ICode总线，DCode总线、系统总线、DMA总线、总线矩阵、AHB/APB桥&lt;/p&gt;
&lt;p&gt;10、在使用一个外设之前，必须设置寄存器RCC_AHBENR来打开该外设的时钟&lt;/p&gt;
&lt;p&gt;11、数据字节以小端存储形式保存在存储器中&lt;/p&gt;
&lt;p&gt;12、 内存映射区分为8个大块，每个块为512MB&lt;/p&gt;
&lt;p&gt;13、 FLASH的一页为1K(小容量和中容量)，大容量是2K。&lt;/p&gt;
&lt;p&gt;14、 系统存储区（SystemMemory）为ST公司出厂配置锁死，用户无法编辑，用于对FLASH区域进行重新编程。所以我们烧写程序务必选择BOOT1 = 0，这样通过内嵌的自举程序对FLASH进行烧写，比如中断向量表和代码&lt;/p&gt;
&lt;p&gt;15、 STM32核心电压为1.8V&lt;/p&gt;
&lt;p&gt;16、 STM32复位有三种：系统复位、上电复位、备份区域复位。其中系统复位除了RCC_CSR中的复位标志和BKP中的数值不复位之外，其他的所有寄存器全部复位。触发方式例如外部复位、看门狗复位、软件复位等；电源复位由于外部电源的上电/掉电复位或者待机模式返回。复位除了BKP中的寄存器值不动，其他全部复位；备份区域复位的触发源为软件复位或者VDD和VBAT全部掉电时。&lt;/p&gt;
&lt;p&gt;17、 单片机复位后所有I/O口均为浮空输入状态&lt;/p&gt;
&lt;p&gt;18、 68个可屏蔽中断通道，16个可编程优先级，16个内核中断，一共68+16=84个中断。103系列只有60个中断，107系列才有68个中断&lt;/p&gt;
&lt;p&gt;19、 系统启动从0x00000004开始，0x000 0000保留&lt;/p&gt;
&lt;p&gt;20、 （NestedVectored Interrupt Controller）NVIC嵌套向量中断控制器，分为两种：抢先式优先级（可嵌套）和中断优先级（副优先级，不能嵌套）。两种优先级由4位二进制位决定。分配下来有十六种情况：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-af732fbf76c317e8e7c63c76743b4aa9_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;21、0号抢先优先级的中断，可以打断任何中断抢先优先级为非0号的中断；1号抢先优先级的中断，可以打断任何中断抢先优先级为2、3、4号的中断；……；构成中断嵌套。如果两个中断的抢先优先级相同，谁先出现，就先响应谁，不构成嵌套。如果一起出现（或挂在那里等待），就看它们2个谁的子优先级高了，如果子优先级也相同，就看它们的中断向量位置了。原来中断向量的位置是最后的决定因素！！！！&lt;/p&gt;
&lt;p&gt;22、 上电初始化后AIRC初始化为0，为16个抢先式优先级，但是由于所有的外部通道中断优先级控制字PRI_n为0，所以抢先式优先级相同，此时就不能嵌套了&lt;/p&gt;
&lt;p&gt;23、 NVI中有ISER[2]（Interrupt Set-Enable Registers），ICER[2]（Interrupt Clear-Enable Registers），ISPR[2]（Interrupt Set-Pending Registers），ICPR[2]（Interrupt Clear-Pending Registers），IABR[2]（Active Bit Registers），IPR[15]（InterruptPriority Registers）定义。其中ISER和ICER分别为中断使能和中断失能寄存器，都是写1来使能/失能中断的。为什么写1？为什么不采用一个寄存器而用两个寄存器来表示中断使能/失能状态？由于硬件，写0比较复杂，并且可能造成其他位的状态改变，所以用1来表示打开或者关断是比较合理的&lt;/p&gt;
&lt;p&gt;24、 中断标志位需要手动清除&lt;/p&gt;
&lt;p&gt;25、 配置外围器件的一般步骤：1、打开端口时钟。2、定义初始化结构体并初始化。3、调用&lt;/p&gt;
&lt;p&gt;26、串口的奇偶校验：如果是奇偶校验，那么USART_InitStructure.USART_WordLength= USART_WordLength_9b;这个数据的长度必须设定为9位！&lt;/p&gt;
&lt;p&gt;27、ADC的规则组可以自定义转换通道顺序和转换的通道个数。在实际应用中，有时候希望有一些特别的通道具有很高的优先权，需要在规则组进行转换的时候强制打断，进行另一个通道的转换，这样一组通道，叫做注入组。&lt;/p&gt;
&lt;p&gt;28、定时器的输出比较模式：Timing（冻结，什么都不做，普通定时）,Active（OCxREF输出高电平有效）,Inactive（OCxREF输出低电平）,Toggle（比较成功后翻转电平）。&lt;/p&gt;
&lt;p&gt;29、STM32的定时器从0开始计数，满足一些条件，给出标志位（比如匹配成功、时间更新、溢出等）然后从0开始计数。这一点和51不同。&lt;/p&gt;
&lt;p&gt;30、OCx=OCxREF+极性&lt;/p&gt;
&lt;p&gt;31、自动装载寄存器和影子寄存器：前者相当于51当中的溢出设定数值。而影子寄存器顾名思义是影子，就是寄存器的另一分copy。实际起作用的是影子寄存器，而程序员操纵的则是自动装载寄存器。如果APPE位使能，表明自动装载寄存器的值在下一次更新事件发生后才写入新值。否则，写入自动装载寄存器的值会被立即更新到影子寄存器。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-76a7250ad614f49a77c7b6ea4c27c40e_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;32、RCC_PCLK1Config(RCC_HCLK_Div4);PCLK1的4分频给定时器基准时钟&lt;/p&gt;
&lt;p&gt;33、定时器配置：RCC、NVIC、GPIO（OC输出或者PWM）、TIMx&lt;/p&gt;
&lt;p&gt;34、通用定时器可以输出4路不同的PWM，高级定时器可以输出4路不同的PWM外，还可以输出3路互补的PWM信号（驱动三相电机），一共有7路。这样算出来STM32可以产生30路PWM=7*2+4*4&lt;/p&gt;
&lt;p&gt;35、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-e5517814a943f2c01c4df9e1f3f2fc8e_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;36、高级定时器时钟源挂在了APB2上，而通用定时器挂在APB1上。AHB（72mhz）→APB1分频器（默认2）→APB1时钟信号（36mhz）→倍频器（*2倍）→通用定时器时钟信号（72mhz）。如果APB1没有分频，那么通用定时器的时钟信号频率就直接等于APB1的时钟频率，没有上述的倍频器*2过程。TIM_SetAutoreload()用来改变PWM的频率,TIM_SetCompare1()用来改变占空比&lt;/p&gt;
&lt;p&gt;37、有刷电机一般启动力矩大一些，无刷电机启动力矩小，运行起来力矩大。有刷电机采用电刷机械电流换向，而无刷电机则通过霍尔传感器测出转子的电流来判断电机的运动位置和方向，返回给控制回路。&lt;/p&gt;
&lt;p&gt;38、死区是必须要有的，因为这涉及到电路的短路问题。晶闸管在换向的时候需要死区时间来彻底关断线路&lt;/p&gt;
&lt;p&gt;39、刹车功能用来在控制回路出现问题时，硬件自动给予外部电机进行紧急刹车制动，反应在PWM上持续给出一个固定的占空比？（三相驱动也是？）&lt;/p&gt;
&lt;p&gt;40、PWM输出最好采用PWM模式，其他的比较输出模式相位会慢慢改变，不精准&lt;/p&gt;
&lt;p&gt;41、对FLASH的读写需要先解锁后加锁。FLASH写0容易，写1难。&lt;/p&gt;
&lt;p&gt;42、下载程序有两种方式，一种为ICP（在线编程），适用于JTAG或SWD协议下的烧写程序。另一种成为IAP（在应用编程），适用于很多接口（USB，串口，CAN）下载到存储器中，IAP允许在程序运行时重新烧写FLASH&lt;/p&gt;
&lt;p&gt;43、FLASH分为主存储器（这里放置用户的程序代码）和信息块（启动代码），除此之外，还有一部分叫做系统存储器，这一块用户不可操作，为ST公司出产后固化，为系统的上电自举程序&lt;/p&gt;
&lt;p&gt;44、FLASH在写的时候，一定不能读，如果有读操作，那么将会锁住总线&lt;/p&gt;
&lt;p&gt;45、对FLASH操作时，必须打开HIS&lt;/p&gt;
&lt;p&gt;46、STM32有两种看门狗（IWDG独立看门狗《独立时钟》，WWDG窗口看门狗《由APB1分频而来》）&lt;/p&gt;
&lt;p&gt;47、SPI的的最高频率为36MHz(fpclk/2)&lt;/p&gt;
&lt;p&gt;48、 TIM1和TIM8高级定时器在输出PWM时，需要配置一下主输出功能（CtrlPWMOutputs）才能输出PWM。其他的通用定时器不需要这样配置。但是TIM6和TIM7没有PWM输出功能。&lt;/p&gt;
&lt;p&gt;49、Code为程序代码部分&lt;/p&gt;
&lt;p&gt;RO-data 表示程序定义的常量(如：const temp等);&lt;/p&gt;
&lt;p&gt;RW-data 表示已初始化的全局变量&lt;/p&gt;
&lt;p&gt;ZI-data 表示未初始化的全局变量,以及初始化为0的变量&lt;/p&gt;
&lt;p&gt;Code, RO-data,RW-data..............flash&lt;/p&gt;
&lt;p&gt;RW-data, ZIdata...................RAM&lt;/p&gt;
&lt;p&gt;初始化时RW-data从flash拷贝到RAM&lt;/p&gt;
&lt;p&gt;50、STM32F103ZET6有144个引脚（Z为144），其中，可用IO口为112个（7X16=112，ABCDEFG口）&lt;/p&gt;
&lt;p&gt;51、ARM公司只生产内核标准，不生产芯片。ST、TI这样的公司从ARM公司那里购买内核，然后外加自己的总线结构、外设、存储器、始终和复位、I/O后就组成了自己的芯片。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-9fdacdfce8f19f71e080529a8ce758e8_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;52、CMSIS标准用于在向上的用户层和下面的硬件层交换信息。这个架构当然可以自己定义，但是这样的话就会没有标准。所以强制使用CMSISI标准来设计芯片。通俗点的讲就是系统初始化的函数名称CMSIS定义为SystemInit()，GPIO_ResetBits()等&lt;/p&gt;
&lt;p&gt;53、端口复用和端口重映射是两个概念：前者在使能其对应的端口和对应的功能时钟即可。后者需要打开AFIO时钟，然后进行端口的重映射GPIO_PinRemapConfig()&lt;/p&gt;
&lt;p&gt;54、下载程序只能使用串口1，在硬件设计时一定要注意！&lt;/p&gt;
&lt;p&gt;55、J-TAG调试频率一般设定为2MHz，而SWD调试频率可以设定为10MHz&lt;/p&gt;
&lt;p&gt;56、SysTick的中断实现可以有两种方式：循环等待和中断法。推荐用循环等待，中断法可能会出问题而且占用资源。&lt;/p&gt;
&lt;p&gt;57、部分I/O引脚是5V兼容的。单个I/O的最大驱动电流和灌入电流均为25mA。整个芯片的电流为150mA&lt;/p&gt;
&lt;p&gt;58、KEIL支持位段操作，可以利用C语言中的位段知识定义位段结构体，然后对单独的寄存器进行单独的位操作。&lt;/p&gt;
&lt;p&gt;59、关于内部上下拉电阻的设置：如果外部的按键另一头接地，那么需要设置成上拉电阻。（理由是当没有按下按键时，由于上拉，输入为高电平；按下时，由于外部接地，输入为低电平。）同理，如果外部的按键另一头接高电平，那么需要设置成下拉电阻。&lt;/p&gt;
&lt;p&gt;60、串口中断TXE和TC的区别：其实很明显，一个是发送寄存器空标志，一个是发送完成标志。因为串口在发送的时候首先需要把发送寄存器中的数据移位到移位寄存器（影子寄存器）后再串行发送出去。所以当发送寄存器DR空时说明现在可能正在往外面发送数据，数据可能还没有发送完。但是发送完成不一样，他是在移位寄存器将本次数据全部移位完成后设置的标志位（也就是发送完了停止位）。这么看来：TXE允许程序有更充裕的时间填写TDR寄存器，保证发送的数据流不间断。TC可以让程序知道发送结束的确切时间，有利于程序控制外部数据流的时序。&lt;/p&gt;
&lt;p&gt;61、窗口看门狗顾名思义有一个窗口，这个窗口的横坐标为时间，意思是在指定的时间范围内刷新寄存器，否则单片机复位。窗口的上限由人来设定W[6:0]，下线定死为0x40Twwdg=(4096×2^WDGTB×(T[5:0]+1)) /Fpclk1；Twwdg为超时时间ms，Fpclk1为APB1时钟KHz，&lt;/p&gt;
&lt;p&gt;62、TIMx通用定时器有4个独立通道，分别可以用来作为：输入捕获、比较输出、PWM生成、单脉冲模式输出。&lt;/p&gt;
&lt;p&gt;63、定时器的时钟来源有4个：内部时钟（CK_INT），外部时钟模式1（TIx），外部时钟模式2（ETR），内部触发模式（ITRx，这个用来定时器的同步）&lt;/p&gt;
&lt;p&gt;64、定时器中断溢出更新时间：Tout=((arr+1)*(psc+1))/Tclk，ARR为自动装载寄存器（1~65535）、PSC为分频系数，TCLK为输入时钟频率（Mhz）&lt;/p&gt;
&lt;p&gt;65、PWM1和PWM2模式的区别仅在于相位的180度。前者高电平时，后者低电平。感觉好鸡肋，OCxREF极性就可以实现这个功能。。&lt;/p&gt;
&lt;p&gt;66、定时器输入捕捉有一个滤波器，顾名思义滤波器起到的就是滤波的作用，在捕捉外部信号时，信号可能不稳定，此时需要滤波：当检测到有外部输入时，需要再连续采样N次如果确定为高电平/低电平，则触发响应中断（如果开启了的话）。&lt;/p&gt;
&lt;p&gt;67、电容触摸屏原理：通过充放电的曲线不同来检测是否被按下。 实际的实验过程中，TPAD可以用一块覆铜区域来替代，通过电容的充放电常数来确定是否按下。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-6eb5a1150ecd9e8dd6e5183b31dc2e9a_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;68、OLED，即有机发光二极管（OrganicLight-Emitting Diode），又称为有机电激光显示（Organic Electroluminesence Display，OELD）。下图为OLED的GRAM与屏幕的对应表&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic4.zhimg.com/80/v2-7373ce71e7f0ffce590ac99409dee41f_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;PAGE2单独列出来：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;69、USART可以操纵SPI设备。不过最大频率只有4.5MHz&lt;/p&gt;
&lt;p&gt;70、使用I/O口时应该注意的问题&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;71、ADC的Vref+和Vdda与VSS，Vref-一定要加高质量的滤波电容，切靠近单片机。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;72、ADC分为规则组和注入组，前者有16个通道，后者有4个通道。并且16个通道公用一个数值寄存器，注入组的4个通道分别有一个数值寄存器。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-66bc2ba7ee0e32743e42abc02941cae1_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;73、采样频率越高，输入阻抗要求越小。&lt;/p&gt;
&lt;p&gt;74、Stm32进入中断的最短周期为6个周期&lt;/p&gt;
&lt;p&gt;75、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-0229e7fa6a12ca20f1b187d487c87cde_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;76、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic4.zhimg.com/80/v2-412fc60a9ca948a0a149ecf854da8b03_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;77、FSMC，即灵活的静态存储控制器。能够与同步或异步存储器和16位PC存储器卡接口，STM32的FSMC接口支持包括SRAM、NANDFLASH、NORFLASH和PSRAM等存储器。&lt;/p&gt;
&lt;p&gt;78、平时所说的U盘里的FLASH存储器有两种类型：NANDflash和NOR flash。&lt;/p&gt;
&lt;p&gt;NAND FLASH&lt;/p&gt;
&lt;p&gt;NOR FLASH&lt;/p&gt;
&lt;p&gt;不能直接运行里面的代码&lt;/p&gt;
&lt;p&gt;可以直接运行里面的代码&lt;/p&gt;
&lt;p&gt;写入和擦除速度快&lt;/p&gt;
&lt;p&gt;写入和擦除速度慢&lt;/p&gt;
&lt;p&gt;读取速度稍慢&lt;/p&gt;
&lt;p&gt;读取速度稍快&lt;/p&gt;
&lt;p&gt;擦写周期100万次&lt;/p&gt;
&lt;p&gt;擦写周期10万次&lt;/p&gt;
&lt;p&gt;成本低，容量高&lt;/p&gt;
&lt;p&gt;成本高，容量低&lt;/p&gt;
&lt;p&gt;一般为串行接口&lt;/p&gt;
&lt;p&gt;有SRAM接口&lt;/p&gt;
&lt;p&gt;79、TFT在操作时，可以当作外部SRAM来操作，这样的话，如果单片机有FSMC接口，就可以使用NORFLASH的SRAM接口去控制，速度非常快。&lt;/p&gt;
&lt;p&gt;80、Stm32的的FSMC有4个256MB的存储块，一共寻址1GB的外部存储器空间。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;81、在STM32内部，FSMC的一端通过内部高速总线AHB连接到内核Cortex－M3，另一端则是面向扩展存储器的外部总线。内核对外部存储器的访问信号发送到AHB总线后，经过FSMC转换为符合外部存储器通信规约的信号，送到外部存储器的相应引脚，实现内核与外部存储器之间的数据交互。&lt;/p&gt;
&lt;p&gt;82、FSMC中的DATASET和ADDSET的设置需要参看外部存储器的时序图来确定。一般而言，DATASET指的是数据建立时间，也就是读/写信号开始到读/写信号停止（上升沿存储数据）的持续时间。（一般来说写比读快！）。而ADDSET指的是地址建立时间，指的是片选之后到读/写操作之前的时间，这是针对SRAM来说的，如果操纵的是TFT，不存在地址线，所以此时的ADDSET就是读/写信号结束到RS电平的转换时间。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-4892c8ba0c437b1aed679c601bdb369a_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;83、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-ee8cdab597a5a93df7ca8200466e087c_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;84、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;85、FSMC的三个配置寄存器：FSMC_BCRx(片选控制配置)、FSMC_BTRx(片选时序)、FSMC_BWTRx(片选写时序)。&lt;/p&gt;
&lt;p&gt;86、 RTC时钟配置必须要用到BKP寄存器，BKP寄存器在单片机复位、电源复位、待机唤醒模式下是不会更改值的，他的供电由VDD供电，VDD被切断后自动切换至外部的VBAT供电。&lt;/p&gt;
&lt;p&gt;87、 要修改BKP寄存器的值，必须取消其写保护的标志。BKP寄存器在上电时自动写保护。&lt;/p&gt;
&lt;p&gt;88、 Stm32有三种省电模式：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;三种省电模式中，耗电量从上到下依次降低，待机模式的电流仅为2uA。&lt;/p&gt;
&lt;p&gt;89、 从待机模式中唤醒单片机等效于让单片机复位，但是电源寄存器的值会有一个标志位指示单片机是被唤醒的，不是被复位的。&lt;/p&gt;
&lt;p&gt;90、 ADC的时钟不要超过14MHz，否则转换精度会下降。最大转换速率为1MHz，即转换周期为1us(14MHz,采样周期为1.5个ADC时钟)&lt;/p&gt;
&lt;p&gt;91、 Tcovn=采样时间+12.5个周期。采样时间尽量选长一点，这样精度高一些，但是转换速率下降，这也是有利必有弊。&lt;/p&gt;
&lt;p&gt;92、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-c5d6734a0cd659c10e37d188a5b579ee_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;93、 拿ARM7TDMI来说，T代表Thumb指令集，D是说支持JTAG调试(Debugging)，M意指快速乘法器，I则对应一个嵌入式ICE模块。&lt;/p&gt;
&lt;p&gt;94、 MMU作为嵌入式处理器与应用处理器的分水岭标志à具有内存管理单元的嵌入式处理器可以定位为应用处理器。这么说M系列和A系列的处理器的区别在于A系列的处理器具有MMU单元可以进行内存模块的管理。&lt;/p&gt;
&lt;p&gt;95、ARM处理器有两种状态：ARM状态和Thumb状态。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic4.zhimg.com/80/v2-977b46d5ef31bbfe3226ab13c6540e2b_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;96、 这张图说明了一切：Thumb2指令集做了一件很伟大的事情：将16位和32位的指令集融为一体，兼容性非常强！（这么说CM3不支持某些32位ARM指令集？？）&lt;/p&gt;
&lt;p&gt;97、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-d7a0a30a6547effaf4e0b5cf1c36d686_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;98、MSP是系统复位后使用的堆栈指针，PSP由用户的代码使用。两个堆栈指针为4字节对齐！！&lt;/p&gt;
&lt;p&gt;99、在ARM编程领域中，凡是打断程序运行的事件，统称为异常(exception)。&lt;/p&gt;
&lt;p&gt;100、 因为存在LR（链接寄存器），所以可支持1级的子程序调用而不用压栈到内存，大大提高了运行速度。---à这就是说，我们在编程的时候，一级调用是不会耗费太多时间的，除非是二级调用！&lt;/p&gt;
&lt;p&gt;101、 处理器有两种操作模式：handler模式和线程模式。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;处理器也有两种特权分级：特权级和用户级。 这张图说明了一切：复位进入特权级线程模式，如果有异常，进入特权级的handler模式处理异常或中断例程，然后返回至特权级线程模式。通过修改CONTROL寄存器可以进入用户级线程模式。&lt;/p&gt;
&lt;p&gt;102、 两个高级定时器TIM1和TIM8是挂接在APB1总线上&lt;/p&gt;
&lt;p&gt;103、 STM32的外部中断是以组来区分的，也就是说PA0,PB0,PC0单片机是无法区分其中哪个触发的中断à均为EXIT0线中断服务例程。所以，外部中断支持16路的中断分辨率。从另一个方面来讲，我们可以设置GPIO_EXTILineConfig(GPIO_PortSourceGPIOx, GPIO_PinSourcex);来开通中断线实现组内的不同中断。&lt;/p&gt;
&lt;p&gt;104、 DAC有两个寄存器，一个是DHR（Data HoldingRegister）数据保持寄存器，一个DOR（Data Output Register）数据输出寄存器。真正起作用的是DOR寄存器，该寄存器把值给数模转换发生单元输出以VREF+为参考电压的电压值。如果是硬件触发转换，系统将在1个ABP时钟周期后把值给DOR，如果是软件触发转换，时间为3个APB时钟周期。然后，均等待Tsetting时间（Typical为3us,Max为4us）后真正输出电压值。&lt;/p&gt;
&lt;p&gt;105、 DAC分8位模式和12位模式，其中后者可以选择左右对齐&lt;/p&gt;
&lt;p&gt;106、 DMA仲裁器分为软件和硬件两种。软件部分分为4个等级，分别是很高优先级、高优先级、中等、低。硬件部分由通道的大小来决定优先级，越低优先级越高。&lt;/p&gt;
&lt;p&gt;107、 DMA有一个实时的传输数据量寄存器叫做DMA_CNDTR，最大值为65535，存放的是当前传输所要传输的数据量。当数据量变为0时，表明传输完成。&lt;/p&gt;
&lt;p&gt;108、 CAN总线（ControllerArea Network）。CAN控制器根据两根线上的电位差来判断总线电平，总线电平又分为显性电平和隐性电平，二者必居其一。&lt;/p&gt;
&lt;p&gt;109、 CAN总线具有6个特点：1：多主控制（挂接在总线上的所有设备均可以成为主设备，并且设备ID是用来决定设备的优先级，没有设备地址概念），2：系统若软性（没有设备地址概念），3、通讯速度较快，通讯距离较远（1Mbps下40M，5kbps下10KM），4、具有错误检测、错误通知（通知其他设备）和错误恢复功能（强制结束发送，重复发送接收错误的信息。），5、故障封闭，当总线上的设备发生连续故障错误时，CAN控制器会把改控制器踢出总线。6、连接节点多。理论上可以无限制加载，但是受到时间延迟和电气负载的限制，实际数目是有限制的。降低传输速度可以适当增加可挂接负载个数。&lt;/p&gt;
&lt;p&gt;110、 CAN协议有两个标准，ISO11898(针对125kbps~1Mbps的高速速率)和ISO11519-2(125kbps以下的低速速率)&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-a37f1102784b96a2e0fc6b5774ece788_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;111、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-f043ae12a4e948cd3423e215471d6356_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;112、 CAN协议的有5种类型的帧：数据帧、遥控帧、错误帧、过载帧、帧间隔。其中前两种帧有标准格式（11位ID）和扩展格式（29位ID）。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-3c40829a650f96ab57be6975d78f8601_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;113、 数据帧构成：&lt;/p&gt;
&lt;p&gt;（1） 帧起始。 表示数据开的段帧起始。&lt;/p&gt;
&lt;p&gt;（2） 仲裁段。 表示该帧优先级的仲裁段。&lt;/p&gt;
&lt;p&gt;（3） 控制段。 表示数据的字节及保留位段。&lt;/p&gt;
&lt;p&gt;（4） 数据段。 数据的内容，一帧可发送0~8个字节的数据。&lt;/p&gt;
&lt;p&gt;（5） CRC段。 检查帧的传输错误段。&lt;/p&gt;
&lt;p&gt;（6） ACK段。 表示确认正常接收的段。&lt;/p&gt;
&lt;p&gt;（7） 帧结束。 表示数据的段帧结束。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-73a99b820978249156880b9d09a6652a_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;114、 Stm32f103系列只有一个CAN控制器，有3个发送邮箱和3级深度的2个FIFO，14个过滤组器。&lt;/p&gt;
&lt;p&gt;115、 STM32的每个过滤组可以配置为1个32位过滤器和2个16位过滤器。除此之外，还可以配置为屏蔽位模式（ID+屏蔽）和标识符列表（ID和屏蔽寄存器均用来做ID寄存器）模式。&lt;/p&gt;
&lt;p&gt;116、 CAN接收到有效报文被放置在3级邮箱深度的FIFO中，FIFO完全由硬件来管理。&lt;/p&gt;
&lt;p&gt;117、 CAN总线的波特率&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-6f8dd4c8a3056faf7674c05212e942f4_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;118、 触摸屏一般分为电阻式触摸屏和电容式触摸屏。前者检测触摸的位置原理是利用触摸屏控制器中的A/D转换器经过两次A/D读值后得出X和Y的坐标值。注意：这个X和Y的值是相对于触摸屏的，而非LCD屏。所以在这里需要注意两个概念：触摸屏和LCD屏。这是两个不同的概念，也是两个不同的物理结构，其中电阻触摸屏是由上下两个导电层中间夹着一层非常薄的透明隔层；而LCD就是指显示屏。&lt;/p&gt;
&lt;p&gt;119、 电阻触摸屏有X和Y、X和Y的比例因子、坐标轴方向、偏移量。LCD也有自己的这些参数。两者完全不相干，所以在定位的时候需要进行坐标转换。公式：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-1024a10d2d975a09e440c858f9a11566_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;，通过对屏幕的四个点进行校准，得到四元一次方程，求解即可。&lt;/p&gt;
&lt;p&gt;120、 NEC协议的数据帧格式：同步码头、地址码、地址反码、控制码、控制反码。同步码由一个9ms的低电平和一个4.5ms的高电平组成，地址码、地址反码、控制码、控制反码均是8位数据格式。按照低位在前，高位在后的顺序发送。&lt;/p&gt;
&lt;p&gt;121、 NEC协议在发送的时候，会有560us的38KHz的载波信号，而在接收的时候这部分载波信号被认定为低电平，而剩余的（2.25ms-650us）的逻辑“1”和（1.12ms-650us）的逻辑“0”时间则被认定为高电平。&lt;/p&gt;
&lt;p&gt;122、 在单位时间内的位移被定义为速度，速度有线速度和角速度之分，分别对应两种传感器测量这两种不同的速度：线速度传感器（加速度计）、角速度传感器（陀螺仪）。前者多应用在静态或者低慢速运动中的姿态求解，后者多应用在动态运动中姿态求解。&lt;/p&gt;
&lt;p&gt;123、 根据标准约定，零加速度（或零 G 准位）通常定义为相当于最大输出值（12 位输出为 4096，10 位输出为 1024 等）一半的输出。对于提供 12 位输出的加速度计，零 G 准位将等于 2048。输出大于 2048 表示正加速度。输出小于 2048 表示负加速度。加速度的数量通常用单位 g (1g = 9.8m/s2 = 重力加速度）表示。通过确定测量的输出与零 G 准位之间的差值，然后除以加速度计的灵敏度（用计数/g 或 LSB/g表示）来计算加速度。对于提供 12 位数字输出的 2g 加速度计，灵敏度为 819 计数/g 或 819 LSB/g。加速度等于：a = (Aout - 2048)/(819 计数/g)，单位为 g。&lt;/p&gt;
&lt;p&gt;124、 加速度计测得的加速度的方向和设备设定的坐标系是相反的，因为原理表明在测量力的时候采用的是非惯性系参考系，而我们高中时代研究的坐标系是惯性系参考系，前者在物体进行运动产生加速度时，假想一个与速度方向相反的力作用在物体上，这个力就是惯性力；后者我们说不存在惯性力，只说存在惯性，因为在惯性坐标系中，我们研究的是物体，而非坐标系（即假定坐标系相对地球静止），当我们把坐标系也考虑在内时，当坐标系运动，就产生了惯性力f，这种力作用会假想作用在物体上，只是与运动方向相反。&lt;/p&gt;
&lt;p&gt;125、 由上可知，加速度计的本质是测量力而非加速度。&lt;/p&gt;
&lt;p&gt;126、 NRF24L01工作在2.4GHz的频段，由于频段频率较高，所以传输速率较快，为2Mbps&lt;/p&gt;
&lt;p&gt;127、 STM32的闪存模块由：主存储器、信息块和闪存存储器接口寄存器3个部分构成。主存储器用来存放代码和const常量；信息块由两个部分组成：启动程序代码、用户选择字节。其中启动程序代码为ST公司自带的启动程序，用于串口下载。最后的闪存存储器接口寄存器用于控制整个对闪存区域的操作。&lt;/p&gt;
&lt;p&gt;128、 CPU的运行速度比FLASH的操作速度快的多，一般FLASH的最快访问速度≤24Mhz。如果CPU的速度超过这个频率，那么在读取FLASH的时候必须加入等待时间（FLASH_ACR设置）&lt;/p&gt;
&lt;p&gt;129、 FLASH编程时，写入必须为半字（16位）。并且在写入的时候必须保证所写区域的数据必须为0xFFFF。&lt;/p&gt;
&lt;p&gt;130、 STM32的FSMC有HADDR[27:0]，其中[27:26]用来选择BANK区域的4个不同块。剩下的[25:0]则用来连接外部存储区域的地址线FSMC_A[25:0]。如果数据宽度是8bit，此时的HADDR[25:0]和FSMC_A[25:0]是完全对应的。如果数据宽度是16bit，此时的HADDR[25:1]和FSMC_A[24:0]是对应起来的。需要注意：无论数据宽度是多少，外部的FSMC_A[0]和A[0]总是对应的。&lt;/p&gt;
&lt;p&gt;131、 关于LB和UB的信号控制是由硬件自动控制的，当AHB的数据宽度小于外部存储器的数据宽度时，此时LB和UB的控制信号自动产生（比如字节读取/写入16bit的外部存储器）&lt;/p&gt;
&lt;p&gt;132、 &lt;strong&gt;attribute&lt;/strong&gt; (函数属性、变量属性、类型属性等)。如果在使用SRAM时，可以采用u32 sram_array[xx] &lt;strong&gt;attribute&lt;/strong&gt; ((at(0x68000000))代表将外部SRAM的空间全部给了sram_array这个变量，他具有在at0x68000000这个地址的属性。往里面写值就直接在SRAM里面写值。&lt;/p&gt;
&lt;p&gt;133、&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-f0117e4e3041e581b136ec958198db5a_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;内存管理有一种方式叫做分块式内存管理。&lt;/p&gt;
&lt;p&gt;注意表中的分配方向，从顶到底。每一项对应一个内存块。里面的数值代表了内存池的状态：如果为0，表示该内存没有被分配；如果非0，那么数值的大小就表示了该块内存被连续占用的内存数。比如说数值为20，意思是包括该项在内的内存块被连续占用了20块分给了指针。&lt;/p&gt;
&lt;p&gt;134、SD卡的分类：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-8731743fcbce06b0ff74d6bcca397cb1_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;一般的SD卡支持两种传输模式：SD卡模式（SDIO）、SPI模式。显然前面一种是专用模式，所以速度比较快。&lt;/p&gt;
&lt;p&gt;135、 常用的汉字内码系统有GB2313、GB13000、GBK、BIG5(繁体)。其中GB2313只有几千个汉字，而GBK则有2万多汉字。&lt;/p&gt;
&lt;p&gt;136、 要显示汉字，采用的方式如果用点阵的形式是不可取的，因为这无法查找汉字。采用的方式就是内码系统。GBK标准中，一个汉字对应2个字节：前者称为区(0x81~0xFE)后者为(0x40~0x7E)和(0x80~0xFE)。前者有126个区，后者有190，那么可以显示的汉字数量有126*190=23940个。根据这两个值用来查找字库，字库中存放的还是每个汉字的点阵数据。这个字库非常大，如果是16*16的字体，那么一个字体就需要32个字节，如此说来需要23940*32=748K的空间，可见非常大，所以需要外部的Flash来存储这个字库。&lt;/p&gt;
&lt;p&gt;137、 由于汉字内码系统不具有国际通用性，但是Unicode几乎把所有的语言都放置进来，这样在单片机中操作汉字时，就需要将GBK和Unicode转化。尤其是在FATFS中，创建中文文件名和读取中文文件信息时需要将Unicode换转为GBK后再进行修改操作，再反转换成Unicode保存修改。这么说，两者的存在是由于标准的不统一，并且Unicode中只有6064个汉字，而GBK显然是一种汉字扩展。&lt;/p&gt;
&lt;p&gt;138、 BMP图片编码的顺序是从左到右，从下到上。&lt;/p&gt;
&lt;p&gt;139、 VS1053是一款高性能的数字音频解码芯片，从SD卡中将mp3等音乐音频文件通过SPI送给VS1053后，由其进行音频解码，输出音乐给耳机。耳机驱动可以采用TDA1308芯片，这款芯片为AB类耳机驱动芯片。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic3.zhimg.com/80/v2-f83f8ee048e6402566d97d0d84cdb446_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;140、&lt;/p&gt;
&lt;p&gt;141、 IAP(In Application Programming)在应用编程是为了后期开发更新程序方便而提出的概念。具体的实现方法如下图所示：&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-f83e224622f350454547f81784ab9a38_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;在普通编程中，flash中的code是通过JTAG和ISP等工具下载到单片机中。而在IAP编程中，flash被分区为A和B两个区域，A区域只允许用USB/USART等方式下载，此区域作为更新B区域的代码用。B区域则是用户的code区域，真正的代码在这里被执行，放置的就是app。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic1.zhimg.com/80/v2-542847378e84948c3c5bd69980db6860_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;上图表示STM32正常运行的流程图，可以看到上电复位后系统从0x80000004处开始运行程序，这里放置的是复位中断向量，然后跳转至复位中断程序入口后再跳转至main函数运行用户的程序。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic2.zhimg.com/80/v2-9dee7229881768ec0dfcc34a2c9cac69_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;上图表示加入IAP后的STM32程序运行流程图。可以看到上电复位后跳到IAP程序的main函数处运行IAP过程（这个过程就是把下面灰底色块的程序代码烧进B区域à代码更新）。后面的过程和STM32正常运行一样，如果出现中断请求，还是跳转到A区域中的中断向量表中，然后再跳转到B区域的中断服务入口。&lt;/p&gt;
&lt;p&gt;142、 USB有四根线，VCC、GND、D+、D-。在USB主机上，D+和D-均通过一个15K的电阻接地，这样两条线均为低电平。在USB设备中，对于高速设备会在D+通过一个1.5K的电阻接到VCC，而低俗设备会在D-通过一个1.5K的电阻接到VCC。这样主机就可以通过D+和D-的高电平的到来来检测是否有设备接入，并且识别高低速设备。&lt;/p&gt;
&lt;p&gt;143、 UCOSII是一种实时操作系统，具有执行效率高、占有空间小（最小内核2KB）、实施性能优良、扩展性强和移植性强等优点。&lt;/p&gt;
&lt;figure data-size=&#34;normal&#34;&gt;![](https://pic4.zhimg.com/80/v2-4dc223f38c4493934d6640958bdafc63_1440w.jpg)&lt;/figure&gt;
&lt;p&gt;UCOS具有多任务并发工作的特点（注意，任何时候只有一个任务能够占用CPU。并发只是任务轮流占用CPU而不是同时工作）。最大支持255个任务并发工作&lt;/p&gt;</description></item><item><title>go os exist</title><link>/language/golang/go-os-exist/</link><pubDate>Fri, 13 Mar 2020 10:23:14 CST</pubDate><author>rinetd</author><guid>/language/golang/go-os-exist/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 判断所给路径文件/文件夹是否存在
func Exists(path string) bool {
_, err := os.Stat(path) //os.Stat获取文件信息
if err != nil {
if os.IsExist(err) {
return true
}
return false
}
return true
}
// 判断所给路径是否为文件夹
func IsDir(path string) bool {
s, err := os.Stat(path)
if err != nil {
return false
}
return s.IsDir()
}
// 判断所给路径是否为文件
func IsFile(path string) bool {
return !IsDir(path)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「思维的深度」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/skh2015java/article/details/78806486&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/skh2015java/article/details/78806486&lt;/a&gt;&lt;/p&gt;</description></item><item><title>linux udev disk_hotplug</title><link>/linux/linux-udev-disk_hotplug/</link><pubDate>Thu, 12 Mar 2020 10:24:32 CST</pubDate><author>rinetd</author><guid>/linux/linux-udev-disk_hotplug/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh
################### SCSI disk #################################################
#DEVTYPE=partition
#DEVPATH=/devices/platform/ahci.0/ata1/host0/target0:0:0/0:0:0:0/block/sdb/sdb2
#SUBSYSTEM=block
#SEQNUM=800
#UDEVD_EVENT=1
#ACTION=remove
#DEVNAME=/dev/sdb1
#DEVTYPE=partition
#DEVPATH=/devices/platform/ahci.0/ata1/host0/target0:0:0/0:0:0:0/block/sdb/sdb1
#SUBSYSTEM=block
#SEQNUM=801
#UDEVD_EVENT=1
#ACTION=remove
#DEVNAME=/dev/sdb
#DEVTYPE=disk
#DEVPATH=/devices/platform/ahci.0/ata1/host0/target0:0:0/0:0:0:0/block/sdb
#SUBSYSTEM=block
#SEQNUM=803
#UDEVD_EVENT=1
################### USB disk #################################################
#
# Block device event:
#
# ACTION=add
# DEVNAME=/dev/sda
# DEVTYPE=disk
# DEVPATH=/devices/platform/hiusb-ehci.0/usb1/1-2/1-2.1/1-2.1:1.0/host8/target8:0:0/8:0:0:0/block/sda
# SUBSYSTEM=block
# SEQNUM=544
# UDEVD_EVENT=1
#
# ACTION=add
# DEVNAME=/dev/sda1
# DEVTYPE=partition
# DEVPATH=/devices/platform/hiusb-ehci.0/usb1/1-2/1-2.1/1-2.1:1.0/host8/target8:0:0/8:0:0:0/block/sda/sda1
# SUBSYSTEM=block
# SEQNUM=545
# UDEVD_EVENT=1
#
# Use command &amp;quot;hdparm -z /dev/sda&amp;quot; to reread partition table
#
################################################################################
PREFIX=udisk
CONSOLE=/dev/ttyS000
################################################################################
show_env ()
{
local RED=&amp;quot;\033[31m&amp;quot;
local NORMAL=&amp;quot;\033[00m&amp;quot;
{
echo -e ${RED}&amp;quot;ACTION=$ACTION&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;DEVNAME=$DEVNAME&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;DEVTYPE=$DEVTYPE&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;DEVPATH=$DEVPATH&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;SUBSYSTEM=$SUBSYSTEM&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;SEQNUM=$SEQNUM&amp;quot; ${NORMAL}
echo -e ${RED}&amp;quot;UDEVD_EVENT=$UDEVD_EVENT&amp;quot; ${NORMAL}
} &amp;gt; ${CONSOLE}
}
################################################################################
# new_name orgin_name
add_disk ()
{
local NEW_NAME=$1
local ORG_NAME=$2
if [ -e ${ORG_NAME} ]; then
cd /dev/; ln -sf ${ORG_NAME} ${NEW_NAME}; cd -
echo &amp;quot;${NEW_NAME} -&amp;gt; ${ORG_NAME}&amp;quot; &amp;gt; ${CONSOLE}
fi
}
################################################################################
# new_name
remove_disk ()
{
local NEW_NAME=$1
if [ -L /dev/${NEW_NAME} ]; then
rm -f /dev/${NEW_NAME}
fi
}
################################################################################
hotplug_usb ()
{
if [ ss&amp;quot;${SUBSYSTEM}&amp;quot; != ss&amp;quot;block&amp;quot; ]; then
return 1
fi
if [ ss&amp;quot;$(echo ${DEVPATH} | grep -r &amp;quot;usb&amp;quot;)&amp;quot; = ss&amp;quot;&amp;quot; ]; then
return 1
fi
local TMP=$(echo ${DEVPATH:36} | sed -e &#39;s/\/host.*//&#39;)
local NEW_NAME=${PREFIX}$(echo ${TMP##*/} | sed -e &#39;s/[-.:]//g&#39;)
local PART_INDEX=`echo $DEVNAME | sed -e &#39;s/\/dev\/sd.//&#39;`
test -z &amp;quot;${PART_INDEX}&amp;quot; || NEW_NAME=${NEW_NAME}p${PART_INDEX}
case &amp;quot;${ACTION}&amp;quot; in
&amp;quot;add&amp;quot; )
add_disk &amp;quot;${NEW_NAME}&amp;quot; &amp;quot;${DEVNAME}&amp;quot;
;;
&amp;quot;remove&amp;quot; )
remove_disk &amp;quot;${NEW_NAME}&amp;quot;
;;
* )
echo &amp;quot;ACTION:${ACTION}&amp;quot; &amp;gt; ${CONSOLE}
;;
esac
return 0
}
hotplug_sata ()
{
if [ ss&amp;quot;${SUBSYSTEM}&amp;quot; != ss&amp;quot;block&amp;quot; ]; then
return 1
fi
if [ ss&amp;quot;$(echo ${DEVPATH} | grep -r &amp;quot;ata&amp;quot;)&amp;quot; = ss&amp;quot;&amp;quot; ]; then
return 1
fi
local TMP=$(echo ${TMP} | sed -e &#39;s/\/block.*//g&#39;)
TMP=$(echo ${TMP} | sed -e &#39;s/\/devices.*\///g&#39;)
local NEW_NAME=${PREFIX}$(echo ${TMP} | sed -e &#39;s/[:]//g&#39;)
local PART_INDEX=`echo $DEVNAME | sed -e &#39;s/\/dev\/sd.//&#39;`
test -z &amp;quot;${PART_INDEX}&amp;quot; || NEW_NAME=${NEW_NAME}p${PART_INDEX}
case &amp;quot;${ACTION}&amp;quot; in
&amp;quot;add&amp;quot; )
add_disk &amp;quot;${NEW_NAME}&amp;quot; &amp;quot;${DEVNAME}&amp;quot;
;;
&amp;quot;remove&amp;quot; )
remove_disk &amp;quot;${NEW_NAME}&amp;quot;
;;
* )
echo &amp;quot;ACTION:${ACTION}&amp;quot; &amp;gt; ${CONSOLE}
;;
esac
return 0
}
################################################################################
#show_env
hotplug_usb
hotplug_sata
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>hi3516 QA</title><link>/hardware/hisilicon/hi3516-qa/</link><pubDate>Tue, 10 Mar 2020 20:08:54 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3516-qa/</guid><description>
&lt;h4 id=&#34;hi3516-运动帧-md-检测录制的视频播放快进&#34;&gt;[hi3516] 运动帧（MD）检测录制的视频播放快进？&lt;/h4&gt;
&lt;p&gt;出现这种情况是因为帧率达不到25帧，因为播放器是按25帧进行播放的。&lt;/p&gt;
&lt;p&gt;原本调试好运动帧检测的demo，sample_ive_main.c里面的SAMPLE_IVE_Md()，把里面的输出到VO的通道换成VENC保存到文件，即SAMPLE_COMM_VENC_StartGetStream（），但是录制的文件播放的时候居然是以快进的方式播放的。&lt;br /&gt;
请问有谁知道哪里的参数设置会导致录制的视频播放是快进的形式？&lt;br /&gt;
而且利用ffmepg播放会报错是 deprecated pixel format used, make sure you did set range correctly？&lt;/p&gt;
&lt;p&gt;目前找到的两处会影响的地方； 一个是VB模块，如果VB的 stVbConf.astCommPool[i].u32BlkCnt 设置小了就会导致快进的情况，因为我的内存不足，只分配了1或者2，所以导致快进，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 另外一个是 VI_CHN_ATTR_S 的s32SrcFrameRate和 s32DstFrameRate，这两个sample里面设置成3和1，进行了帧率控制，也会导致快进；
再问一个问题就是 aenSize[1] = PIC_D1 如果改成PIC_HD1080就没有检测效果，有谁知道为什么吗
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己回复一下自己，播放加速主要是因为我的sensor获取1080P的只有20帧，写入文件是并没有时间戳，所以导致播放时会按照正常的25帧来播放，从而导致加速&lt;/p&gt;</description></item><item><title>hi3518e usb wifi</title><link>/hardware/hisilicon/cross_compile/hi3518e-usb-wifi/</link><pubDate>Thu, 05 Mar 2020 10:58:45 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/cross_compile/hi3518e-usb-wifi/</guid><description>
&lt;h4 id=&#34;板子启动后建立ap热点命令&#34;&gt;板子启动后建立ap热点命令：&lt;/h4&gt;
&lt;p&gt;ifconfig wlan0 up&lt;br /&gt;
hostapd /etc/hostapd.conf -B&lt;br /&gt;
ifconfig wlan0 192.168.2.1&lt;br /&gt;
udhcpd -fS /etc/udhcpd.conf &amp;amp;&lt;br /&gt;
默认的热点名字和密码配置文件在/etc/hostapd.conf 文件里面&lt;br /&gt;
默认的热点名字：qddytt&lt;br /&gt;
密码：qddytt11&lt;/p&gt;
&lt;h3 id=&#34;板子连接到无线路由器命令&#34;&gt;板子连接到无线路由器命令&lt;/h3&gt;
&lt;p&gt;ifconfig wlan0 up&lt;br /&gt;
iwlist wlan0 scanning (扫描附近的无线路由器)&lt;/p&gt;
&lt;p&gt;修改连接到无线路由器的ssid和密码&lt;br /&gt;
请在/etc/wpa.conf 里面修改。用户可以直接使用vi编辑这个文件，也可以修改rootfs里面的，然后重新制作烧写rootfs&lt;/p&gt;
&lt;p&gt;wpa_supplicant -B -Dwext -iwlan0 -c/etc/wpa.conf&lt;br /&gt;
动态获取ip&lt;br /&gt;
udhcpc -i wlan0&lt;br /&gt;
手动设置ip&lt;br /&gt;
ifconfig wlan0 192.168.1.67&lt;/p&gt;
&lt;p&gt;ping 192.168.1.1 //测试网络是否通，请ping 客户wifi路由器的ip，连接上来就可以ping通路由器&lt;/p&gt;
&lt;p&gt;注意： 如果连接不上，检查SSID是否正确&lt;/p&gt;
&lt;h1 id=&#34;hi3518e上usb-wifi模块移植记录&#34;&gt;Hi3518E上USB Wifi模块移植记录&lt;/h1&gt;
&lt;h3 id=&#34;1-说明&#34;&gt;1.说明&lt;/h3&gt;
&lt;p&gt;Hi3518e+USB Wifi和PC作为station，路由器作为AP。&lt;br /&gt;
MT7601驱动可在此链接下载(5mj9)：&lt;a href=&#34;https://pan.baidu.com/s/122kbybDR22zVRD_lui37ig&#34; target=&#34;_blank&#34;&gt;MT7601_sta_driver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IP分配：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;路由器：192.168.0.1&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开发板：192.168.0.10&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;windows主机：192.168.0.20&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-编译驱动&#34;&gt;2.编译驱动&lt;/h3&gt;
&lt;h4 id=&#34;2-1修改makefile&#34;&gt;2.1修改Makefile&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /sambashare/MT7601_driver/sta/DPO_MT7601U_LinuxSTA_3.0.0.4_20130913
vim Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要修改如下标记my add的三处：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; 66 #PLATFORM = MSTARTV
67
68 #my_add
69 PLATFORM = HISI_3518E
70
71 #APSOC
72 ifeq ($(MODULE),3050)
73 PLATFORM = RALINK_3050
74 endif
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; 101 ifeq ($(TARGET), ECOS)
102 MAKE = make
103 MODULE = $(shell pwd | sed &amp;quot;s/.*\///&amp;quot; ).o
104 export MODULE
105 endif
106
107 #my_add
108 ifeq ($(PLATFORM),HISI_3518E)
109 LINUX_SRC = /home/peco/sambashare/Hi3518E_SDK_V1.0.3.0/osdrv/opensource/kern el/linux-3.4.y
110 CROSS_COMPILE = arm-hisiv300-linux-
111 export ARCH=arm
112 endif
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;407 ifeq ($(PLATFORM),DM6446)
408 $(MAKE) ARCH=arm CROSS_COMPILE=arm_v5t_le- -C $(LINUX_SRC) SUBDIRS=$(R T28xx_DIR)/os/linux modules
409 else
410 #my add
411 ifeq ($(PLATFORM),HISI_3518E)
412 $(MAKE) ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE) -C $(LINUX_SRC) SUBDIRS =$(RT28xx_DIR)/os/linux modules
413 else
414 $(MAKE) -C $(LINUX_SRC) SUBDIRS=$(RT28xx_DIR)/os/linux modules
415 endif
416 endif
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&#34;2-2修改config-mk&#34;&gt;2.2修改config.mk&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim os/linux/config.mk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改如下一处：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1089 ifeq ($(PLATFORM),SMDK)
1090 EXTRA_CFLAGS := $(WFLAGS)
1091 endif
1092
1093 #my add
1094 ifeq ($(PLATFORM),HISI_3518E)
1095 EXTRA_CFLAGS := $(WFLAGS)
1096 endif
1097
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-3修改rtmp-def-h&#34;&gt;2.3修改rtmp_def.h&lt;/h4&gt;
&lt;p&gt;此处修改为了让生成的网卡名字为wlan，也可以不修改，不修改则为ra。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim include/rtmp_def.h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改如下一处：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1599
1600 //#ifdef ANDROID_SUPPORT
1601 #define INF_MAIN_DEV_NAME &amp;quot;wlan&amp;quot;
1602 #define INF_MBSSID_DEV_NAME &amp;quot;wlan&amp;quot;
1603 //#else
1604 //#define INF_MAIN_DEV_NAME &amp;quot;ra&amp;quot;
1605 //#define INF_MBSSID_DEV_NAME &amp;quot;ra&amp;quot;
1606 //#endif /* ANDROID_SUPPORT */
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-4编译驱动&#34;&gt;2.4编译驱动&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make clean &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译生成的驱动在os/linux/目录下。&lt;/p&gt;
&lt;h3 id=&#34;3-编译openssl&#34;&gt;3.编译openSSL&lt;/h3&gt;
&lt;h4 id=&#34;3-1解压文件&#34;&gt;3.1解压文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -xvf wpa_supplicant-2.5.tar.gz
tar -xvf openssl-0.9.8za.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-2给openssl打补丁&#34;&gt;3.2给openSSL打补丁&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cp wpa_supplicant-2.5/patches/openssl-0.9.8za-tls-extensions.patch ./openssl-0.9.8za
cd openssl-0.9.8za/
patch -p1 &amp;lt; openssl-0.9.8za-tls-extensions.patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-3修改openssl-makefile&#34;&gt;3.3修改openSSL Makefile&lt;/h4&gt;
&lt;p&gt;修改如下几处：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CC=arm-hisiv300-linux-gcc
AR=arm-hisiv300-linux-ar $(ARFLAGS) r
ARD=arm-hisiv300-linux-ar $(ARFLAGS) d
RANLIB=arm-hisiv300-linux-ranlib
INSTALLTOP =/tmp/openssl
OPENSSLDIR =/tmp/openssl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若报错xpected text after =item, not a number，则执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rm -f /usr/bin/pod2man
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后执行make install安装openSSL。&lt;/p&gt;
&lt;h3 id=&#34;4-编译wpa-supplicant&#34;&gt;4.编译wpa_supplicant&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd wpa_supplicant-2.5/wpa_supplicant
cp defconfig .config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改.config，增加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CC=arm-hisiv300-linux-gcc -L/tmp/openssl/lib
CFLAGS+=-I /tmp/openssl/include
LIBS+=-L/tmp/openssl/lib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行make，若报错：fatal error: netlink/genl/genl.h，修改.config文件，将CONFIG_DRIVER_NL80211=y 注释掉即可。&lt;br /&gt;
继续make，生成&lt;strong&gt;wpa_supplicant&lt;/strong&gt;和&lt;strong&gt;wpa_cli&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5-部署-spa-supplicant&#34;&gt;5.部署 spa_supplicant&lt;/h3&gt;
&lt;p&gt;将wpa_supplicant、wpa_cli复制到开发板/usr/local/bin目录下。&lt;br /&gt;
创建配置文件/etc/wap_supplicant.conf，输入如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ctrl_interface=/var/run/wpa_supplicant
network={
ssid=&amp;quot;路由器Wifi名字&amp;quot;
scan_ssid=1
key_mgmt= WPA-EAP WPA-PSK IEEE8021X NONE
pairwise=TKIP CCMP
group=CCMP TKIP WEP104 WEP40
psk=&amp;quot;路由器Wifi密码&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装驱动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; insmod mt7601Usta.ko
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置静态IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; ifconfig wlan0 192.168.0.10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发板sta连接AP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wpa_supplicant -Dwext -iwlan0 -c/etc/wpa_supplicant.conf -dd &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ping 192.168.0.1成功，至此USB Wifi移植完成。&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>hi3516 uart1 485</title><link>/hardware/hisilicon/hi3516-uart1-485/</link><pubDate>Wed, 04 Mar 2020 16:54:23 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3516-uart1-485/</guid><description>&lt;p&gt;&lt;a href=&#34;ibm.com/developerworks/cn/linux/l-serials/&#34; target=&#34;_blank&#34;&gt;Linux下串口编程&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;termios.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#define RS485_DEV &amp;quot;/dev/ttyAMA1&amp;quot;
CRS485::CRS485()
{
hasRs485Inited = false;
mFd = -1;
}
CRS485::~CRS485()
{
DEBUG_INFO(DEV_MNG, &amp;quot;RS485 exit&amp;quot;);
if( mFd != -1 )
{
close( mFd );
}
hasRs485Inited = false;
}
int CRS485::setRS485(int band, int stopBit, int parity, int dataBit)
{
int status = -1;
struct termios options;
tcgetattr( mFd, &amp;amp;options );
tcflush( mFd, TCIOFLUSH ); // discard data written to RS485 that hasn&#39;t not been transmitted
// set band rate
switch( band )
{
case 1200:
cfsetispeed( &amp;amp;options, B1200 );
cfsetospeed( &amp;amp;options, B1200 );
break;
case 2400:
cfsetispeed( &amp;amp;options, B2400 );
cfsetospeed( &amp;amp;options, B2400 );
break;
case 4800:
cfsetispeed( &amp;amp;options, B4800 );
cfsetospeed( &amp;amp;options, B4800 );
break;
case 9600:
cfsetispeed( &amp;amp;options, B9600 );
cfsetospeed( &amp;amp;options, B9600 );
break;
case 19200:
cfsetispeed( &amp;amp;options, B19200 );
cfsetospeed( &amp;amp;options, B19200 );
break;
case 38400:
cfsetispeed( &amp;amp;options, B38400 );
cfsetospeed( &amp;amp;options, B38400 );
break;
case 57600:
cfsetispeed( &amp;amp;options, B57600 );
cfsetospeed( &amp;amp;options, B57600 );
break;
default:
DEBUG_ERROR(DEV_MNG, &amp;quot;Band rate:%d is not supported, now use 9600&amp;quot;, band);
cfsetispeed( &amp;amp;options, B9600 );
cfsetospeed( &amp;amp;options, B9600 );
break;
}
status = tcsetattr( mFd, TCSANOW, &amp;amp;options );
if( status != 0 )
{
DEBUG_API_ERROR( DEV_MNG, &amp;quot;tcsetattr(TCSANOW)&amp;quot;);
return -1;
}
tcflush( mFd, TCIOFLUSH );
status = tcgetattr( mFd, &amp;amp;options );
if( status &amp;lt; 0 )
{
DEBUG_API_ERROR( DEV_MNG, &amp;quot;tcgetattr()&amp;quot;);
return -1;
}
// set data bits
options.c_cflag &amp;amp;= (~CSIZE);
switch( dataBit )
{
case 5:
options.c_cflag |= CS5;
break;
case 6:
options.c_cflag |= CS6;
break;
case 7:
options.c_cflag |= CS7;
break;
case 8:
options.c_cflag |= CS8;
break;
default:
DEBUG_ERROR(DEV_MNG, &amp;quot;Unsupported data bits(%d)&amp;quot;, dataBit);
return -1;
break;
}
// set parity
switch( parity )
{
case 0: // None
options.c_cflag &amp;amp;= (~PARENB);
options.c_iflag &amp;amp;= (~INPCK);
break;
case 1: // ODD
options.c_cflag |= (PARODD | PARENB);
options.c_iflag |= INPCK;
break;
case 2: // Even
options.c_cflag |= PARENB;
options.c_cflag &amp;amp;= (~PARODD);
options.c_iflag |= INPCK;
break;
default:
DEBUG_ERROR(DEV_MNG, &amp;quot;Unsupported parity type:%d&amp;quot;, parity);
return -1;
break;
}
// set stop bits
switch( stopBit )
{
case 1:
options.c_cflag &amp;amp;= (~CSTOPB);
break;
case 2:
options.c_cflag |= CSTOPB;
break;
default:
DEBUG_ERROR(DEV_MNG, &amp;quot;Unsupported stop bits:%d&amp;quot;, stopBit);
return -1;
break;
}
/* Set input parity option */
if (parity != 0)
options.c_iflag |= INPCK;
/* Set Raw Mode */
options.c_lflag &amp;amp;= ~(ICANON | ECHO | ECHOE | ISIG); /*Input*/
options.c_oflag &amp;amp;= ~OPOST; /*Output*/
tcflush( mFd, TCIFLUSH );
options.c_cc[VTIME] = 150;
options.c_cc[VMIN] = 7;
status = tcsetattr( mFd, TCSANOW, &amp;amp;options );
if( status != 0 )
{
DEBUG_API_ERROR(DEV_MNG, &amp;quot;tcsetattr()&amp;quot;);
return -1;
}
return 0;
}
int CRS485::init(int band, int stopBit, int parity, int dataBit)
{
if( hasRs485Inited )
{
DEBUG_ERROR(DEV_MNG, &amp;quot;RS485 has been inited&amp;quot;);
return -1;
}
int ret = -1;
// open device
mFd = open( RS485_DEV, O_RDWR );
if( mFd &amp;lt; 0 )
{
DEBUG_API_ERROR(DEV_MNG, &amp;quot;open()&amp;quot;);
return -1;
}
ret = setRS485(band, stopBit, parity, dataBit);
if(ret == -1)
goto ERROR;
// success
hasRs485Inited = 1;
DEBUG_INFO(DEV_MNG, &amp;quot;RS485 init success&amp;quot;);
return 0;
ERROR:
close( mFd );
return -1;
}
int CRS485::sendData(char *data, int dataLen)
{
if( data == NULL )
return -1;
if( dataLen &amp;lt;= 0 )
return -1;
if( hasRs485Inited != 1 )
{
DEBUG_ERROR(DEV_MNG, &amp;quot;Can&#39;t send 485 data before inited&amp;quot;);
return -1;
}
return write( mFd, data, dataLen );
}
int CRS485::recvData(char *data, int dataLen, int maxWaitTime)
{
if( data == NULL )
return -1;
if( dataLen &amp;lt;= 0 )
return -1;
if( hasRs485Inited != 1 )
{
DEBUG_ERROR(DEV_MNG, &amp;quot;Can&#39;t recv 485 data before inited&amp;quot;);
return -1;
}
int index = 0;
int rc = 0;
int rcnum = dataLen;
struct timeval tv;
fd_set readfd;
tv.tv_sec = maxWaitTime / 1000;
tv.tv_usec = maxWaitTime % 1000 * 1000;
FD_ZERO(&amp;amp;readfd);
FD_SET(mFd, &amp;amp;readfd);
rc = select(mFd + 1, &amp;amp;readfd, NULL, NULL, &amp;amp;tv);
if(rc &amp;gt; 0)
{
while(dataLen)
{
rc = read(mFd, &amp;amp;data[index], 1);
if(rc &amp;gt; 0)
index = index + 1;
dataLen = dataLen - 1;
}
if(index != rcnum)
return -1;
return rcnum;
}
else
{
return -1;
}
return -1;
//return read( mFd, data, dataLen );
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>stm32 can</title><link>/hardware/stm32/stm32-can/</link><pubDate>Tue, 03 Mar 2020 17:57:31 CST</pubDate><author>rinetd</author><guid>/hardware/stm32/stm32-can/</guid><description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/Qrsleizhipeng/article/details/79788272&#34; target=&#34;_blank&#34;&gt;基于STM32的CAN总线通信学习笔记_网络_Qrsleizhipeng的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编程调试心得（总结一些知识要点）&lt;/p&gt;
&lt;p&gt;1 对CAN_RX_data的函数定义&lt;/p&gt;
&lt;p&gt;如果函数定义成形式：char CAN_RX_data(CanRxMsg* RecieveData , uint8_t *RXdata);会出现如下反应：&lt;br /&gt;
i:如果 CanRxMsg RecieveMess; 放在CAN_RX_data函数外，即主函数里，将会多打印出一字符：”接收到数据:AED9i8ua”(会多接收到一个的乱码)&lt;br /&gt;
ii:如果 CanRxMsg RecieveMess; 放在函数内，显示正常：”接收到数据:AED9i8ua”&lt;/p&gt;
&lt;p&gt;如果函数定义成形式：char CAN_RX_data(CanRxMsg RecieveData , uint8_t *RXdata);,即：RecieveData为非指针。&lt;br /&gt;
无论CanRxMsg RecieveMess; 在函数内还是函数外不影响。&lt;/p&gt;
&lt;p&gt;分析原因：和形参的指针有关（形参应该为非指针形式）。具体详细原因未解。&lt;/p&gt;
&lt;p&gt;2 知识难点（针对过滤器（筛选器）的理解与配置）：&lt;/p&gt;
&lt;p&gt;如果是接收的数据是标准帧格式：&lt;br /&gt;
标准帧ID占用位数为11位， 在发送函数中设置的标准帧ID（StdId）只需为低11位赋值即可，另外高5位可任意。&lt;/p&gt;
&lt;p&gt;过滤器的ID号与接收的标准帧ID是左对齐形式（即32位与11位的左对齐），因此过滤器的ID号的高11位有过滤的效果，其他位可设任意值。&lt;/p&gt;
&lt;p&gt;举例，如：发送函数配置的标志帧ID：StdId=0xFA8B;则标准帧ID= 010 1000 1011（取最低的11位）&lt;br /&gt;
如果在掩码模式的所有位都在检测的情况下，那么过滤器ID号高11位和标准帧ID应该一样，&lt;br /&gt;
可以取:CAN_FilterIdHigh=0x516F=010 1000 1011 01111 ( CAN_FilterIdLow 任意）&lt;/p&gt;
&lt;p&gt;同理，如果是接收的数据是扩展帧格式：&lt;br /&gt;
标准帧ID占用位数为29位，只需对ExtId的低29位赋值即可。&lt;br /&gt;
过滤时和过滤ID好也是左对齐，因此过滤器的ID号的高29位有过滤的效果，其他位可设任意值。&lt;/p&gt;
&lt;p&gt;3 对过滤器（筛选器）配置方法的改进：&lt;/p&gt;
&lt;p&gt;改进：由于以上给帧ID和过滤器ID赋值格式不统一，也不容易计算。为了统一并方便观察，&lt;br /&gt;
对取标准/扩展帧ID和过滤器ID的赋值进行如下改进。（最严格情况：掩码模式对所有位都要关心）&lt;/p&gt;
&lt;p&gt;举例（标准帧），如程序可设置标准帧ID宏定义为：0xABC（取前11位，最后一位必须取0，不作为标准ID位）。但是，将其写入StdId时，需右移动一位，取出高11位作为有效位：&lt;br /&gt;
StdId = 0xABC&amp;gt;&amp;gt;1; //（取出11位)&lt;br /&gt;
CAN_FilterIdHigh= 0xABC&amp;lt;&amp;lt;4; //11个有效位移动到最左端（使32位过滤ID与11位标准帧的左对齐）&lt;/p&gt;
&lt;p&gt;举例（扩展帧）：如程序可设置扩展帧ID宏定义为：0xABCDEF98（取前29位，最后3位必须取0，不作为标准ID位），但是，将其写入ExtId为时，需右移动3位，取出高29位作为有效位：&lt;br /&gt;
ExtId = 0xABCDEF98&amp;gt;&amp;gt;3;（取出29位）&lt;br /&gt;
CAN_FilterIdHigh = 0xABCDEF98&amp;gt;&amp;gt;16;&lt;br /&gt;
CAN_FilterIdLow = 0xABCDEF98&amp;amp;0x0000FFF8 ;//29个有效位移到最高位（使32位过滤ID与29位标准帧的左对齐）&lt;/p&gt;
&lt;p&gt;需要注意：&lt;br /&gt;
在标准帧下，对于32位的过滤器，设置掩码ID只能关心高11位，后25位不能关心。（掩码ID：0表不关心此位，1表关心此位）&lt;br /&gt;
在扩展帧下，设置掩码ID只能关心高29位，后3位不能关心。&lt;/p&gt;</description></item><item><title>mpp region osd</title><link>/hardware/hisilicon/mpp/mpp-region-osd/</link><pubDate>Mon, 02 Mar 2020 18:57:28 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/mpp/mpp-region-osd/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mill_li/article/details/90262607&#34; target=&#34;_blank&#34;&gt;海思3516A区域管理操作汇总及位图填充示例_海思,OSD,点阵传位图_mill_li的博客-CSDN博客&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.ebaina.com/thread-10385-1-1.html&#34; target=&#34;_blank&#34;&gt;【已解决】关于Hi3516A做OSD的问题 - 海思平台开放论坛 - 易百纳论坛 - Powered by Discuz!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.创建RGN(overlay)&lt;br /&gt;
HI_MPI_RGN_Create()&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;attach到编码通道(设置OSD的位置大小透明特性)&lt;br /&gt;
HI_MPI_RGN_AttachToChn()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;制作OSD内容&lt;br /&gt;
把需要显示的内容做成第一,二步要求的格式放在一块内存里&lt;br /&gt;
4.HI_MPI_RGN_SetBitMap()&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;0x8000 ==0x0&lt;br /&gt;
0x7FFF == 0xFFFF&lt;/p&gt;
&lt;p&gt;结论：&lt;br /&gt;
A. 如果想让背景色透明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. stChnAttr.unChnAttr.stOverlayExChn.u32BgAlpha = 0; // 设置背景色的透明度为0
2. stRegion.unAttr.stOverlay.u32BgColor = 0xxxx &amp;amp; 0x7FFF ; // 把图像像素点的 Alpha 位清0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;B. 如果想让前景色半透明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. stChnAttr.unChnAttr.stOverlayExChn.u32FgAlpha = 64; 设置前景色透明度为 50%
2. 像素点的alpha位设为1 【argb1555 | 0x8000】
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;图像像素点的-alpha-位为1-控制前景色透明度&#34;&gt;图像像素点的 Alpha 位为1 控制前景色透明度&lt;/h4&gt;
&lt;p&gt;stRegion.unAttr.stOverlay.u32BgColor = 0xFFFF; //背景白色 alpha位为1，那么这个颜色的透明度受u32FgAlpha控制，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果u32FgAlpha=64则背景就是50%的透明度。
如果u32FgAlpha=128则背景就是不透明度。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注： 这种情况下，背景色和前景色的透明度始终保持一致，也就是说bmp图片转换为 argb1555 时 alpha位始终为1的&lt;/p&gt;
&lt;h4 id=&#34;图像像素点的-alpha-位为0-控制背景色透明度&#34;&gt;图像像素点的 Alpha 位为0 控制背景色透明度&lt;/h4&gt;
&lt;p&gt;stRegion.unAttr.stOverlay.u32BgColor = 0x7FFF; //背景白色 alpha位为0，那么这个颜色的透明度收u32BgAlpha控制，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果u32BgAlpha=0则背景就是全透明。
如果u32BgAlpha=128则背景就是不透明。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stChnAttr.unChnAttr.stOverlayExChn.u32BgAlpha = 0;//【argb1555 &amp;amp; 0x8000 == 0】 alpha位 为0的像素点透明度，也称背景透明度&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayExChn.u32FgAlpha = 10;//【argb1555 &amp;amp; 0x8000 == 0x8000】alpha为1的像素点透明度，也称前景透明度&lt;/p&gt;
&lt;h3 id=&#34;和图像格式搭配&#34;&gt;和图像格式搭配&lt;/h3&gt;
&lt;p&gt;u32BgAlpha + 图像 Alpha 位为0 的像素点的透明度。也称背景Alpha。&lt;br /&gt;
u32FgAlpha + 图像 Alpha 位为1 的像素点的透明度。也称前景Alpha。&lt;/p&gt;
&lt;p&gt;举例说明:&lt;br /&gt;
比如 u32FgAlpha = 128;u32BgAlpha = 0; 假定0表示透明, 128表示不透明&lt;/p&gt;
&lt;p&gt;在ARGB1555格式下, 像素A的值是0x7fff, 像素B的值是0x8000&lt;br /&gt;
可以看到像素A的 Alpha 位为0, 那么像素B的 Alpha 位为1&lt;/p&gt;
&lt;p&gt;那么&lt;br /&gt;
u32FgAlpha对于像素A没有作用, u32BgAlpha有作用, 作用效果就是被透明了&lt;br /&gt;
u32FgAlpha对于像素B有作用, u32BgAlpha没有作用, 作用效果就是显示了像素B&lt;/p&gt;
&lt;p&gt;所以OSD中的像素点的alpha也很重要, 意思就是用alpha区分前景和背景, 比如前景的alpha = 1, 背景的alpha = 0,然后配合u32FgAlpha和u32FgAlpha就能做到了&lt;/p&gt;
&lt;p&gt;u32FgAlpha Alpha 位为1 的像素点的透明度。也称前景Alpha。&lt;/p&gt;
&lt;p&gt;尴尬了，&lt;br /&gt;
我的像素描点值：&lt;br /&gt;
前景黑色0x8000,&lt;br /&gt;
背景白色是0x7fff；&lt;/p&gt;
&lt;p&gt;rgn_attr.unAttr.stOverlay.u32BgColor = 0x7FFF;&lt;/p&gt;
&lt;p&gt;stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0;&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;&lt;/p&gt;
&lt;p&gt;现象是：屏幕上没osd了；把u32BgAlpha=128，能显示，但是背景是蓝色，很奇怪。&lt;/p&gt;
&lt;p&gt;rgn_attr.unAttr.stOverlay.u32BgColor = 0x7FFF;&lt;/p&gt;
&lt;h3 id=&#34;1-黑白正常显示&#34;&gt;1. 黑白正常显示&lt;/h3&gt;
&lt;p&gt;stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 128; //背景的透明度&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;&lt;/p&gt;
&lt;h3 id=&#34;2-背景白色显示透明&#34;&gt;2. 背景白色显示透明&lt;/h3&gt;
&lt;p&gt;stRegion.unAttr.stOverlay.u32BgColor = 0x7FFF; //背景白色&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0; //背景透明&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 50;&lt;/p&gt;
&lt;h3 id=&#34;2-背景黑色-alpha显示黑色&#34;&gt;2. 背景黑色 Alpha显示黑色&lt;/h3&gt;
&lt;p&gt;stRegion.unAttr.stOverlay.u32BgColor = 0x8000; //背景黑色&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32BgAlpha = 0; //背景透明&lt;br /&gt;
stChnAttr.unChnAttr.stOverlayChn.u32FgAlpha = 128;&lt;/p&gt;
&lt;p&gt;目前用SDL生成了BMP图像，然后给到Hi3516A的Vpss通道，实现了如下图的效果，但是还有两个问题，希望大家能够帮忙看一下&lt;br /&gt;
1、生成的BMP图像的背景颜色如何变成透明的呢，现在有背景颜色不太好看&lt;br /&gt;
2、如何显示两行字符，即在目前显示的时间下面，再显示一行别的信息，这个需要怎么去做，有没有办法让生成的BMP图像有两行或者多行数据呢&lt;/p&gt;
&lt;p&gt;第一个问题可以利用overlay的alpha来处理,当然BMP图像要处理成有alpha的&lt;br /&gt;
第二个问题就是把几个BMP合成一个BMP而已&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;还搞得这么麻烦，我直接用freetype2就在上面画汉字字母了，还是实现了时间显示，根本就不用什么SDL&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;当Alpha 位为1时，芯片使用u32FgAlpha 进行透明度叠加；&lt;br /&gt;
当Alpha 位为0时，芯片使用u32BgAlpha 进行透明度叠加。&lt;br /&gt;
0 表示全透明；128表示不透明。&lt;/p&gt;
&lt;p&gt;而你的BMP的每个象素都是一种alpha的当然就只能一起变了,把要透明的像素的alpha和不要透明的像素的alpha设成不一样的&lt;br /&gt;
注意:这里讨论的实BMP图,而不是RGN的设定&lt;br /&gt;
举例:&lt;br /&gt;
比如你的BMP有两个像素(假设是16bits, RGN设为ARGB1555格式) ,假设BMP的buffer为[0x0000, 0x0123], 可以看出前一个点为黑色,后一个点为有色点,如果要黑点透明,那么要把黑点的值改为&lt;br /&gt;
0x8000, 同时u32FgAlpha=0, u32BgAlpha=128&lt;br /&gt;
这样一来有色点就留下了,黑点就透明了被下面的视频代替了&lt;/p&gt;
&lt;p&gt;关于BMP合并,如果格式相同,就是简单的内存搬移了,很简单&lt;/p&gt;
&lt;p&gt;可以分配一个大的内存,用SDL生成两个BMP内存,然后搬到大的内存就好了,只要注意下起始地址,高,宽和stride就可以了&lt;br /&gt;
然后把大的内存做为osd送给海思就能显示多行了&lt;/p&gt;
&lt;p&gt;s32Ret = SAMPLE_RGN_UpdateCanvas(&amp;quot;sys_time.bmp&amp;quot;, &amp;amp;stBitmap, HI_FALSE, 0, &amp;amp;stSize, stCanvasInfo.u32Stride, stRgnAttrSet.unAttr.stOverlayEx.enPixelFmt);&lt;/p&gt;
&lt;p&gt;请注意第三第四个参数, 这两个可以控制透明, 第三个设为HI_TRUE, 第四个设为BMP中需要透明的背景像素的值(你可以用打印的方法得到)&lt;/p&gt;
&lt;p&gt;也可以做个测试,第四个参数设为0x8000(从代码和贴出OSD的实际图猜的), 应该会看到osd中的字(黑色的部分, 希望值是0x8000,祈祷中...)透明了&lt;/p&gt;
&lt;h3 id=&#34;求助-时间osd闪烁&#34;&gt;[求助] 时间osd闪烁&lt;/h3&gt;
&lt;p&gt;你每隔500ms，或者1s 刷新一下画布HI_MPI_RGN_UpdateCanvas就可以了啊，没有必要HI_MPI_RGN_DetachFromChn，和销毁HI_MPI_RGN_Destroy啊&lt;/p&gt;</description></item><item><title>启用linux内核对usb摄像头的支持</title><link>/hardware/kernel/linux-kernel-uvc-usb-camera/</link><pubDate>Sat, 29 Feb 2020 20:02:14 CST</pubDate><author>rinetd</author><guid>/hardware/kernel/linux-kernel-uvc-usb-camera/</guid><description>&lt;p&gt;1、配置内核；允许如下命令配置linux内核&lt;/p&gt;
&lt;p&gt;make menuconfig&lt;/p&gt;
&lt;p&gt;2、启用摄像头支持，最后一步时根据自己需要进行选择摄像头配置。&lt;br /&gt;
      Device Drivers  ---&amp;gt;&lt;br /&gt;
               &amp;lt;&lt;em&gt;&amp;gt; Multimedia support  ---&amp;gt;&lt;br /&gt;
                         [&lt;/em&gt;]   Video capture adapters  ---&amp;gt;&lt;br /&gt;
                                [&lt;em&gt;]   V4L USB devices  ---&amp;gt;&lt;br /&gt;
                                         &amp;lt;&lt;/em&gt;&amp;gt;   USB Video Class (UVC)&lt;br /&gt;
                                          [*]     UVC input events device support   &lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「yingxian_Fei」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/smilefyx/article/details/29574783&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/smilefyx/article/details/29574783&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>