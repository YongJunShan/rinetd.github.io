<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>时光小栈 on 时光小栈</title>
        <link>/</link>
        <language>zh-CN</language>
        <author>rinetd</author>
        <rights>Copyright (c) 2015, rinetd; all rights reserved.</rights>
        <updated>Wed, 08 Jan 2020 09:51:41 CST</updated>
        
        <item>
            <title>AT指令（中文详解版）（一）</title>
            <link>/hardware/at-helper/</link>
            <pubDate>Wed, 08 Jan 2020 09:51:41 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/at-helper/</guid>
            <description>&lt;p&gt;一 ． 一 般 命 令&lt;br /&gt;
1．AT+CGMI      给出模块厂商的标识。&lt;br /&gt;
2．AT+CGMM    获得模块标识。这个命令用来得到支持的频带（GSM 900，DCS 1800    或PCS 1900）。当&lt;br /&gt;
模块有多频带时，回应可能是不同频带的结合。&lt;br /&gt;
3．AT+CGMR    获得模块的软件版本。&lt;br /&gt;
4．AT+CGSN    获得 GSM  模块的 IMEI（国际移动设备标识）序列号。&lt;br /&gt;
5．AT+CSCS    选择TE  特征设定。这个命令报告TE  用的是哪个状态设定上的 ME。&lt;br /&gt;
ME于是可以转换每一个输入的或显示的字母。这个是用来发送.读取或者撰写短信。&lt;br /&gt;
6．AT+WPCS    设定电话簿状态。这个特殊的命令报告通过 TE    电话簿所用的状态的 ME。&lt;br /&gt;
ME于是可以转换每一个输入的或者显示的字符串字母。这个用来读或者写电话簿的入口。&lt;br /&gt;
7．AT+CIMI    获得 IMSI。这命令用来读取或者识别 SIM  卡的IMSI (国际移动签署者标识）。  在读取&lt;br /&gt;
IMSI  之前应该先输入 PIN（如果需要 PIN 的话）码。&lt;br /&gt;
8．AT+CCID    获得 SIM  卡的标识。这个命令使模块读取 SIM卡上的 EF-CCID  文件。&lt;br /&gt;
9．AT+GCAP    获得能力表。（支持的功能）&lt;br /&gt;
10．A/           重复上次命令。只有 A/  命令不能重复。这命令重复前一个执行的命令。&lt;br /&gt;
11．AT+CPOF    关机。这个特殊的命令停止 GSM   软件堆栈和硬件层。命令 AT+CFUN=0 的功能&lt;br /&gt;
与+CPOF  相同。&lt;br /&gt;
12．AT+CFUN    设定电话机能。这个命令选择移动站点的机能水平。&lt;br /&gt;
13．AT+CPAS    返回移动设备的活动状态。&lt;br /&gt;
14．AT+CMEE    报告移动设备的错误。这个命令决定是否允许输出错误代码“+CME   ERROR:&lt;xxx&gt;”&lt;br /&gt;
或者“+CMSERROR:&lt;xxx&gt;”代替简单的“ERROR” 。&lt;br /&gt;
15．AT+CKPD    小键盘控制。仿真 ME小键盘执行命令。&lt;br /&gt;
16．AT+CCLK    时钟管理。这个命令用来设置或者获得 ME真实时钟的当前日期和时间。&lt;br /&gt;
17．AT+CALA    警报管理。这个命令用来设定在 ME  中的警报日期/时间。（闹铃）&lt;br /&gt;
18．AT+CRMP    铃声旋律播放。这个命令在模块的蜂鸣器上播放一段旋律。有两种旋律可用：语音来电&lt;br /&gt;
及数据或传真呼叫旋律和到来短信声音。&lt;br /&gt;
19．AT+CRSL    设定或获得到来的电话铃声的声音级别。&lt;/p&gt;

&lt;p&gt;二 ． 呼 叫 控 制 命 令&lt;br /&gt;
1．ATD           拨号命令。这个命令用来设置通话.数据或传真呼叫。&lt;br /&gt;
2．ATH           挂机命令。&lt;br /&gt;
3．ATA           接电话。&lt;br /&gt;
4．AT+CEER    扩展错误报告。这个命令给出当上一次通话设置失败后中断通话的原因。&lt;br /&gt;
5．AT+VTD      给用户提供应用 GSM  网络发送 DTMF（双音多频）双音频。这个命令用来定义双音&lt;br /&gt;
频的长度（默认值是 300 毫秒）。&lt;br /&gt;
6．AT+VTS       给用户提供应用 GSM  网络发送 DTMF 双音频。这个命令允许传送双音频。&lt;br /&gt;
7．ATDL        重拨上次电话号码。&lt;br /&gt;
8．AT%Dn        数据终端就绪（DTR）时自动拨号。&lt;br /&gt;
9．ATS0          自动应答。&lt;br /&gt;
10．AT+CICB    来电信差。&lt;br /&gt;
11．AT+CSNS    单一编号方案。&lt;br /&gt;
12．AT+VGR，AT+VGT      增益控制。这个命令应用于调节喇叭的接收增益和麦克风的传输增益。&lt;br /&gt;
13．AT+CMUT               麦克风静音控制。&lt;br /&gt;
14．AT+SPEAKER             喇叭/麦克风选择。这个特殊命令用来选择喇叭和麦克风。&lt;br /&gt;
 Tech-Link T&amp;amp;E Limited&lt;/p&gt;

&lt;p&gt;15．AT+ECHO        回音取消。&lt;br /&gt;
16．AT+SIDET          侧音修正。&lt;br /&gt;
17．AT+VIP          初始化声音参数。&lt;br /&gt;
18．AT+DUI           用附加的用户信息拨号。&lt;br /&gt;
19．AT+HUI           用附加的用户信息挂机。&lt;br /&gt;
20．AT+RUI           接收附加用户信息。&lt;/p&gt;

&lt;p&gt;三 .网 络 服 务 命 令&lt;br /&gt;
1．AT+CSQ      信号质量。&lt;br /&gt;
2．AT+COPS    服务商选择。&lt;br /&gt;
3．AT+CREG    网络注册。获得手机的注册状态。&lt;br /&gt;
4．AT+WOPN    读取操作员名字。&lt;br /&gt;
5．AT+CPOL    优先操作员列表。&lt;/p&gt;

&lt;p&gt;四 ． 安 全 命 令&lt;br /&gt;
1．AT+CPIN            输入 PIN。&lt;br /&gt;
2．AT+CPIN2           输入 PIN2。&lt;br /&gt;
3．AT+CPINC         PIN 的剩余的尝试号码。&lt;br /&gt;
4．AT+CLCK          设备锁。&lt;br /&gt;
5．AT+CPWD           改变密码。&lt;/p&gt;

&lt;p&gt;五 ． 电 话 簿 命 令&lt;br /&gt;
1．AT+CPBS        选择电话簿记忆存储。&lt;br /&gt;
2．AT+CPBR        读取电话簿表目。&lt;br /&gt;
3．AT+CPBF        查找电话簿表目。&lt;br /&gt;
4．AT+CPBW       写电话簿表目。&lt;br /&gt;
5．AT+CPBP        电话簿电话查询。&lt;br /&gt;
6．AT+CPBN        电话簿移动动作。这个特殊命令使电话簿中的条目前移或后移（按字母顺序）&lt;br /&gt;
7．AT+CNUM       签署者号码。&lt;br /&gt;
8．AT+WAIP        防止在下一次重起时初始化所有的电话簿。&lt;br /&gt;
9．AT+WDCP       删除呼叫电话号码。&lt;br /&gt;
10．AT+CSVM    设置语音邮件号码。&lt;/p&gt;

&lt;p&gt;六 ． 短 消 息 命 令&lt;br /&gt;
1．AT+CSMS       选择消息服务。支持的服务有 GSM-MO.SMS-MT.SMS-CB。&lt;br /&gt;
2．AT+CNMA     新信息确认应答。&lt;br /&gt;
3．AT+CPMS       优先信息存储。这个命令定义用来读写信息的存储区域。&lt;br /&gt;
4．AT+CMGF    优先信息格式。执行格式有 TEXT    方式和 PDU    方式。&lt;br /&gt;
5．AT+CSAS      保存设置。保存+CSAS  和+CSMP  的参数。&lt;br /&gt;
6．AT+CRES       恢复设置。&lt;br /&gt;
7．AT+CSDH       显示文本方式的参数。&lt;br /&gt;
8．AT+CNMI       新信息指示。这个命令选择如何从网络上接收短信息。&lt;br /&gt;
9．AT+CMGR    读短信。信息从+CPMS    命令设定的存储器读取。&lt;br /&gt;
10．AT+CMGL    列出存储的信息。&lt;br /&gt;
11．AT+CMGS    发送信息。&lt;br /&gt;
12．AT+CMGW   写短信息并存储。&lt;br /&gt;
 Tech-Link T&amp;amp;E Limited&lt;/p&gt;

&lt;p&gt;13．AT+CMSS       从存储器中发送信息。&lt;br /&gt;
14．AT+CSMP       设置文本模式的参数。&lt;br /&gt;
15．AT+CMGD    删除短信息。删除一个或多个短信息。&lt;br /&gt;
16．AT+CSCA       短信服务中心地址。&lt;br /&gt;
17．AT+CSCB      选择单元广播信息类型。&lt;br /&gt;
18．AT+WCBM    单元广播信息标识。&lt;br /&gt;
19．AT+WMSC    信息状态（是否读过.是否发送等等）修正。&lt;br /&gt;
20．AT+WMGO    信息覆盖写入。&lt;br /&gt;
21．AT+WUSS       不改变 SMS    状态。在执行+CMGR  或+CMGL 后仍保持 UNREAD。&lt;/p&gt;

&lt;p&gt;七 ． 追 加 服 务 命 令&lt;br /&gt;
1．AT+CCFC        呼叫继续。&lt;br /&gt;
2．AT+CLCK        呼叫禁止。&lt;br /&gt;
3．AT+CPWD        改变追加服务密码。&lt;br /&gt;
4．AT+CCWA        呼叫等待。&lt;br /&gt;
5．AT+CLIR         呼叫线确认限制。&lt;br /&gt;
6．AT+CLIP           呼叫线确认陈述。&lt;br /&gt;
7．AT+COLP        联络线确认陈述。&lt;br /&gt;
8．AT+CAOC        费用报告。&lt;br /&gt;
9．AT+CACM       累计呼叫计量。&lt;br /&gt;
10．AT+CAMM    累计呼叫计量最大值。&lt;br /&gt;
11．AT+CPUC       单价和货币表。&lt;br /&gt;
12．AT+CHLD       呼叫相关的追加服务。&lt;br /&gt;
13．AT+CLCC       列出当前的呼叫。&lt;br /&gt;
14．AT+CSSN       追加服务通知。&lt;br /&gt;
15．AT+CUSD       无组织的追加服务数据。&lt;br /&gt;
16．AT+CCUG       关闭的用户组。&lt;/p&gt;

&lt;p&gt;八 ． 数 据 命 令&lt;br /&gt;
1．AT+CBST         信差类型选择。&lt;br /&gt;
2．AT+FCLASS    选择模式。这个命令把模块设置成数据或传真操作的特殊模式。&lt;br /&gt;
3．AT+CR           服务报告控制。这个命令允许更为详细的服务报告。&lt;br /&gt;
4．AT+CRC         划分的结果代码。这个命令在呼叫到来时允许更为详细的铃声指示。&lt;br /&gt;
5．AT+ILRR       本地 DTE-DCE    速率报告。&lt;br /&gt;
6．AT+CRLP       无线电通信线路协议参数。&lt;br /&gt;
7．AT+DOPT        其他无线电通信线路参数。&lt;br /&gt;
8．AT%C           数据压缩选择。&lt;br /&gt;
9．AT+DS          是否允许 V42    二度数据压缩。&lt;br /&gt;
10．AT+DR           是否报告 V42    二度数据压缩。&lt;br /&gt;
11．AT/N           数据纠错选择。&lt;/p&gt;

&lt;p&gt;九 ． 传 真 命 令&lt;br /&gt;
1．AT+FTM      传送速率。&lt;br /&gt;
2．AT+FRM       接收速率&lt;br /&gt;
3．AT+FTH      用 HDLC协议设置传真传送速率。&lt;br /&gt;
4．AT+FRH      用 HDLC协议设置传真接收速率。&lt;br /&gt;
 Tech-Link T&amp;amp;E Limited&lt;/p&gt;

&lt;p&gt;5．AT+FTS      停止特定时期的传送并等待。&lt;br /&gt;
6．AT+FRS       接收沉默。&lt;/p&gt;

&lt;p&gt;十 ． 第 二 类 传 真 命 令&lt;br /&gt;
1．AT+FDT        传送数据。&lt;br /&gt;
2．AT+FDR        接收数据。&lt;br /&gt;
3．AT+FET        传送页标点。&lt;br /&gt;
4．AT+FPTS       页转换状态参数。&lt;br /&gt;
5．AT+FK         终止会议。&lt;br /&gt;
6．AT+FBOR    页转换字节顺序。&lt;br /&gt;
7．AT+FBUF       缓冲大小报告。&lt;br /&gt;
8．AT+FCQ        控制拷贝质量检验。&lt;br /&gt;
9．AT+FCR        控制接收传真的能力。&lt;br /&gt;
10．AT+FDIS       当前会议参数。&lt;br /&gt;
11．AT+FDCC    设置 DCE    功能参数。&lt;br /&gt;
12．AT+FLID       定义本地 ID    串。&lt;br /&gt;
13．AT+FPHCTO       页转换超时参数。&lt;/p&gt;

&lt;p&gt;十 一 .V25-V25 命 令&lt;br /&gt;
1．AT+IPR          确定 DTE    速率。&lt;br /&gt;
2．AT+ICF         确定 DTE-DCE  特征结构。&lt;br /&gt;
3．AT+IFC         控制 DTE-DCE  本地流量。&lt;br /&gt;
4．AT&amp;amp;C          设置 DCD（数据携带检测）信号。&lt;br /&gt;
5．AT&amp;amp;D          设置 DTR（数据终端就绪）信号。&lt;br /&gt;
6．AT&amp;amp;S          设置 DST（数据设置就绪）信号。&lt;br /&gt;
7．ATV            决定 DCE    响应格式。&lt;br /&gt;
8．ATZ            恢复为缺省设置。&lt;br /&gt;
9．AT&amp;amp;W          保存设置。&lt;br /&gt;
10．ATE           决定是否回显字符。&lt;br /&gt;
11．AT&amp;amp;F          回到出厂时的设定。&lt;br /&gt;
12．AT&amp;amp;V         显示模块设置情况。&lt;br /&gt;
13．AT+WMUX       数据/命令多路复用。&lt;/p&gt;

&lt;p&gt;十 二 .特 殊 AT 命 令&lt;br /&gt;
1．AT+CCED         小区环境描述。&lt;br /&gt;
2．AT+WIND         一般指示。&lt;br /&gt;
3．AT+ADC          模拟数字转换度量。&lt;br /&gt;
4．AT+CMER         移动设备事件报告。这个命令决定是否允许在键按下时是否主动发送结果代码。&lt;br /&gt;
5．AT+WLPR          读取的语言编码。&lt;br /&gt;
6．AT+WLPW          写的语言编码。&lt;br /&gt;
7．AT+WIOR          读取 GPIO  值。&lt;br /&gt;
8．AT+WIOW          写 GPIO  值。&lt;br /&gt;
9．AT+WIOM          输入/输出口管理。&lt;br /&gt;
10．AT+WTONE       播放旋律。&lt;br /&gt;
11．AT+WDTMF       播放 DTMF    旋律。&lt;br /&gt;
12．AT+WDWL        进入软件下载模式。&lt;br /&gt;
 Tech-Link T&amp;amp;E Limited&lt;/p&gt;

&lt;p&gt;13．AT+WVR            配置信差的声音速率。&lt;br /&gt;
14．AT+WDR          配置数据速率&lt;br /&gt;
15．AT+WHWV       显示硬件的版本。&lt;br /&gt;
16．AT+WDOP        显示产品的出厂日期。&lt;br /&gt;
17．AT+WSVG         声音增益选择。&lt;br /&gt;
18．AT+WSTR         返回指定状态的状态。&lt;br /&gt;
19．AT+WSCAN       扫描收到的信号强度。&lt;br /&gt;
20．AT+WRIM       设置或返回铃声指示模式&lt;br /&gt;
21．AT+W32K         是否允许 32kHz  省电方式。&lt;br /&gt;
22．AT+WCDM        改变缺省旋律。&lt;br /&gt;
23．AT+WSSW        显示内部软件版本。&lt;br /&gt;
24．AT+WCCS       编辑或显示订制性质设置表。&lt;br /&gt;
25．AT+WLCK       允许在特定的操作符上个性化 ME。&lt;br /&gt;
26．AT+CPHS        设置 CPHS  命令。&lt;br /&gt;
27．AT+WBCM        电池充电管理。&lt;br /&gt;
28．AT+WFM         特性管理。是否允许模块的某些特性，如频段模式及 SIM  卡电压等。&lt;br /&gt;
29．AT+WCFM        商业特性管理。是否允许 Wavecom  特殊特性。&lt;br /&gt;
30．AT+WMIR        允许从当前存储的参数值创建定制的存储镜像&lt;br /&gt;
31．AT+WCDP       改变旋律的缺省播放器。&lt;/p&gt;

&lt;p&gt;十 三 .SIM  卡 工 具 箱 命 令&lt;br /&gt;
1．AT+STSF         配置工具箱实用程序。&lt;br /&gt;
2．AT+STIN        工具箱指示。&lt;br /&gt;
3．AT+STGI         获得从 SIM  卡发来的预期命令的信息。&lt;br /&gt;
4．AT+STCR        主动提供的结果：工具箱控制反应。&lt;br /&gt;
5．AT+STGR        给出响应。允许程序或用户从主菜单上选择项目，或响应某些命令。&lt;/p&gt;

&lt;p&gt;AT命令最常见的应用场景：&lt;br /&gt;
1。智能手机：一般智能手机都是一个主芯片控制一个通信模块，这个通信模块就是一个完整的、简单的手机，包括手机应该有的射频、基带等部分，还有GSM协议栈，完全可以独立打电话、发短信、用GPRS上网等。主芯片实现复杂的应用软件。主芯片和通信模块之间通过AT命令，也就是做主芯片通过AT命令控制通信模块打电话，发短信等。2、当其他通信模块。例如出租车上的车载台，通信模块可以接收控制中心发来的短信，进行车辆调度，或者利用GSM中的位置服务－－一种补充业务，可以实现大致的定位，控制中心可以对出租车做简单的位置跟踪。&lt;br /&gt;
简单的说，无线通讯中有一种产品就是把一个简单的手机做成半成品，这个半成品可以通过AT命令控制来实现发短信，打电话，gprs上网等无线通讯功能，业界把这种产品叫做模块\无线模块。然后这个半成品卖给集成商，集成商在产品中挂载一个这样的无线模块，这个无线模块受主芯片控制。集成商可以用这种方式做出不同应用的产品，例如智能手机。其中AT命令是主芯片和无线模块的协议接口，硬件接口一般使用串口。&lt;br /&gt;
下面的一段是从百度上拷贝下来的，借花献佛。&lt;br /&gt;
附件是一个AT命令spec样本。&lt;br /&gt;
AT指令介绍及用法&lt;/p&gt;

&lt;p&gt;AT 指令&lt;br /&gt;
AT 即Attention，AT指令集是从终端设备(Terminal Equipment，TE)或数据终端设备(Data Terminal Equipment，DTE)向终端适配器(Terminal Adapter， TA)或数据电路终端设备(Data Circuit Terminal Equipment，DCE)发送的。通过TA，TE发送AT指令来控制移动台(Mobile Station，MS)的功能，与GSM 网络业务进行交互。用户可以通过AT指令进行呼叫、短信、电话本、数据业务、传真等方面的控制。90年代初，AT指令仅被用于Modem操作。没有控制移动电话文本消息的先例，只开发了一种叫SMS BlockMode的协议，通过终端设备(TE)或电脑来完全控制&lt;br /&gt;
SMS。几年后，主要的移动电话生产厂商诺基亚、爱立信、摩托罗拉和HP共同为GSM 研制了一整套AT指令，其中就包括对SMS的控制。AT指令在此基础上演化并被加入GSM 07．05标准以及现在的GSM07．07标准，完全标准化和比较健全的标准。如：对SMS的控制共有3种实现途径：最初的Block Mode；基于AT指令的Text Mode；基于AT指令的PDU Mode。到现在PDU Mode已经取代BlockMode，后者逐渐淡出。GSM 模块与计算机之间的通信协议是一些AT指令&lt;br /&gt;
集，AT指令是以AT作首， 字符结束的字符串，AT指令的响应数据包在 中。每个指令执行成功与否都有相应的返回。其他的一些非预期的信息(如有人拨号进来、线路无信号等)，模块将有对应的一些信息提示，接收端可做相应的处理。&lt;br /&gt;
示例：CDMA modem DTE&lt;br /&gt;
AT&amp;lt; CR&amp;gt;&lt;br /&gt;
&amp;lt; LF&amp;gt; OK &amp;lt; LF&amp;gt;&lt;br /&gt;
ATTEST&amp;lt; CR&amp;gt;&lt;br /&gt;
&amp;lt; CR&amp;gt; ERROR &amp;lt; LF&amp;gt;&lt;br /&gt;
如果AT指令执行成功，“OK”字符串返回；&lt;br /&gt;
如果AT 指令语法错误或AT 指令执行失败，&lt;br /&gt;
“ERROR”字符串返回。&lt;/p&gt;

&lt;p&gt;col 1&lt;br /&gt;
---------- | -----------------------------------------------------------------------------------------------&lt;br /&gt;
&lt;strong&gt;一、一般命令&lt;/strong&gt;&lt;br /&gt;
AT+CGMI    | 给出模块厂商的标识。 SONY ERICSSON&lt;br /&gt;
AT+CGMM    | 获得模块标识。这个命令用来得到支持的频带（GSM900，DCS1800或PCS1900）。当模块有多频带时，回应可能是不同频带的结合。 AAB-1021011-CN&lt;br /&gt;
AT+CGMR    | 获得改订的软件版本。 R6C005      CXC125582CHINA1&lt;br /&gt;
AT+CGSN    | 获得GSM模块的IMEI（国际移动设备标识）序列号。351254004238596&lt;br /&gt;
AT+CSCS    | 选择TE特征设定。这个命令报告TE用的是哪个状态设定上的ME。ME于是可以转换每一个输入的或显示的字母。这个是用来发送、读取或者撰写短信。&lt;/p&gt;

&lt;p&gt;AT+CSCS?&lt;/p&gt;

&lt;p&gt;+CSCS: &amp;quot;GSM&amp;quot;&lt;br /&gt;
AT+WPCS    | 设定电话簿状态。这个特殊的命令报告通过TE电话簿所用的状态的ME。ME于是可以转换每一个输入的或者显示的字符串字母。这个用来读或者写电话簿的入口。&lt;/p&gt;

&lt;p&gt;NONE&lt;br /&gt;
AT+CIMI    | 获得IMSI。这命令用来读取或者识别SIM卡的IMSI（国际移动签署者标识）。在读取IMSI之前应该先输入PIN（如果需要PIN的话）。&lt;/p&gt;

&lt;p&gt;460001711603161&lt;br /&gt;
AT+CCID    | 获得SIM卡的标识。这个命令使模块读取SIM卡上的EF-CCID文件。&lt;/p&gt;

&lt;p&gt;NONE&lt;br /&gt;
AT+GCAP    | 获得能力表。（支持的功能）+GCAP: +FCLASS, +CGSM, +DS&lt;br /&gt;
A/        |  重复上次命令。只有A/命令不能重复。这命令重复前一个执行的命令。&lt;br /&gt;
AT+CPOF    | 关机。这个特殊的命令停止GSM软件堆栈和硬件层。命令AT+CFUN=0的功能与+CPOF相同。&lt;br /&gt;
AT+CFUN    | 设定电话机能。这个命令选择移动站点的机能水平。&lt;br /&gt;
AT+CPAS    | 返回移动设备的活动状态。&lt;br /&gt;
AT+CMEE    | 报告移动设备的错误。这个命令决定允许或不允许用结果码“+CMEERROR:”或者“+CMSERROR:”代替简单的“ERROR”。&lt;br /&gt;
AT+CKPD    | 小键盘控制。仿真ME小键盘执行命令。&lt;br /&gt;
AT+CCLK    | 时钟管理。这个命令用来设置或者获得ME真实时钟的当前日期和时间。&lt;/p&gt;

&lt;p&gt;AT+CCLK?&lt;/p&gt;

&lt;p&gt;+CCLK: &amp;quot;04/08/12,17:00:42+32&amp;quot;&lt;br /&gt;
AT+CALA    | 警报管理。这个命令用来设定在ME中的警报日期/时间。（闹铃）&lt;/p&gt;

&lt;p&gt;AT+CALA=?&lt;/p&gt;

&lt;p&gt;+CALA: (1-2),(),(),(13),()&lt;br /&gt;
AT+CRMP    | 铃声旋律播放。这个命令在模块的蜂鸣器上播放一段旋律。有两种旋律可用：到来语音、数据或传真呼叫旋律和到来短信声音。&lt;br /&gt;
AT+CRSL    | 设定或获得到来的电话铃声的声音级别。NONE&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、呼叫控制命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ATD&lt;/td&gt;
&lt;td&gt;拨号命令。这个命令用来设置通话、数据或传真呼叫。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATH&lt;/td&gt;
&lt;td&gt;挂机命令。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATA&lt;/td&gt;
&lt;td&gt;接电话。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CEER&lt;/td&gt;
&lt;td&gt;扩展错误报告。这个命令给出当上一次通话设置失败后中断通话的原因。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+VTD&lt;/td&gt;
&lt;td&gt;给用户提供应用GSM网络发送DTMF（双音多频）双音频。这个命令用来定义双音频的长度（默认值是300毫秒）。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+VTS&lt;/td&gt;
&lt;td&gt;给用户提供应用GSM网络发送DTMF双音频。这个命令允许传送双音频。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATDL&lt;/td&gt;
&lt;td&gt;重拨上次电话号码。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT%Dn&lt;/td&gt;
&lt;td&gt;数据终端就绪（DTR）时自动拨号。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATS0&lt;/td&gt;
&lt;td&gt;自动应答。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CICB&lt;/td&gt;
&lt;td&gt;来电信差。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSNS&lt;/td&gt;
&lt;td&gt;单一编号方案。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;AT+VGR&lt;/p&gt;

&lt;p&gt;AT+VGT | 增益控制。这个命令应用于调节喇叭的接收增益和麦克风的传输增益。&lt;br /&gt;
AT+CMUT        | 麦克风静音控制。&lt;br /&gt;
AT+SPEAKER     | 喇叭/麦克风选择。这个特殊命令用来选择喇叭和麦克风。&lt;br /&gt;
AT+ECHO        | 回音取消。&lt;br /&gt;
AT+SIDET       | 侧音修正。&lt;br /&gt;
AT+VIP         | 初始化声音参数。&lt;br /&gt;
AT+DUI         | 用附加的用户信息拨号。&lt;br /&gt;
AT+HUI         | 用附加的用户信息挂机。&lt;br /&gt;
AT+RUI         | 接收附加用户信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、网络服务命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CSQ&lt;/td&gt;
&lt;td&gt;信号质量。+CSQ: 17,99&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+COPS&lt;/td&gt;
&lt;td&gt;服务商选择。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;AT+COPS?&lt;/p&gt;

&lt;p&gt;+COPS: 0,0,&amp;quot;China Mobile&amp;quot;&lt;br /&gt;
AT+CREG | 网络注册。获得手机的注册状态。&lt;/p&gt;

&lt;p&gt;AT+CREG?&lt;/p&gt;

&lt;p&gt;+CREG: 0,1&lt;br /&gt;
AT+WOPN | 读取操作员名字。NONE&lt;br /&gt;
AT+CPOL | 优先操作员列表。NONE&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、安全命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CPIN&lt;/td&gt;
&lt;td&gt;输入PIN。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPIN2&lt;/td&gt;
&lt;td&gt;输入PIN2。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPINC&lt;/td&gt;
&lt;td&gt;PIN的剩余的尝试号码。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLCK&lt;/td&gt;
&lt;td&gt;设备锁。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPWD&lt;/td&gt;
&lt;td&gt;改变密码。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;五、电话簿命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CPBS&lt;/td&gt;
&lt;td&gt;选择电话簿记忆存储。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;AT+CPBS?&lt;/p&gt;

&lt;p&gt;+CPBS: &amp;quot;SM&amp;quot;&lt;br /&gt;
AT+CPBR | 读取电话簿表目。&lt;/p&gt;

&lt;p&gt;AT+CPBF | 查找电话簿表目。&lt;br /&gt;
AT+CPBW | 写电话簿表目。&lt;br /&gt;
AT+CPBP | 电话簿电话查询。&lt;br /&gt;
AT+CPBN | 电话簿移动动作。这个特殊命令使电话簿中的条目前移或后移（按字母顺序）&lt;br /&gt;
AT+CNUM | 签署者号码。&lt;br /&gt;
AT+WAIP | 防止在下一次重起时初始化所有的电话簿。&lt;br /&gt;
AT+WDCP | 删除呼叫电话号码。NONE&lt;br /&gt;
AT+CSVM | 设置语音邮件号码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、短消息命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CSMS&lt;/td&gt;
&lt;td&gt;选择消息服务。支持的服务有GSM-MO、SMS-MT、SMS-CB。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CNMA&lt;/td&gt;
&lt;td&gt;新信息确认应答。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPMS&lt;/td&gt;
&lt;td&gt;优先信息存储。这个命令定义用来读写信息的存储区域。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGF&lt;/td&gt;
&lt;td&gt;优先信息格式。执行格式有TEXT方式和PDU方式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSAS&lt;/td&gt;
&lt;td&gt;保存设置。保存+CSAS和+CSMP的参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CRES&lt;/td&gt;
&lt;td&gt;恢复设置。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSDH&lt;/td&gt;
&lt;td&gt;显示文本方式的参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CNMI&lt;/td&gt;
&lt;td&gt;新信息指示。这个命令选择如何从网络上接收短信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGR&lt;/td&gt;
&lt;td&gt;读短信。信息从+CPMS命令设定的存储器读取。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGL&lt;/td&gt;
&lt;td&gt;列出存储的信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGS&lt;/td&gt;
&lt;td&gt;发送信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGW&lt;/td&gt;
&lt;td&gt;写短信息并存储。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMSS&lt;/td&gt;
&lt;td&gt;从存储器中发送信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSMP&lt;/td&gt;
&lt;td&gt;设置文本模式的参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGD&lt;/td&gt;
&lt;td&gt;删除短信息。删除一个或多个短信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSCA&lt;/td&gt;
&lt;td&gt;短信服务中心地址。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSCB&lt;/td&gt;
&lt;td&gt;选择单元广播信息类型。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WCBM&lt;/td&gt;
&lt;td&gt;单元广播信息标识。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WMSC&lt;/td&gt;
&lt;td&gt;信息状态（是否读过、是否发送等等）修正。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WMGO&lt;/td&gt;
&lt;td&gt;信息覆盖写入。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WUSS&lt;/td&gt;
&lt;td&gt;不改变SMS状态。在执行+CMGR或+CMGL后仍保持UNREAD。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;七、追加服务命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CCFC&lt;/td&gt;
&lt;td&gt;呼叫继续。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLCK&lt;/td&gt;
&lt;td&gt;呼叫禁止。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPWD&lt;/td&gt;
&lt;td&gt;改变追加服务密码。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CCWA&lt;/td&gt;
&lt;td&gt;呼叫等待。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLIR&lt;/td&gt;
&lt;td&gt;呼叫线确认限制。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLIP&lt;/td&gt;
&lt;td&gt;呼叫线确认陈述。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+COLP&lt;/td&gt;
&lt;td&gt;联络线确认陈述。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CAOC&lt;/td&gt;
&lt;td&gt;费用报告。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CACM&lt;/td&gt;
&lt;td&gt;累计呼叫计量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CAMM&lt;/td&gt;
&lt;td&gt;累计呼叫计量最大值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPUC&lt;/td&gt;
&lt;td&gt;单价和货币表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CHLD&lt;/td&gt;
&lt;td&gt;呼叫相关的追加服务。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLCC&lt;/td&gt;
&lt;td&gt;列出当前的呼叫。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSSN&lt;/td&gt;
&lt;td&gt;追加服务通知。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CUSD&lt;/td&gt;
&lt;td&gt;无组织的追加服务数据。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CCUG&lt;/td&gt;
&lt;td&gt;关闭的用户组。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;八、数据命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CBST&lt;/td&gt;
&lt;td&gt;信差类型选择。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FCLASS&lt;/td&gt;
&lt;td&gt;选择模式。这个命令把模块设置成数据或传真操作的特殊模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CR&lt;/td&gt;
&lt;td&gt;服务报告控制。这个命令允许更为详细的服务报告。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CRC&lt;/td&gt;
&lt;td&gt;划分的结果代码。这个命令在呼叫到来时允许更为详细的铃声指示。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+ILRR&lt;/td&gt;
&lt;td&gt;本地DTE-DCE速率报告。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CRLP&lt;/td&gt;
&lt;td&gt;无线电通信线路协议参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+DOPT&lt;/td&gt;
&lt;td&gt;其他无线电通信线路参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT%C&lt;/td&gt;
&lt;td&gt;数据压缩选择。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+DS&lt;/td&gt;
&lt;td&gt;是否允许V42二度数据压缩。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+DR&lt;/td&gt;
&lt;td&gt;是否报告V42二度数据压缩。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT/N&lt;/td&gt;
&lt;td&gt;数据纠错选择。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;九、传真命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+FTM&lt;/td&gt;
&lt;td&gt;传送速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FRM&lt;/td&gt;
&lt;td&gt;接收速率&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FTH&lt;/td&gt;
&lt;td&gt;用HDLC协议设置传真传送速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FRH&lt;/td&gt;
&lt;td&gt;用HDLC协议设置传真接收速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FTS&lt;/td&gt;
&lt;td&gt;停止特定时期的传送并等待。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FRS&lt;/td&gt;
&lt;td&gt;接收沉默。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;十、第二类传真命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+FDT&lt;/td&gt;
&lt;td&gt;传送数据。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FDR&lt;/td&gt;
&lt;td&gt;接收数据。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FET&lt;/td&gt;
&lt;td&gt;传送页标点。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FPTS&lt;/td&gt;
&lt;td&gt;页转换状态参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FK&lt;/td&gt;
&lt;td&gt;终止会议。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FBOR&lt;/td&gt;
&lt;td&gt;页转换字节顺序。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FBUF&lt;/td&gt;
&lt;td&gt;缓冲大小报告。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FCQ&lt;/td&gt;
&lt;td&gt;控制拷贝质量检验。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FCR&lt;/td&gt;
&lt;td&gt;控制接收传真的能力。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FDIS&lt;/td&gt;
&lt;td&gt;当前会议参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FDCC&lt;/td&gt;
&lt;td&gt;设置DCE功能参数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FLID&lt;/td&gt;
&lt;td&gt;定义本地ID串。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+FPHCTO&lt;/td&gt;
&lt;td&gt;页转换超时参数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;十一、V24-V25命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+IPR&lt;/td&gt;
&lt;td&gt;确定DTE速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+ICF&lt;/td&gt;
&lt;td&gt;确定DTE-DCE特征结构。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+IFC&lt;/td&gt;
&lt;td&gt;控制DTE-DCE本地流量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;C&lt;/td&gt;
&lt;td&gt;设置DCD（数据携带检测）信号。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;D&lt;/td&gt;
&lt;td&gt;设置DTR（数据终端就绪）信号。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;S&lt;/td&gt;
&lt;td&gt;设置DST（数据设置就绪）信号。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATO&lt;/td&gt;
&lt;td&gt;回到联机模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATQ&lt;/td&gt;
&lt;td&gt;决定手机是否发送结果代码。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATV&lt;/td&gt;
&lt;td&gt;决定DCE响应格式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATZ&lt;/td&gt;
&lt;td&gt;恢复为缺省设置。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;W&lt;/td&gt;
&lt;td&gt;保存设置。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;T&lt;/td&gt;
&lt;td&gt;自动测试。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATE&lt;/td&gt;
&lt;td&gt;决定是否回显字符。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;F&lt;/td&gt;
&lt;td&gt;回到出厂时的设定。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT&amp;amp;V&lt;/td&gt;
&lt;td&gt;显示模块设置情况。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATI&lt;/td&gt;
&lt;td&gt;要求确认信息。这命令使GSM模块传送一行或多行特定的信息文字。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WMUX&lt;/td&gt;
&lt;td&gt;数据/命令多路复用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;十二、特殊AT命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+CCED&lt;/td&gt;
&lt;td&gt;电池环境描述。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CCED&lt;/td&gt;
&lt;td&gt;自动RxLev指示。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WIND&lt;/td&gt;
&lt;td&gt;一般指示。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+ALEA&lt;/td&gt;
&lt;td&gt;在ME和MSC之间的数据密码模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CRYPT&lt;/td&gt;
&lt;td&gt;数据密码模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+EXPKEY&lt;/td&gt;
&lt;td&gt;键管理。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPLMN&lt;/td&gt;
&lt;td&gt;在PLMN上的信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+ADC&lt;/td&gt;
&lt;td&gt;模拟数字转换度量。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMER&lt;/td&gt;
&lt;td&gt;移动设备事件报告。这个命令决定是否允许在键按下时是否主动发送结果代码。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WLPR&lt;/td&gt;
&lt;td&gt;读取语言偏好。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WLPW&lt;/td&gt;
&lt;td&gt;写语言偏好。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WIOR&lt;/td&gt;
&lt;td&gt;读取GPIO值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WIOW&lt;/td&gt;
&lt;td&gt;写GPIO值。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WIOM&lt;/td&gt;
&lt;td&gt;输入/输出管理。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WAC&lt;/td&gt;
&lt;td&gt;忽略命令。这个特殊命令允许忽略SMS、SS和可用的PLMN。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WTONE&lt;/td&gt;
&lt;td&gt;播放旋律。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WDTMF&lt;/td&gt;
&lt;td&gt;播放DTMF旋律。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WDWL&lt;/td&gt;
&lt;td&gt;下载模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WVR&lt;/td&gt;
&lt;td&gt;配置信差的声音速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WDR&lt;/td&gt;
&lt;td&gt;配置数据速率。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WHWV&lt;/td&gt;
&lt;td&gt;显示硬件的版本。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WDOP&lt;/td&gt;
&lt;td&gt;显示产品的出厂日期。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WSVG&lt;/td&gt;
&lt;td&gt;声音增益选择。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WSTR&lt;/td&gt;
&lt;td&gt;返回指定状态的状态。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WSCAN&lt;/td&gt;
&lt;td&gt;扫描。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WRIM&lt;/td&gt;
&lt;td&gt;设置或返回铃声指示模式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+W32K&lt;/td&gt;
&lt;td&gt;是否允许32kHz掉电方式。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WCDM&lt;/td&gt;
&lt;td&gt;改变缺省旋律。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WSSW&lt;/td&gt;
&lt;td&gt;显示内部软件版本。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WCCS&lt;/td&gt;
&lt;td&gt;编辑或显示订制性质设置表。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WLCK&lt;/td&gt;
&lt;td&gt;允许在特定的操作符上个性化ME。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPHS&lt;/td&gt;
&lt;td&gt;设置CPHS命令。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WBCM&lt;/td&gt;
&lt;td&gt;电池充电管理。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WFM&lt;/td&gt;
&lt;td&gt;特性管理。是否允许模块的某些特性，如带宽模式、SIM卡电压等。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WCFM&lt;/td&gt;
&lt;td&gt;商业特性管理。是否允许Wavecom特殊特性。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WMIR&lt;/td&gt;
&lt;td&gt;允许从当前存储的参数值创建定制的存储镜像。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WCDP&lt;/td&gt;
&lt;td&gt;改变旋律的缺省播放器。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+WMBN&lt;/td&gt;
&lt;td&gt;设置SIM卡中的不同邮箱号码。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;十三、SIM卡工具箱命令&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AT+STSF&lt;/td&gt;
&lt;td&gt;配置工具箱实用程序。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+STIN&lt;/td&gt;
&lt;td&gt;工具箱指示。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+STGI&lt;/td&gt;
&lt;td&gt;获得从SIM卡发来的预期命令的信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+STCR&lt;/td&gt;
&lt;td&gt;主动提供的结果：工具箱控制反应。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+STGR&lt;/td&gt;
&lt;td&gt;给出响应。允许程序或用户从主菜单上选择项目，或响应某些命令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;th&gt;col 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ASCI码指令&lt;/td&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;手机回答&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT回车&lt;/td&gt;
&lt;td&gt;握手&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATE&lt;/td&gt;
&lt;td&gt;简化显示&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLCC&lt;/td&gt;
&lt;td&gt;来电显示&lt;/td&gt;
&lt;td&gt;OK      来电话时串口输出：RING&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CLCC&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;+CLCC: 1,1,4,0,0,&amp;quot;05133082087&amp;quot;,129&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CNMI=1,1,2&lt;/td&gt;
&lt;td&gt;设置收到短消息提示&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+CMTI：“SM”，4&lt;/p&gt;

&lt;p&gt;4表示手机内短消息数量&lt;br /&gt;
ATD05133082087;                                                            | 拨打05133082087电话&lt;br /&gt;
AT+CMGL=0                                                                  | 读取电话上全部未读过的SMS消息&lt;br /&gt;
AT+CMGL=2                                                                  | 列出已有的短信息&lt;br /&gt;
AT+CMGL=4                                                                  | 读取全部SMS消息&lt;br /&gt;
AT+CMGR=X回车                                                                | 读取第X条短消息&lt;br /&gt;
AT+CMGF=0回车                                                                | 用PDU格式            |&lt;br /&gt;
AT+CMGD=X回车                                                                | 删除第X条短消息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                                       |                  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AT+CLIP=1,1                                                                | 来电自动显示的指令         | ERROR&lt;br /&gt;
来电话！                                                                       |                   | RING   +CLIP: 13306285091,129&lt;br /&gt;
AT+CMGS=6                                                                 |  发送短消息的字节数         | &amp;gt;&lt;br /&gt;
0891683108503105F011000B8131032&lt;/p&gt;

&lt;p&gt;65890F10008A90C665A4E0A597D00&lt;/p&gt;

&lt;p&gt;3100320033 | 1A   结束符号&lt;/p&gt;

&lt;p&gt;十六进制大写 | +CMGS: 45&lt;/p&gt;

&lt;p&gt;OK&lt;/p&gt;

&lt;p&gt;第45条短信发送成功！！！！！！&lt;br /&gt;
AT+CMGR=1                                                                  | 读取第1条短信           | 0：未读过，新的短信息&lt;/p&gt;

&lt;p&gt;1：已读过&lt;/p&gt;

&lt;p&gt;第二个1表示已读&lt;/p&gt;

&lt;p&gt;150 表示PDU数据的长度&lt;br /&gt;
1 表示读取第几条短信                                                               |  +CMGR: 1,1,,150&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col 1&lt;/th&gt;
&lt;th&gt;col 2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GSM07.05&lt;/td&gt;
&lt;td&gt;Function(功能)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATE0&lt;/td&gt;
&lt;td&gt;RESET&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSMS&lt;/td&gt;
&lt;td&gt;选择短信息服务&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CPMS&lt;/td&gt;
&lt;td&gt;选择短信息内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGF&lt;/td&gt;
&lt;td&gt;选择短信息格式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSCA&lt;/td&gt;
&lt;td&gt;短信息中心地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CNMI&lt;/td&gt;
&lt;td&gt;显示新收到的短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGR&lt;/td&gt;
&lt;td&gt;读短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGS&lt;/td&gt;
&lt;td&gt;发送短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGL&lt;/td&gt;
&lt;td&gt;列出SIM卡中短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMSS&lt;/td&gt;
&lt;td&gt;从SIM内存中发短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGW&lt;/td&gt;
&lt;td&gt;向SIM内存中写入待发短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CMGD&lt;/td&gt;
&lt;td&gt;删除SIM内存中的短信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AT+CSCB&lt;/td&gt;
&lt;td&gt;选择蜂窝广播信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/top5/archive/2012/04/17/2453924.html&#34; target=&#34;_blank&#34;&gt;http://www.cnblogs.com/top5/archive/2012/04/17/2453924.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.52rd.com/bbs/Archive_Thread.asp?SID=96226&amp;amp;TID=2&#34; target=&#34;_blank&#34;&gt;http://www.52rd.com/bbs/Archive_Thread.asp?SID=96226&amp;amp;TID=2&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>go for range</title>
            <link>/language/golang/go-for-range/</link>
            <pubDate>Mon, 06 Jan 2020 20:57:22 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-for-range/</guid>
            <description>&lt;p&gt;golang常用的遍历方式，有两种： for 和 for-range。 而for-range使用中有些坑常会遇到，今天我们一起来捋一捋。&lt;/p&gt;

&lt;p&gt;0x01 遍历取不到所有元素指针?&lt;br /&gt;
如下代码想从数组遍历获取一个指针元素切片集合&lt;/p&gt;

&lt;p&gt;arr := [2]int{1, 2}&lt;br /&gt;
res := []*int{}&lt;br /&gt;
for _, v := range arr {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res = append(res, &amp;amp;v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
//expect: 1 2&lt;br /&gt;
fmt.Println(*res[0],*res[1])&lt;br /&gt;
//but output: 2 2&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【取不到】 同样代码对切片[]int{1, 2}或map[int]int{1:1, 2:2}遍历也不符合预期。 问题出在哪里？&lt;/p&gt;

&lt;p&gt;通过查看go编译源码可以了解到, for-range其实是语法糖，内部调用还是for循环，初始化会拷贝带遍历的列表（如array，slice，map），然后每次遍历的v都是对同一个元素的遍历赋值。 也就是说如果直接对v取地址，最终只会拿到一个地址，而对应的值就是最后遍历的那个元素所附给v的值。对应伪代码如下：&lt;/p&gt;

&lt;p&gt;// len_temp := len(range)&lt;br /&gt;
// range_temp := range&lt;br /&gt;
// for index_temp = 0; index_temp &amp;lt; len_temp; index_temp++ {&lt;br /&gt;
//     value_temp = range_temp[index_temp]&lt;br /&gt;
//     index = index_temp&lt;br /&gt;
//     value = value_temp&lt;br /&gt;
//     original body&lt;br /&gt;
//   }&lt;br /&gt;
复制代码&lt;br /&gt;
那么怎么改？ 有两种&lt;/p&gt;

&lt;p&gt;使用局部变量拷贝v&lt;br /&gt;
for _, v := range arr {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//局部变量v替换了v，也可用别的局部变量名
v := v 
res = append(res, &amp;amp;v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
直接索引获取原来的元素&lt;br /&gt;
//这种其实退化为for循环的简写&lt;br /&gt;
for k := range arr {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res = append(res, &amp;amp;arr[k])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
理顺了这个问题后边的坑基本都好发现了，来迅速过一遍&lt;/p&gt;

&lt;p&gt;0x02 遍历会停止么？&lt;br /&gt;
v := []int{1, 2, 3}&lt;br /&gt;
for i := range v {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v = append(v, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【会】，因为遍历前对v做了拷贝，所以期间对原来v的修改不会反映到遍历中&lt;/p&gt;

&lt;p&gt;0x03 对大数组这样遍历有啥问题？&lt;br /&gt;
//假设值都为1，这里只赋值3个&lt;br /&gt;
var arr = [102400]int{1, 1, 1}&lt;br /&gt;
for i, n := range arr {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//just ignore i and n for simplify the example
_ = i 
_ = n 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【有问题】！遍历前的拷贝对内存是极大浪费啊 怎么优化？有两种&lt;/p&gt;

&lt;p&gt;对数组取地址遍历 for i, n := range &amp;amp;arr&lt;br /&gt;
对数组做切片引用 for i, n := range arr[:]&lt;br /&gt;
反思题：对大量元素的slice和map遍历为啥不会有内存浪费问题？ （提示，底层数据结构是否被拷贝）&lt;/p&gt;

&lt;p&gt;0x04 对大数组这样重置效率高么？&lt;br /&gt;
//假设值都为1，这里只赋值3个&lt;br /&gt;
var arr = [102400]int{1, 1, 1}&lt;br /&gt;
for i, _ := range &amp;amp;arr {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr[i] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【高】，这个要理解得知道go对这种重置元素值为默认值的遍历是有优化的, 详见go源码：memclrrange&lt;/p&gt;

&lt;p&gt;// Lower n into runtime·memclr if possible, for&lt;br /&gt;
// fast zeroing of slices and arrays (issue 5373).&lt;br /&gt;
// Look for instances of&lt;br /&gt;
//&lt;br /&gt;
// for i := range a {&lt;br /&gt;
//  a[i] = zero&lt;br /&gt;
// }&lt;br /&gt;
//&lt;br /&gt;
// in which the evaluation of a is side-effect-free.&lt;br /&gt;
复制代码&lt;br /&gt;
0x05 对map遍历时删除元素能遍历到么？&lt;br /&gt;
var m = map[int]int{1: 1, 2: 2, 3: 3}&lt;br /&gt;
//only del key once, and not del the current iteration key&lt;br /&gt;
var o sync.Once&lt;br /&gt;
for i := range m {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o.Do(func() {
    for _, key := range []int{1, 2, 3} {
        if key != i {
            fmt.Printf(&amp;quot;when iteration key %d, del key %d\n&amp;quot;, i, key)
            delete(m, key)
            break
        }
    }
})
fmt.Printf(&amp;quot;%d%d &amp;quot;, i, m[i])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【不会】 map内部实现是一个链式hash表，为保证每次无序，初始化时会随机一个遍历开始的位置, 这样，如果删除的元素开始没被遍历到（上边once.Do函数内保证第一次执行时删除未遍历的一个元素），那就后边就不会出现。&lt;/p&gt;

&lt;p&gt;0x06 对map遍历时新增元素能遍历到么？&lt;br /&gt;
var m = map[int]int{1:1, 2:2, 3:3}&lt;br /&gt;
for i, _ := range m {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m[4] = 4
fmt.Printf(&amp;quot;%d%d &amp;quot;, i, m[i])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【可能会】，输出中可能会有44。原因同上一个, 可以用以下代码验证&lt;/p&gt;

&lt;p&gt;var createElemDuringIterMap = func() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var m = map[int]int{1: 1, 2: 2, 3: 3}
for i := range m {
    m[4] = 4
    fmt.Printf(&amp;quot;%d%d &amp;quot;, i, m[i])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
for i := 0; i &amp;lt; 50; i++ {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//some line will not show 44, some line will
createElemDuringIterMap()
fmt.Println()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
0x07 这样遍历中起goroutine可以么？&lt;br /&gt;
var m = []int{1, 2, 3}&lt;br /&gt;
for i := range m {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go func() {
    fmt.Print(i)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
//block main 1ms to wait goroutine finished&lt;br /&gt;
time.Sleep(time.Millisecond)&lt;br /&gt;
复制代码&lt;br /&gt;
答案是【不可以】。预期输出0,1,2的某个组合，如012，210.. 结果是222. 同样是拷贝的问题 怎么解决&lt;/p&gt;

&lt;p&gt;以参数方式传入&lt;br /&gt;
for i := range m {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go func(i int) {
    fmt.Print(i)
}(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
使用局部变量拷贝&lt;br /&gt;
for i := range m {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i := i
go func() {
    fmt.Print(i)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
复制代码&lt;br /&gt;
发现没，一个简单的for-range，仔细剖析下来也是有不少有趣的地方。 希望剖析后能让你更进一步的了解。 如有问题欢迎关注留言交流。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>go 检查进程是否存在</title>
            <link>/language/golang/go-os-process/</link>
            <pubDate>Sat, 04 Jan 2020 16:01:45 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-os-process/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/42061521&#34; target=&#34;_blank&#34;&gt;golang程序优雅关闭与重启 - 知乎&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;golang中 &lt;code&gt;os.FindProcess(pid)&lt;/code&gt;并会做进程存在性检查，查看源码我们发现，他只是创建了一个进程id&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func findProcess(pid int) (p *Process, err error) {
	// NOOP for unix.
	return newProcess(pid, 0), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我通过对进程发送一个signal 来判断进程是否存活&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// Will return true if the process with PID exists.
func checkPid(pid int) bool {
	process, err := os.FindProcess(pid)
	if err != nil {
		log.Printf(&amp;quot;Unable to find the process %d&amp;quot;, pid)
		return false
	}

	err = process.Signal(syscall.Signal(0))
	log.Println(err)
	if err != nil {
		log.Printf(&amp;quot;Process %d is dead!&amp;quot;, pid)
		return false
	} else {
		log.Printf(&amp;quot;Process %d is alive!&amp;quot;, pid)
		return true
	}
	// return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;以守护进程启动服务器&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当使用 &lt;code&gt;bingo run daemon&lt;/code&gt;或者 &lt;code&gt;bingo run daemon start&lt;/code&gt;的时候，会触发 &lt;code&gt;DaemonInit()&lt;/code&gt;函数,内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;func DaemonInit() {
    // 得到存放pid文件的路径
    dir, _ := os.Getwd()
    pidFile = dir + &amp;quot;/&amp;quot; + Env.Get(&amp;quot;PID_FILE&amp;quot;)
    if os.Getenv(&amp;quot;__Daemon&amp;quot;) != &amp;quot;true&amp;quot; { //master
        cmd := &amp;quot;start&amp;quot; //缺省为start
        if l := len(os.Args); l &amp;gt; 2 {
            cmd = os.Args[l-1]
        }
        switch cmd {
        case &amp;quot;start&amp;quot;:
            if isRunning() {
                fmt.Printf(&amp;quot;\n %c[0;48;34m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+strconv.Itoa(pidVal)+&amp;quot;] Bingo is running&amp;quot;, 0x1B)
            } else { //fork daemon进程
                if err := forkDaemon(); err != nil {
                    fmt.Println(err)
                }
            }
        case &amp;quot;restart&amp;quot;: //重启:
            if !isRunning() {
                fmt.Printf(&amp;quot;\n %c[0;48;31m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[Warning]bingo not running&amp;quot;, 0x1B)
                restart(pidVal)
            } else {
                fmt.Printf(&amp;quot;\n %c[0;48;34m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+strconv.Itoa(pidVal)+&amp;quot;] Bingo restart now&amp;quot;, 0x1B)
                restart(pidVal)
            }
        case &amp;quot;stop&amp;quot;: //停止
            if !isRunning() {
                fmt.Printf(&amp;quot;\n %c[0;48;31m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[Warning]bingo not running&amp;quot;, 0x1B)
            } else {
                syscall.Kill(pidVal, syscall.SIGTERM) //kill
            }
        case &amp;quot;-h&amp;quot;:
            fmt.Println(&amp;quot;Usage: &amp;quot; + appName + &amp;quot; start|restart|stop&amp;quot;)
        default:   //其它不识别的参数
            return //返回至调用方
        }
        //主进程退出
        os.Exit(0)
    }
    go handleSignals()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先要获取&lt;code&gt;pidFile&lt;/code&gt; 这个文件主要是存储令程序运行时候的进程&lt;code&gt;pid&lt;/code&gt;,为什么要持久化&lt;code&gt;pid&lt;/code&gt;呢？是为了让多次程序运行过程中，判定是否有相同程序启动等操作&lt;/p&gt;

&lt;p&gt;之后要获取对应的操作 (start|restart|stop)，一个一个说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;case &lt;code&gt;start&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先使用 &lt;code&gt;isRunning()&lt;/code&gt;方法判断当前程序是否在运行，如何判断？就是从上面提到的 &lt;code&gt;pidFile&lt;/code&gt; 中取出进程号&lt;/p&gt;

&lt;p&gt;然后判断当前系统是否运行令这个进程，如果有，证明正在运行，返回 &lt;code&gt;true&lt;/code&gt;，反之返回 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果没有运行的话，调用 &lt;code&gt;forkDaemon()&lt;/code&gt; 函数启动程序，这个函数是整个功能的核心&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;func forkDaemon() error {
    args := os.Args
    os.Setenv(&amp;quot;__Daemon&amp;quot;, &amp;quot;true&amp;quot;)
    procAttr := &amp;amp;syscall.ProcAttr{
        Env:   os.Environ(),
        Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()},
    }
    pid, err := syscall.ForkExec(args[0], []string{args[0], &amp;quot;dev&amp;quot;}, procAttr)
    if err != nil {
        panic(err)
    }
    savePid(pid)
    fmt.Printf(&amp;quot;\n %c[0;48;32m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+strconv.Itoa(pid)+&amp;quot;] Bingo running...&amp;quot;, 0x1B)
    fmt.Println()
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;syscall&lt;/code&gt;包不支持win系统，也就意味着如果想在 &lt;code&gt;windows&lt;/code&gt;上做开发的话，只能使用虚拟机或者 &lt;code&gt;docker&lt;/code&gt;啦&lt;/p&gt;

&lt;p&gt;这里的主要功能就是，使用 &lt;code&gt;syscall.ForkExec()&lt;/code&gt;，&lt;code&gt;fork&lt;/code&gt; 一个进程出来&lt;/p&gt;

&lt;p&gt;运行这个进程所执行的命令就是这里的参数(因为我们的原始命令是 &lt;code&gt;go run start.go dev&lt;/code&gt;,所以这里的&lt;code&gt;args[0]&lt;/code&gt;实际上是 &lt;code&gt;start.go&lt;/code&gt;编译之后的二进制文件)&lt;/p&gt;

&lt;p&gt;然后再把 &lt;code&gt;fork&lt;/code&gt;出来的进程号保存在 &lt;code&gt;pidFile&lt;/code&gt;里&lt;/p&gt;

&lt;p&gt;所以最终运行的效果就是我们第一步时候说到的 &lt;code&gt;bingo run dev&lt;/code&gt; 达到的效果&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;case &lt;code&gt;restart&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个比较简单，通过 &lt;code&gt;pidFile&lt;/code&gt;判定程序是否正在运行，如果正在运行，才会继续向下执行&lt;/p&gt;

&lt;p&gt;函数体也比较简单，只有两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;syscall.Kill(pid, syscall.SIGHUP) //kill -HUP, daemon only时，会直接退出
forkDaemon()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行杀死这个进程 第二行开启一个新进程&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;case &lt;code&gt;stop&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里就一行代码，就是杀死这个进程&lt;/p&gt;

&lt;h2 id=&#34;额外的想法&#34;&gt;额外的想法&lt;/h2&gt;

&lt;p&gt;在开发过程中，每当有一丁点变动（比如更改来一丁点控制器），就需要再次执行一次 &lt;code&gt;bingo run daemon restart&lt;/code&gt; 命令，让新的改动生效，十分麻烦&lt;/p&gt;

&lt;p&gt;所以我又开发了 &lt;code&gt;bingo run watch&lt;/code&gt; 命令，监听改动，自动重启server服务器&lt;/p&gt;

&lt;p&gt;我使用了&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//github.com/fsnotify/fsnotify&#34; target=&#34;_blank&#34;&gt;github.com/fsnotify/fsnotify&lt;/a&gt;包来实现监听&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;func startWatchServer(port string, handler http.Handler) {
    // 监听目录变化，如果有变化，重启服务
    // 守护进程开启服务，主进程阻塞不断扫描当前目录，有任何更新，向守护进程传递信号，守护进程重启服务
    // 开启一个协程运行服务
    // 监听目录变化，有变化运行 bingo run daemon restart
    f, err := fsnotify.NewWatcher()
    if err != nil {
        panic(err)
    }
    defer f.Close()
    dir, _ := os.Getwd()
    wdDir = dir
    fileWatcher = f
    f.Add(dir)

    done := make(chan bool)

    go func() {
        procAttr := &amp;amp;syscall.ProcAttr{
            Env:   os.Environ(),
            Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()},
        }
        _, err := syscall.ForkExec(os.Args[0], []string{os.Args[0], &amp;quot;daemon&amp;quot;, &amp;quot;start&amp;quot;}, procAttr)
        if err != nil {
            fmt.Println(err)
        }
    }()

    go func() {
        for {
            select {
            case ev := &amp;lt;-f.Events:
                if ev.Op&amp;amp;fsnotify.Create == fsnotify.Create {
                    fmt.Printf(&amp;quot;\n %c[0;48;33m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)+&amp;quot;]created file:&amp;quot;+ev.Name, 0x1B)
                }
                if ev.Op&amp;amp;fsnotify.Remove == fsnotify.Remove {
                    fmt.Printf(&amp;quot;\n %c[0;48;31m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)+&amp;quot;]deleted file:&amp;quot;+ev.Name, 0x1B)
                }
                if ev.Op&amp;amp;fsnotify.Rename == fsnotify.Rename {
                    fmt.Printf(&amp;quot;\n %c[0;48;34m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)+&amp;quot;]renamed file:&amp;quot;+ev.Name, 0x1B)
                } else {
                    fmt.Printf(&amp;quot;\n %c[0;48;32m%s%c[0m&amp;quot;, 0x1B, &amp;quot;[&amp;quot;+time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)+&amp;quot;]modified file:&amp;quot;+ev.Name, 0x1B)
                }
                // 有变化，放入重启数组中
                restartSlice = append(restartSlice, 1)
            case err := &amp;lt;-f.Errors:
                fmt.Println(&amp;quot;error:&amp;quot;, err)
            }
        }
    }()

    // 准备重启守护进程
    go restartDaemonServer()

    &amp;lt;-done
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先按照 &lt;code&gt;fsnotify&lt;/code&gt;的文档，创建一个 &lt;code&gt;watcher&lt;/code&gt;，然后添加监听目录（这里只是监听目录下的文件，不能监听子目录）&lt;/p&gt;

&lt;p&gt;然后开启两个协程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;监听文件变化，如果有文件变化，把变化的个数写入一个 &lt;code&gt;slice&lt;/code&gt; 里，这是一个阻塞的 &lt;code&gt;for&lt;/code&gt;循环&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每隔1s中查看一次记录文件变化的 &lt;code&gt;slice&lt;/code&gt;， 如果有的话，就重启服务器，并重新设置监听目录，然后清空 &lt;code&gt;slice&lt;/code&gt; ，否则跳过&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;递归遍历子目录，达到监听整个工程目录的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;func listeningWatcherDir(dir string) {
    filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
        dir, _ := os.Getwd()
        pidFile = dir + &amp;quot;/&amp;quot; + Env.Get(&amp;quot;PID_FILE&amp;quot;)
        fileWatcher.Add(path)

        // 这里不能监听 pidFile，否则每次重启都会导致pidFile有更新，会不断的触发重启功能
        fileWatcher.Remove(pidFile)
        return nil
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里这个 &lt;code&gt;slice&lt;/code&gt; 的作用也就是为了避免当一次保存更新了多个文件的时候，也重启了多次服务器&lt;/p&gt;

&lt;p&gt;下面看看重启服务器的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-language-go&#34;&gt;go func() {
                // 执行重启命令
                cmd := exec.Command(&amp;quot;bingo&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;daemon&amp;quot;, &amp;quot;restart&amp;quot;)
                stdout, err := cmd.StdoutPipe()
                if err != nil {
                    fmt.Println(err)
                }
                defer stdout.Close()

                if err := cmd.Start(); err != nil {
                    panic(err)
                }
                reader := bufio.NewReader(stdout)
                //实时循环读取输出流中的一行内容
                for {
                    line, err2 := reader.ReadString(&#39;\n&#39;)
                    if err2 != nil || io.EOF == err2 {
                        break
                    }
                    fmt.Print(line)
                }

                if err := cmd.Wait(); err != nil {
                    fmt.Println(err)
                }
                opBytes, _ := ioutil.ReadAll(stdout)
                fmt.Print(string(opBytes))

            }()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;exec.Command()&lt;/code&gt; 方法得到一个 &lt;code&gt;cmd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;调用 &lt;code&gt;cmd.Stdoutput()&lt;/code&gt; 得到一个输出管道，命令打印出来的数据都会从这个管道流出来&lt;/p&gt;

&lt;p&gt;然后使用 &lt;code&gt;reader := bufio.NewReader(stdout)&lt;/code&gt; 从管道中读出数据&lt;/p&gt;

&lt;p&gt;用一个阻塞的&lt;code&gt;for&lt;/code&gt;循环，不断的从管道中读出数据，以 &lt;code&gt;\n&lt;/code&gt; 为一行，一行一行的读&lt;/p&gt;

&lt;p&gt;并打印在控制台里，达到输出的效果，如果这几行不写的话，在新的进程里的 &lt;code&gt;fmt.Println()&lt;/code&gt;方法打印出来的数据将无法显示在控制台上.&lt;/p&gt;

&lt;p&gt;就酱,最后贴下项目链接 &lt;a href=&#34;https://github.com/silsuer/bingo&#34; target=&#34;_blank&#34;&gt;silsuer/bingo&lt;/a&gt;  ，欢迎star，欢迎PR，欢迎提意见&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>go image colors</title>
            <link>/language/golang/go-image-colors/</link>
            <pubDate>Fri, 27 Dec 2019 19:57:57 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-image-colors/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package colors

import &amp;quot;image/color&amp;quot;

var (
	//Black RGBA color
	Black = color.RGBA{R: 0, G: 0, B: 0, A: 255}
	//White RGBA color
	White = color.RGBA{R: 255, G: 255, B: 255, A: 255}
	//Red RGBA color
	Red = color.RGBA{R: 255, G: 0, B: 0, A: 255}
	//Lime RGBA color
	Lime = color.RGBA{R: 0, G: 255, B: 0, A: 255}
	//Blue RGBA color
	Blue = color.RGBA{R: 0, G: 0, B: 255, A: 255}
	//Yellow RGBA color
	Yellow = color.RGBA{R: 255, G: 255, B: 0, A: 255}
	//Cyan RGBA color
	Cyan = color.RGBA{R: 0, G: 255, B: 255, A: 255}
	//Aqua RGBA color
	Aqua = color.RGBA{R: 0, G: 255, B: 255, A: 255}
	//Magenta RGBA color
	Magenta = color.RGBA{R: 255, G: 0, B: 255, A: 255}
	//Fuchsia RGBA color
	Fuchsia = color.RGBA{R: 255, G: 0, B: 255, A: 255}
	//Silver RGBA color
	Silver = color.RGBA{R: 192, G: 192, B: 192, A: 255}
	//Gray RGBA color
	Gray = color.RGBA{R: 128, G: 128, B: 128, A: 255}
	//Maroon RGBA color
	Maroon = color.RGBA{R: 128, G: 0, B: 0, A: 255}
	//Olive RGBA color
	Olive = color.RGBA{R: 128, G: 128, B: 0, A: 255}
	//Green RGBA color
	Green = color.RGBA{R: 0, G: 128, B: 0, A: 255}
	//Purple RGBA color
	Purple = color.RGBA{R: 128, G: 0, B: 128, A: 255}
	//Teal RGBA color
	Teal = color.RGBA{R: 0, G: 128, B: 128, A: 255}
	//Navy RGBA color
	Navy = color.RGBA{R: 0, G: 0, B: 128, A: 255}
	//DarkRed RGBA color
	DarkRed = color.RGBA{R: 139, G: 0, B: 0, A: 255}
	//Brown RGBA color
	Brown = color.RGBA{R: 165, G: 42, B: 42, A: 255}
	//Firebrick RGBA color
	Firebrick = color.RGBA{R: 178, G: 34, B: 34, A: 255}
	//Crimson RGBA color
	Crimson = color.RGBA{R: 220, G: 20, B: 60, A: 255}
	//Tomato RGBA color
	Tomato = color.RGBA{R: 255, G: 99, B: 71, A: 255}
	//Coral RGBA color
	Coral = color.RGBA{R: 255, G: 127, B: 80, A: 255}
	//IndianRed RGBA color
	IndianRed = color.RGBA{R: 205, G: 92, B: 92, A: 255}
	//LightCoral RGBA color
	LightCoral = color.RGBA{R: 240, G: 128, B: 128, A: 255}
	//DarkSalmon RGBA color
	DarkSalmon = color.RGBA{R: 233, G: 150, B: 122, A: 255}
	//Salmon RGBA color
	Salmon = color.RGBA{R: 250, G: 128, B: 114, A: 255}
	//LightSalmon RGBA color
	LightSalmon = color.RGBA{R: 255, G: 160, B: 122, A: 255}
	//OrangeRed RGBA color
	OrangeRed = color.RGBA{R: 255, G: 69, B: 0, A: 255}
	//DarkOrange RGBA color
	DarkOrange = color.RGBA{R: 255, G: 140, B: 0, A: 255}
	//Orange RGBA color
	Orange = color.RGBA{R: 255, G: 165, B: 0, A: 255}
	//Gold RGBA color
	Gold = color.RGBA{R: 255, G: 215, B: 0, A: 255}
	//DarkGoldenRod RGBA color
	DarkGoldenRod = color.RGBA{R: 184, G: 134, B: 11, A: 255}
	//GoldenRod RGBA color
	GoldenRod = color.RGBA{R: 218, G: 165, B: 32, A: 255}
	//PaleGoldenRod RGBA color
	PaleGoldenRod = color.RGBA{R: 238, G: 232, B: 170, A: 255}
	//DarkKhaki RGBA color
	DarkKhaki = color.RGBA{R: 189, G: 183, B: 107, A: 255}
	//Khaki RGBA color
	Khaki = color.RGBA{R: 240, G: 230, B: 140, A: 255}
	//YellowGreen RGBA color
	YellowGreen = color.RGBA{R: 154, G: 205, B: 50, A: 255}
	//DarkOliveGreen RGBA color
	DarkOliveGreen = color.RGBA{R: 85, G: 107, B: 47, A: 255}
	//OliveDrab RGBA color
	OliveDrab = color.RGBA{R: 107, G: 142, B: 35, A: 255}
	//LawnGreen RGBA color
	LawnGreen = color.RGBA{R: 124, G: 252, B: 0, A: 255}
	//ChartReuse RGBA color
	ChartReuse = color.RGBA{R: 127, G: 255, B: 0, A: 255}
	//GreenYellow RGBA color
	GreenYellow = color.RGBA{R: 173, G: 255, B: 47, A: 255}
	//DarkGreen RGBA color
	DarkGreen = color.RGBA{R: 0, G: 100, B: 0, A: 255}
	//ForestGreen RGBA color
	ForestGreen = color.RGBA{R: 34, G: 139, B: 34, A: 255}
	//LimeGreen RGBA color
	LimeGreen = color.RGBA{R: 50, G: 205, B: 50, A: 255}
	//LightGreen RGBA color
	LightGreen = color.RGBA{R: 144, G: 238, B: 144, A: 255}
	//PaleGreen RGBA color
	PaleGreen = color.RGBA{R: 152, G: 251, B: 152, A: 255}
	//DarkSeaGreen RGBA color
	DarkSeaGreen = color.RGBA{R: 143, G: 188, B: 143, A: 255}
	//MediumSpringGreen RGBA color
	MediumSpringGreen = color.RGBA{R: 0, G: 250, B: 154, A: 255}
	//SpringGreen RGBA color
	SpringGreen = color.RGBA{R: 0, G: 255, B: 127, A: 255}
	//SeaGreen RGBA color
	SeaGreen = color.RGBA{R: 46, G: 139, B: 87, A: 255}
	//MediumAquaMarine RGBA color
	MediumAquaMarine = color.RGBA{R: 102, G: 205, B: 170, A: 255}
	//MediumSeaGreen RGBA color
	MediumSeaGreen = color.RGBA{R: 60, G: 179, B: 113, A: 255}
	//LightSeaGreen RGBA color
	LightSeaGreen = color.RGBA{R: 32, G: 178, B: 170, A: 255}
	//DarkSlateGray RGBA color
	DarkSlateGray = color.RGBA{R: 47, G: 79, B: 79, A: 255}
	//DarkCyan RGBA color
	DarkCyan = color.RGBA{R: 0, G: 139, B: 139, A: 255}
	//LightCyan RGBA color
	LightCyan = color.RGBA{R: 224, G: 255, B: 255, A: 255}
	//DarkTurquoise RGBA color
	DarkTurquoise = color.RGBA{R: 0, G: 206, B: 209, A: 255}
	//Turquoise RGBA color
	Turquoise = color.RGBA{R: 64, G: 224, B: 208, A: 255}
	//MediumTurquoise RGBA color
	MediumTurquoise = color.RGBA{R: 72, G: 209, B: 204, A: 255}
	//PaleTurquoise RGBA color
	PaleTurquoise = color.RGBA{R: 175, G: 238, B: 238, A: 255}
	//AquaMarine RGBA color
	AquaMarine = color.RGBA{R: 127, G: 255, B: 212, A: 255}
	//PowderBlue RGBA color
	PowderBlue = color.RGBA{R: 176, G: 224, B: 230, A: 255}
	//CadetBlue RGBA color
	CadetBlue = color.RGBA{R: 95, G: 158, B: 160, A: 255}
	//SteelBlue RGBA color
	SteelBlue = color.RGBA{R: 70, G: 130, B: 180, A: 255}
	//CornFlowerBlue RGBA color
	CornFlowerBlue = color.RGBA{R: 100, G: 149, B: 237, A: 255}
	//DeepSkyBlue RGBA color
	DeepSkyBlue = color.RGBA{R: 0, G: 191, B: 255, A: 255}
	//DodgerBlue RGBA color
	DodgerBlue = color.RGBA{R: 30, G: 144, B: 255, A: 255}
	//LightBlue RGBA color
	LightBlue = color.RGBA{R: 173, G: 216, B: 230, A: 255}
	//SkyBlue RGBA color
	SkyBlue = color.RGBA{R: 135, G: 206, B: 235, A: 255}
	//LightSkyBlue RGBA color
	LightSkyBlue = color.RGBA{R: 135, G: 206, B: 250, A: 255}
	//MidnightBlue RGBA color
	MidnightBlue = color.RGBA{R: 25, G: 25, B: 112, A: 255}
	//DarkBlue RGBA color
	DarkBlue = color.RGBA{R: 0, G: 0, B: 139, A: 255}
	//MediumBlue RGBA color
	MediumBlue = color.RGBA{R: 0, G: 0, B: 205, A: 255}
	//RoyalBlue RGBA color
	RoyalBlue = color.RGBA{R: 65, G: 105, B: 225, A: 255}
	//BlueViolet RGBA color
	BlueViolet = color.RGBA{R: 138, G: 43, B: 226, A: 255}
	//Indigo RGBA color
	Indigo = color.RGBA{R: 75, G: 0, B: 130, A: 255}
	//DarkSlateBlue RGBA color
	DarkSlateBlue = color.RGBA{R: 72, G: 61, B: 139, A: 255}
	//SlateBlue RGBA color
	SlateBlue = color.RGBA{R: 106, G: 90, B: 205, A: 255}
	//MediumSlateBlue RGBA color
	MediumSlateBlue = color.RGBA{R: 123, G: 104, B: 238, A: 255}
	//MediumPurple RGBA color
	MediumPurple = color.RGBA{R: 147, G: 112, B: 219, A: 255}
	//DarkMagenta RGBA color
	DarkMagenta = color.RGBA{R: 139, G: 0, B: 139, A: 255}
	//DarkViolet RGBA color
	DarkViolet = color.RGBA{R: 148, G: 0, B: 211, A: 255}
	//DarkOrchid RGBA color
	DarkOrchid = color.RGBA{R: 153, G: 50, B: 204, A: 255}
	//MediumOrchid RGBA color
	MediumOrchid = color.RGBA{R: 186, G: 85, B: 211, A: 255}
	//Thistle RGBA color
	Thistle = color.RGBA{R: 216, G: 191, B: 216, A: 255}
	//Plum RGBA color
	Plum = color.RGBA{R: 221, G: 160, B: 221, A: 255}
	//Violet RGBA color
	Violet = color.RGBA{R: 238, G: 130, B: 238, A: 255}
	//Orchid RGBA color
	Orchid = color.RGBA{R: 218, G: 112, B: 214, A: 255}
	//MediumVioletRed RGBA color
	MediumVioletRed = color.RGBA{R: 199, G: 21, B: 133, A: 255}
	//PaleVioletRed RGBA color
	PaleVioletRed = color.RGBA{R: 219, G: 112, B: 147, A: 255}
	//DeepPink RGBA color
	DeepPink = color.RGBA{R: 255, G: 20, B: 147, A: 255}
	//HotPink RGBA color
	HotPink = color.RGBA{R: 255, G: 105, B: 180, A: 255}
	//LightPink RGBA color
	LightPink = color.RGBA{R: 255, G: 182, B: 193, A: 255}
	//Pink RGBA color
	Pink = color.RGBA{R: 255, G: 192, B: 203, A: 255}
	//AntiqueWhite RGBA color
	AntiqueWhite = color.RGBA{R: 250, G: 235, B: 215, A: 255}
	//Beige RGBA color
	Beige = color.RGBA{R: 245, G: 245, B: 220, A: 255}
	//Bisque RGBA color
	Bisque = color.RGBA{R: 255, G: 228, B: 196, A: 255}
	//BlanchedAlmond RGBA color
	BlanchedAlmond = color.RGBA{R: 255, G: 235, B: 205, A: 255}
	//Wheat RGBA color
	Wheat = color.RGBA{R: 245, G: 222, B: 179, A: 255}
	//CornSilk RGBA color
	CornSilk = color.RGBA{R: 255, G: 248, B: 220, A: 255}
	//LemonChiffon RGBA color
	LemonChiffon = color.RGBA{R: 255, G: 250, B: 205, A: 255}
	//LightGoldenRod RGBA color
	LightGoldenRod = color.RGBA{R: 250, G: 250, B: 210, A: 255}
	//LightYellow RGBA color
	LightYellow = color.RGBA{R: 255, G: 255, B: 224, A: 255}
	//SaddleBrown RGBA color
	SaddleBrown = color.RGBA{R: 139, G: 69, B: 19, A: 255}
	//Sienna RGBA color
	Sienna = color.RGBA{R: 160, G: 82, B: 45, A: 255}
	//Chocolate RGBA color
	Chocolate = color.RGBA{R: 210, G: 105, B: 30, A: 255}
	//Peru RGBA color
	Peru = color.RGBA{R: 205, G: 133, B: 63, A: 255}
	//SandyBrown RGBA color
	SandyBrown = color.RGBA{R: 244, G: 164, B: 96, A: 255}
	//BurlyWood RGBA color
	BurlyWood = color.RGBA{R: 222, G: 184, B: 135, A: 255}
	//Tan RGBA color
	Tan = color.RGBA{R: 210, G: 180, B: 140, A: 255}
	//RosyBrown RGBA color
	RosyBrown = color.RGBA{R: 188, G: 143, B: 143, A: 255}
	//Moccasin RGBA color
	Moccasin = color.RGBA{R: 255, G: 228, B: 181, A: 255}
	//NavajoWhite RGBA color
	NavajoWhite = color.RGBA{R: 255, G: 222, B: 173, A: 255}
	//PeachPuff RGBA color
	PeachPuff = color.RGBA{R: 255, G: 218, B: 185, A: 255}
	//MistyRose RGBA color
	MistyRose = color.RGBA{R: 255, G: 228, B: 225, A: 255}
	//LavenderBlush RGBA color
	LavenderBlush = color.RGBA{R: 255, G: 240, B: 245, A: 255}
	//Linen RGBA color
	Linen = color.RGBA{R: 250, G: 240, B: 230, A: 255}
	//OldLace RGBA color
	OldLace = color.RGBA{R: 253, G: 245, B: 230, A: 255}
	//PapayaWhip RGBA color
	PapayaWhip = color.RGBA{R: 255, G: 239, B: 213, A: 255}
	//SeaShell RGBA color
	SeaShell = color.RGBA{R: 255, G: 245, B: 238, A: 255}
	//MintCream RGBA color
	MintCream = color.RGBA{R: 245, G: 255, B: 250, A: 255}
	//SlateGray RGBA color
	SlateGray = color.RGBA{R: 112, G: 128, B: 144, A: 255}
	//LightSlateGray RGBA color
	LightSlateGray = color.RGBA{R: 119, G: 136, B: 153, A: 255}
	//LightSteelBlue RGBA color
	LightSteelBlue = color.RGBA{R: 176, G: 196, B: 222, A: 255}
	//Lavender RGBA color
	Lavender = color.RGBA{R: 230, G: 230, B: 250, A: 255}
	//FloralWhite RGBA color
	FloralWhite = color.RGBA{R: 255, G: 250, B: 240, A: 255}
	//AliceBlue RGBA color
	AliceBlue = color.RGBA{R: 240, G: 248, B: 255, A: 255}
	//GhostWhite RGBA color
	GhostWhite = color.RGBA{R: 248, G: 248, B: 255, A: 255}
	//Honeydew RGBA color
	Honeydew = color.RGBA{R: 240, G: 255, B: 240, A: 255}
	//Ivory RGBA color
	Ivory = color.RGBA{R: 255, G: 255, B: 240, A: 255}
	//Azure RGBA color
	Azure = color.RGBA{R: 240, G: 255, B: 255, A: 255}
	//Snow RGBA color
	Snow = color.RGBA{R: 255, G: 250, B: 250, A: 255}
	//DimGray RGBA color
	DimGray = color.RGBA{R: 105, G: 105, B: 105, A: 255}
	//DimGrey RGBA color
	DimGrey = color.RGBA{R: 105, G: 105, B: 105, A: 255}
	//Grey RGBA color
	Grey = color.RGBA{R: 128, G: 128, B: 128, A: 255}
	//DarkGray RGBA color
	DarkGray = color.RGBA{R: 169, G: 169, B: 169, A: 255}
	//DarkGrey RGBA color
	DarkGrey = color.RGBA{R: 169, G: 169, B: 169, A: 255}
	//LightGray RGBA color
	LightGray = color.RGBA{R: 211, G: 211, B: 211, A: 255}
	//LightGrey RGBA color
	LightGrey = color.RGBA{R: 211, G: 211, B: 211, A: 255}
	//Gainsboro RGBA color
	Gainsboro = color.RGBA{R: 220, G: 220, B: 220, A: 255}
	//WhiteSmoke RGBA color
	WhiteSmoke = color.RGBA{R: 245, G: 245, B: 245, A: 255}
)

&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>go machine id</title>
            <link>/language/golang/go-machine-id/</link>
            <pubDate>Wed, 25 Dec 2019 15:50:29 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-machine-id/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package main

import (
  &amp;quot;crypto/hmac&amp;quot;
  &amp;quot;crypto/sha256&amp;quot;
  &amp;quot;fmt&amp;quot;
  &amp;quot;github.com/denisbrodbeck/machineid&amp;quot;
)

const appKey = &amp;quot;WowSuchNiceApp&amp;quot;

func main() {
  id, _ := machineid.ID()
  fmt.Println(protect(appKey, id))
  // Output: dbabdb7baa54845f9bec96e2e8a87be2d01794c66fdebac3df7edd857f3d9f97
}

func protect(appID, id string) string {
  mac := hmac.New(sha256.New, []byte(id))
  mac.Write([]byte(appID))
  return fmt.Sprintf(&amp;quot;%x&amp;quot;, mac.Sum(nil))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>linux hostid</title>
            <link>/linux/linux-hostid/</link>
            <pubDate>Wed, 25 Dec 2019 15:41:24 CST</pubDate>
            <author>rinetd</author>
            <guid>/linux/linux-hostid/</guid>
            <description>&lt;p&gt;我们知道hostid作为一台主机的唯一标示符(hostname本身可能重复),而许多付费软件通过鉴别hostid发给相关的license. hostname的修改较为简单，只需要修改/etc/sysconfig/network中的hostname并重启即可。 hostid的修改就不那么方便了，下面介绍一种方法： 编辑一个c文件，是的之后你还需要修改它,就叫做host.c吧！&lt;/p&gt;

&lt;p&gt;ifconfig&lt;br /&gt;
eth0      Link encap:Ethernet  HWaddr 00:0C:29:A6:A7:1C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      inet addr:192.168.233.128  Bcast:192.168.233.255  Mask:255.255.255.0
      inet6 addr: fe80::20c:29ff:fea6:a71c/64 Scope:Link
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[root@pr ~]# hostid&lt;br /&gt;
a8c080e9&lt;/p&gt;

&lt;p&gt;将192.168.233.128 转换成16进制就是 c0.a8.e9.80，好像找到规律了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
 
int main() {
long id,res;
 
// get real (default) hostid
id = gethostid();
printf(&amp;quot;current hostid is: %x\n&amp;quot;,id);
// set new hostid if is superuser
res = sethostid(0xa090d01);                    //括号内填入你想要的hostid
if (res == 0) printf(&amp;quot;if result is zero - success! (%d) \n&amp;quot;,res);
// check if it is changed....
id = gethostid();
printf(&amp;quot;current hostid is: %x ;-PPPppppp\n&amp;quot;,id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后我们需要编译它&lt;/p&gt;

&lt;p&gt;[root@pmsora ~]# cc host.c&lt;br /&gt;
[root@pmsora ~]# ./a.out                   //编译后运行&lt;br /&gt;
current hostid is: a090d01&lt;br /&gt;
if result is zero - success! (0)&lt;br /&gt;
current hostid is: a090d01 ;-PPPppppp&lt;br /&gt;
[root@pmsora ~]# hostid&lt;br /&gt;
0a090d01&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go Graphics (gg) 类似于draw2d golang图像处理库</title>
            <link>/language/golang/go-image-gg2d/</link>
            <pubDate>Tue, 24 Dec 2019 18:01:48 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-image-gg2d/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://stackoverrun.com/cn/q/7966351&#34; target=&#34;_blank&#34;&gt;https://stackoverrun.com/cn/q/7966351&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Rect(x1, y1, x2, y2, thickness int, img *image.RGBA) { 
    col := color.RGBA{0, 0, 0, 255} 

    for t:=0; t&amp;lt;thickness; t++ { 
     // draw horizontal lines 
     for x := x1; x&amp;lt;= x2; x++ { 
      img.Set(x, y1+t, col) 
      img.Set(x, y2-t, col) 
     } 
     // draw vertical lines 
     for y := y1; y &amp;lt;= y2; y++ { 
      img.Set(x1+t, y, col) 
      img.Set(x2-t, y, col) 
     } 
    } 
} 


// handler to test 
func draw(w http.ResponseWriter, r *http.Request) { 
    img := image.NewRGBA(image.Rect(0, 0, 1200, 1800)) 
    Rect(5, 5, 1195, 1795, 2, img) 
    png.Encode(w, img) 
} 



// HLine draws a horizontal line 
func HLine(x1, y, x2 int) { 
    for ; x1 &amp;lt;= x2; x1++ { 
     img.Set(x1, y, col) 
    } 
} 

// VLine draws a veritcal line 
func VLine(x, y1, y2 int) { 
    for ; y1 &amp;lt;= y2; y1++ { 
     img.Set(x, y1, col) 
    } 
} 

// Rect draws a rectangle utilizing HLine() and VLine() 
func Rect(x1, y1, x2, y2 int) { 
    HLine(x1, y1, x2) 
    HLine(x1, y2, x2) 
    VLine(x1, y1, y2) 
    VLine(x2, y1, y2) 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;go-graphics&#34;&gt;Go Graphics&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;gg&lt;/code&gt; is a library for rendering 2D graphics in pure Go.&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/fogleman/gg
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/fogleman/gg&#34; target=&#34;_blank&#34;&gt;https://godoc.org/github.com/fogleman/gg&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hello-circle&#34;&gt;Hello, Circle!&lt;/h2&gt;

&lt;p&gt;Look how easy!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/fogleman/gg&amp;quot;

func main() {
    dc := gg.NewContext(1000, 1000)
    dc.DrawCircle(500, 500, 400)
    dc.SetRGB(0, 0, 0)
    dc.Fill()
    dc.SavePNG(&amp;quot;out.png&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;p&gt;There are &lt;a href=&#34;https://github.com/fogleman/gg/tree/master/examples&#34; target=&#34;_blank&#34;&gt;lots of examples&lt;/a&gt; included. They&#39;re mostly for testing the code, but they&#39;re good for learning, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/tMFoyzu.png&#34; alt=&#34;Examples&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;creating-contexts&#34;&gt;Creating Contexts&lt;/h2&gt;

&lt;p&gt;There are a few ways of creating a context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;NewContext(width, height int) *Context
NewContextForImage(im image.Image) *Context
NewContextForRGBA(im *image.RGBA) *Context
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;drawing-functions&#34;&gt;Drawing Functions&lt;/h2&gt;

&lt;p&gt;Ever used a graphics library that didn&#39;t have functions for drawing rectangles&lt;br /&gt;
or circles? What a pain!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;DrawPoint(x, y, r float64)
DrawLine(x1, y1, x2, y2 float64)
DrawRectangle(x, y, w, h float64)
DrawRoundedRectangle(x, y, w, h, r float64)
DrawCircle(x, y, r float64)
DrawArc(x, y, r, angle1, angle2 float64)
DrawEllipse(x, y, rx, ry float64)
DrawEllipticalArc(x, y, rx, ry, angle1, angle2 float64)
DrawRegularPolygon(n int, x, y, r, rotation float64)
DrawImage(im image.Image, x, y int)
DrawImageAnchored(im image.Image, x, y int, ax, ay float64)
SetPixel(x, y int)

MoveTo(x, y float64)
LineTo(x, y float64)
QuadraticTo(x1, y1, x2, y2 float64)
CubicTo(x1, y1, x2, y2, x3, y3 float64)
ClosePath()
ClearPath()
NewSubPath()

Clear()
Stroke()
Fill()
StrokePreserve()
FillPreserve()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is often desired to center an image at a point. Use &lt;code&gt;DrawImageAnchored&lt;/code&gt; with &lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;ay&lt;/code&gt; set to 0.5 to do this. Use 0 to left or top align. Use 1 to right or bottom align. &lt;code&gt;DrawStringAnchored&lt;/code&gt; does the same for text, so you don&#39;t need to call &lt;code&gt;MeasureString&lt;/code&gt; yourself.&lt;/p&gt;

&lt;h2 id=&#34;text-functions&#34;&gt;Text Functions&lt;/h2&gt;

&lt;p&gt;It will even do word wrap for you!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;DrawString(s string, x, y float64)
DrawStringAnchored(s string, x, y, ax, ay float64)
DrawStringWrapped(s string, x, y, ax, ay, width, lineSpacing float64, align Align)
MeasureString(s string) (w, h float64)
MeasureMultilineString(s string, lineSpacing float64) (w, h float64)
WordWrap(s string, w float64) []string
SetFontFace(fontFace font.Face)
LoadFontFace(path string, points float64) error
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;color-functions&#34;&gt;Color Functions&lt;/h2&gt;

&lt;p&gt;Colors can be set in several different ways for your convenience.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;SetRGB(r, g, b float64)
SetRGBA(r, g, b, a float64)
SetRGB255(r, g, b int)
SetRGBA255(r, g, b, a int)
SetColor(c color.Color)
SetHexColor(x string)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;stroke-fill-options&#34;&gt;Stroke &amp;amp; Fill Options&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;SetLineWidth(lineWidth float64)
SetLineCap(lineCap LineCap)
SetLineJoin(lineJoin LineJoin)
SetDash(dashes ...float64)
SetDashOffset(offset float64)
SetFillRule(fillRule FillRule)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gradients-patterns&#34;&gt;Gradients &amp;amp; Patterns&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;gg&lt;/code&gt; supports linear and radial gradients and surface patterns. You can also implement your own patterns.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;SetFillStyle(pattern Pattern)
SetStrokeStyle(pattern Pattern)
NewSolidPattern(color color.Color)
NewLinearGradient(x0, y0, x1, y1 float64)
NewRadialGradient(x0, y0, r0, x1, y1, r1 float64)
NewSurfacePattern(im image.Image, op RepeatOp)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;transformation-functions&#34;&gt;Transformation Functions&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Identity()
Translate(x, y float64)
Scale(x, y float64)
Rotate(angle float64)
Shear(x, y float64)
ScaleAbout(sx, sy, x, y float64)
RotateAbout(angle, x, y float64)
ShearAbout(sx, sy, x, y float64)
TransformPoint(x, y float64) (tx, ty float64)
InvertY()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is often desired to rotate or scale about a point that is not the origin. The functions &lt;code&gt;RotateAbout&lt;/code&gt;, &lt;code&gt;ScaleAbout&lt;/code&gt;, &lt;code&gt;ShearAbout&lt;/code&gt; are provided as a convenience.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;InvertY&lt;/code&gt; is provided in case Y should increase from bottom to top vs. the default top to bottom.&lt;/p&gt;

&lt;h2 id=&#34;stack-functions&#34;&gt;Stack Functions&lt;/h2&gt;

&lt;p&gt;Save and restore the state of the context. These can be nested.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Push()
Pop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;clipping-functions&#34;&gt;Clipping Functions&lt;/h2&gt;

&lt;p&gt;Use clipping regions to restrict drawing operations to an area that you&lt;br /&gt;
defined using paths.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Clip()
ClipPreserve()
ResetClip()
AsMask() *image.Alpha
SetMask(mask *image.Alpha)
InvertMask()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;helper-functions&#34;&gt;Helper Functions&lt;/h2&gt;

&lt;p&gt;Sometimes you just don&#39;t want to write these yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Radians(degrees float64) float64
Degrees(radians float64) float64
LoadImage(path string) (image.Image, error)
LoadPNG(path string) (image.Image, error)
SavePNG(path string, im image.Image) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/fsUvnPB.png&#34; alt=&#34;Separator&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;another-example&#34;&gt;Another Example&lt;/h2&gt;

&lt;p&gt;See the output of this example below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;github.com/fogleman/gg&amp;quot;

func main() {
	const S = 1024
	dc := gg.NewContext(S, S)
	dc.SetRGBA(0, 0, 0, 0.1)
	for i := 0; i &amp;lt; 360; i += 15 {
		dc.Push()
		dc.RotateAbout(gg.Radians(float64(i)), S/2, S/2)
		dc.DrawEllipse(S/2, S/2, S*7/16, S/8)
		dc.Fill()
		dc.Pop()
	}
	dc.SavePNG(&amp;quot;out.png&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/J9CBZef.png&#34; alt=&#34;Ellipses&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>go interface func</title>
            <link>/language/golang/go-interface-func/</link>
            <pubDate>Tue, 24 Dec 2019 16:42:53 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/golang/go-interface-func/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Model can convert any Color to one from its own color model. The conversion
// may be lossy.
type Model interface {
	Convert(c Color) Color
}

// ModelFunc returns a Model that invokes f to implement the conversion.
func ModelFunc(f func(Color) Color) Model {
	// Note: using *modelFunc as the implementation
	// means that callers can still use comparisons
	// like m == RGBAModel. This is not possible if
	// we use the func value directly, because funcs
	// are no longer comparable.
	return &amp;amp;modelFunc{f}
}

type modelFunc struct {
	f func(Color) Color
}

func (m *modelFunc) Convert(c Color) Color {
	return m.f(c)
}

// Models for the standard color types.
var (
	RGBAModel    Model = ModelFunc(rgbaModel)
	RGBA64Model  Model = ModelFunc(rgba64Model)
	NRGBAModel   Model = ModelFunc(nrgbaModel)
	NRGBA64Model Model = ModelFunc(nrgba64Model)
	AlphaModel   Model = ModelFunc(alphaModel)
	Alpha16Model Model = ModelFunc(alpha16Model)
	GrayModel    Model = ModelFunc(grayModel)
	Gray16Model  Model = ModelFunc(gray16Model)
)

func rgbaModel(c Color) Color {
	if _, ok := c.(RGBA); ok {
		return c
	}
	r, g, b, a := c.RGBA()
	return RGBA{uint8(r &amp;gt;&amp;gt; 8), uint8(g &amp;gt;&amp;gt; 8), uint8(b &amp;gt;&amp;gt; 8), uint8(a &amp;gt;&amp;gt; 8)}
}

func rgba64Model(c Color) Color {
	if _, ok := c.(RGBA64); ok {
		return c
	}
	r, g, b, a := c.RGBA()
	return RGBA64{uint16(r), uint16(g), uint16(b), uint16(a)}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (p *RGBA) Set(x, y int, c color.Color) {
	if !(Point{x, y}.In(p.Rect)) {
		return
	}
	i := p.PixOffset(x, y)
	c1 := color.RGBAModel.Convert(c).(color.RGBA)
	s := p.Pix[i : i+4 : i+4] // Small cap improves performance, see https://golang.org/issue/27857
	s[0] = c1.R
	s[1] = c1.G
	s[2] = c1.B
	s[3] = c1.A
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Color interface {
	// RGBA returns the alpha-premultiplied red, green, blue and alpha values
	// for the color. Each value ranges within [0, 0xffff], but is represented
	// by a uint32 so that multiplying by a blend factor up to 0xffff will not
	// overflow.
	//
	// An alpha-premultiplied color component c has been scaled by alpha (a),
	// so has valid values 0 &amp;lt;= c &amp;lt;= a.
	RGBA() (r, g, b, a uint32)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;color.RGBAModel.Convert(c).(color.RGBA)&lt;/p&gt;

&lt;p&gt;首先 RGBAModel 是color 包中一个·接口对象·&lt;br /&gt;
RGBAModel    Model&lt;/p&gt;

&lt;p&gt;Model 是 color 包中的一个接口 具备 &lt;code&gt;Convert(c Color) Color&lt;/code&gt; 方法 转换之后返回 Color 对象。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>mpp vpss detection tracker</title>
            <link>/hardware/hisilicon/mpp/mpp-vpss-detection-tracker/</link>
            <pubDate>Sat, 21 Dec 2019 18:53:02 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/mpp/mpp-vpss-detection-tracker/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifdef __cplusplus
#if __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
#endif   /* End of #ifdef __cplusplus */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;quot;sample_comm.h&amp;quot;
#include &amp;quot;student_process.h&amp;quot;

typedef struct rhTRACK_PARAM_S
{
    HI_BOOL bThreadStart;
    VPSS_CHN VpssChn;
} TRACK_PARAM_S;

static TRACK_PARAM_S gs_stTrkParam;
static pthread_t gs_TrkPid;

/*Analysis of Algorithms */
HI_VOID *RH_MPI_Alg_Analysis(VIDEO_FRAME_INFO_S *pFrmInfo)
{
	HI_U32 u32Size = pFrmInfo-&amp;gt;stVFrame.u32Width*pFrmInfo-&amp;gt;stVFrame.u32Height*3/2;
	int Is_Realcoordinate = 0;	
	HI_U8* pVirAddr;
	rect_t rect = {0}; 
	
	pVirAddr = (HI_U8*) HI_MPI_SYS_Mmap(pFrmInfo-&amp;gt;stVFrame.u32PhyAddr[0], u32Size);
	usleep(200000);
	//算法运行接口
	Is_Realcoordinate = Reach_Track_run(pVirAddr,&amp;amp;rect);	
	if(Is_Realcoordinate == 2)	{
		SAMPLE_PRT(&amp;quot;current data !!!!!!!!!!!! &amp;quot;);
		SAMPLE_PRT(&amp;quot;rect min_x=%d,min_y=%d,max_x=%d,max_y=%d\n&amp;quot;,rect.min_x,rect.min_y,rect.max_x,rect.max_y);
	}

	HI_MPI_SYS_Munmap((HI_VOID*)pVirAddr,u32Size);
	return ;
}


/*RH_MPI_YUV_Analysis */
HI_VOID* RH_MPI_YUV_Analysis(HI_VOID* pdata)
 {
 	TRACK_PARAM_S *pgs_stTrkParam;
	VPSS_CHN VpssChn = 0;
	VPSS_GRP VpssGrp = 0;
	HI_U32 s32Ret;
    HI_S32 s32GetFrameMilliSec = 20000;
	VIDEO_FRAME_INFO_S stFrameInfo;

    pgs_stTrkParam = (TRACK_PARAM_S*)pdata;
	VpssChn = pgs_stTrkParam-&amp;gt;VpssChn;

	while(HI_TRUE == pgs_stTrkParam-&amp;gt;bThreadStart)
	{
		s32Ret = HI_MPI_VPSS_GetChnFrame(VpssGrp, VpssChn, &amp;amp;stFrameInfo, s32GetFrameMilliSec);
		if (HI_SUCCESS != s32Ret)
		{
			SAMPLE_PRT(&amp;quot;HI_MPI_VPSS_GetChnFrame fail,VpssChn(%d),Error(%#x)\n&amp;quot;, VpssChn, s32Ret);
			continue;
		}
		/*Analysis of Algorithms */
		RH_MPI_Alg_Analysis(&amp;amp;stFrameInfo);	
		
		s32Ret = HI_MPI_VPSS_ReleaseChnFrame(VpssGrp, VpssChn, &amp;amp;stFrameInfo);
		if (HI_SUCCESS != s32Ret)
		{
			SAMPLE_PRT(&amp;quot;HI_MPI_VPSS_ReleaseChnFrame fail,VpssChn(%d),Error(%#x)\n&amp;quot;, VpssChn, s32Ret);
			continue;
		}
	}
	return ;
}

/*跟踪算法启动*/
HI_U32 RH_Track_Algorithm_Start(VPSS_CHN VpssChn)
{
	HI_U32 u32Depth = 4;
	HI_U32 s32Ret = HI_SUCCESS;
	VPSS_GRP VpssGrp = 0;

	Reach_Track_start();
	s32Ret = HI_MPI_VPSS_SetDepth(VpssGrp, VpssChn, u32Depth);	
	if (s32Ret != HI_SUCCESS)
	{
		SAMPLE_PRT(&amp;quot;HI_MPI_VPSS_SetDepth failed with %#x!\n&amp;quot;,s32Ret);
		return s32Ret;
	}	
	gs_stTrkParam.bThreadStart = HI_TRUE;
	gs_stTrkParam.VpssChn   = VpssChn;	

	s32Ret = pthread_create(&amp;amp;gs_TrkPid, 0, RH_MPI_YUV_Analysis, (HI_VOID*)&amp;amp;gs_stTrkParam);
	return s32Ret;
}

/*Stop Tracking YUV*/
HI_U32 RH_Track_Algorithm_Stop(HI_VOID)
{
    /* join thread */
    if (HI_TRUE == gs_stTrkParam.bThreadStart)
    {
        gs_stTrkParam.bThreadStart = HI_FALSE;
        pthread_join(gs_TrkPid, 0);
    }
	return HI_SUCCESS;
}

#ifdef __cplusplus
#if __cplusplus
}
#endif
#endif /* End of #ifdef __cplusplus */
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>海思3516 zbar识别二维码，并保存yuv图像代码</title>
            <link>/hardware/hisilicon/mpp/mpp-vpss-zbar/</link>
            <pubDate>Sat, 21 Dec 2019 18:44:12 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/mpp/mpp-vpss-zbar/</guid>
            <description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/******************************************************************************
  Some simple Hisilicon Hi35xx video input functions.

  Copyright (C), 2010-2011, Hisilicon Tech. Co., Ltd.
 ******************************************************************************
    Modification:  2011-2 Created
******************************************************************************/
#ifdef __cplusplus
#if __cplusplus
extern &amp;quot;C&amp;quot;
{
#endif
#endif /* End of #ifdef __cplusplus */

#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/poll.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;quot;hi_comm_video.h&amp;quot;
#include &amp;quot;mpi_vi.h&amp;quot;
#include &amp;quot;zbar.h&amp;quot;
    //#include &amp;quot;test_images.h&amp;quot;

#include &amp;quot;sample_comm.h&amp;quot;
#define MAX_FRM_WIDTH 2048
    static HI_CHAR *pUserPageAddr[2] = {HI_NULL, HI_NULL};
    static HI_U32 u32Size = 0;

    static FILE *pfd = HI_NULL;

    HI_S32 SAMPLE_COMM_VPSS_GetImg(VPSS_GRP VpssGrp, VPSS_CHN VpssChn)
    {
        printf(&amp;quot;grp:%d,chn:%d\n&amp;quot;, VpssGrp, VpssChn);
        zbar_image_scanner_t *scanner = NULL;
        /* create a reader */
        scanner = zbar_image_scanner_create();

        /* configure the reader */
        zbar_image_scanner_set_config(scanner, 0, ZBAR_CFG_ENABLE, 1);

        /* obtain image data */
        int width = 0, height = 0;
        HI_S32 s32ret;
        HI_VOID *yPtr;
        VIDEO_FRAME_INFO_S stFrame;
        HI_U32 u32Depth, i;
        char *pVBufVirt_Y;
        HI_CHAR *pUserPageAddr[2];
        HI_U32 u32UvHeight;
        char *pVBufVirt_C;
        HI_CHAR szYuvName[128];
        char *pMemContent;
        HI_CHAR szPixFrm[10];
        unsigned int w, h;
        static unsigned char TmpBuff[MAX_FRM_WIDTH];
        HI_U32 u32Cnt = 1;
        snprintf(szPixFrm, 10, &amp;quot;P420&amp;quot;);
        /* set max depth */
        u32Depth = 3;
        HI_U32 len;
        snprintf(szYuvName, 128, &amp;quot;./vpss_grp%d_chn%d_w%d_h%d_%s_%d.yuv&amp;quot;, VpssGrp, VpssChn,
                 stFrame.stVFrame.u32Width, stFrame.stVFrame.u32Height, szPixFrm, u32Cnt);
        printf(&amp;quot;Dump YUV frame of vpss chn %d  to file: \&amp;quot;%s\&amp;quot;\n&amp;quot;, VpssChn, szYuvName);
        fflush(stdout);
        pfd = fopen(szYuvName, &amp;quot;wb&amp;quot;);
        s32ret = HI_MPI_VPSS_SetDepth(VpssGrp, VpssChn, u32Depth); //HI_MPI_VPSS_SetDepth
        if (HI_SUCCESS != s32ret)
        {
            printf(&amp;quot;set max depth err:0x%x\n&amp;quot;, s32ret);
            return s32ret;
        }

        while (1)
        {

            /* get video frame from vpss chn */
            s32ret = HI_MPI_VPSS_GetChnFrame(VpssGrp, VpssChn, &amp;amp;stFrame, -1);
            if (HI_SUCCESS != s32ret)
            {
                printf(&amp;quot;get vpss frame err:0x%x\n&amp;quot;, s32ret);
                return s32ret;
            }
            width = stFrame.stVFrame.u32Width;
            height = stFrame.stVFrame.u32Height;
            //raw=(void*)malloc(2*width*height);
            zbar_image_t *image = zbar_image_create();
            zbar_image_set_format(image, *(int *)&amp;quot;NV21&amp;quot;);
            zbar_image_set_size(image, width, height);
            printf(&amp;quot;get vpss frame u32Width: 0x%x\n&amp;quot;, stFrame.stVFrame.u32Width);
            printf(&amp;quot;get vpss frame u32Height: 0x%x\n&amp;quot;, stFrame.stVFrame.u32Height);
            u32UvHeight = stFrame.stVFrame.u32Height / 2;
            //len = (stFrame.stVFrame.u32Stride[0])*(stFrame.stVFrame.u32Height)+(stFrame.stVFrame.u32Stride[1])*u32UvHeight;
            len = (stFrame.stVFrame.u32Stride[0]) * (stFrame.stVFrame.u32Height) * 3 / 2;
            //	yPtr= HI_MPI_SYS_Mmap(stFrame.stVFrame.u32PhyAddr[0], len);
            pUserPageAddr[0] = (HI_CHAR *)HI_MPI_SYS_Mmap(stFrame.stVFrame.u32PhyAddr[0], len);
            pVBufVirt_Y = pUserPageAddr[0];
            pVBufVirt_C = pVBufVirt_Y + (stFrame.stVFrame.u32Stride[0]) * (stFrame.stVFrame.u32Height);

            fprintf(stderr, &amp;quot;saving......Y......&amp;quot;);
            fflush(stderr);
            for (h = 0; h &amp;lt; stFrame.stVFrame.u32Height; h++)
            {
                pMemContent = pVBufVirt_Y + h * stFrame.stVFrame.u32Stride[0];
                fwrite(pMemContent, stFrame.stVFrame.u32Width, 1, pfd);
            }

            fflush(pfd);
            /* save U ----------------------------------------------------------------*/
            fprintf(stderr, &amp;quot;U......&amp;quot;);
            fflush(stderr);

            for (h = 0; h &amp;lt; u32UvHeight; h++)
            {
                pMemContent = pVBufVirt_C + h * stFrame.stVFrame.u32Stride[1];

                pMemContent += 1;

                for (w = 0; w &amp;lt; stFrame.stVFrame.u32Height / 2; w++)
                {
                    TmpBuff[w] = *pMemContent;
                    pMemContent += 2;
                }
                fwrite(TmpBuff, stFrame.stVFrame.u32Width / 2, 1, pfd);
            }
            fflush(pfd);

            /* save V ----------------------------------------------------------------*/
            fprintf(stderr, &amp;quot;V......&amp;quot;);
            fflush(stderr);
            for (h = 0; h &amp;lt; u32UvHeight; h++)
            {
                pMemContent = pVBufVirt_C + h * stFrame.stVFrame.u32Stride[1];

                for (w = 0; w &amp;lt; stFrame.stVFrame.u32Width / 2; w++)
                {
                    TmpBuff[w] = *pMemContent;
                    pMemContent += 2;
                }
                fwrite(TmpBuff, stFrame.stVFrame.u32Width / 2, 1, pfd);
            }

            fflush(pfd);

            fprintf(stderr, &amp;quot;done %d, 0x%x!\n&amp;quot;, stFrame.stVFrame.u32TimeRef, stFrame.stVFrame.u32PhyAddr[0]);
            fflush(stderr);

            zbar_image_set_data(image, pVBufVirt_Y, (stFrame.stVFrame.u32Stride[0]) * (stFrame.stVFrame.u32Height), NULL);

            zbar_image_t *test = zbar_image_convert(image, *(int *)&amp;quot;Y800&amp;quot;);
            s32ret = HI_MPI_VPSS_ReleaseChnFrame(VpssGrp, VpssChn, &amp;amp;stFrame);

            if (HI_SUCCESS != s32ret)
            {
                printf(&amp;quot;Release vi frame err:0x%x\n&amp;quot;, s32ret);
                return s32ret;
            }

            /* scan the image for barcodes */

            int n = zbar_scan_image(scanner, test); //二维码扫描
            printf(&amp;quot;n=%d\n&amp;quot;, n);
            if (n == 0)
                continue;
            /* extract results */
            const zbar_symbol_t *symbol = zbar_image_first_symbol(test);
            for (; symbol; symbol = zbar_symbol_next(symbol))
            {
                /* do something useful with results */
                zbar_symbol_type_t typ = zbar_symbol_get_type(symbol);
                const char *data = zbar_symbol_get_data(symbol);

                printf(&amp;quot;decoded %s symbol \&amp;quot;%s\&amp;quot;\n&amp;quot;,
                       zbar_get_symbol_name(typ), data);
            }

            HI_MPI_SYS_Munmap(pUserPageAddr[0], len);
        }
        return s32ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「不吃胡萝卜smile」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/wmdshhzsmile/article/details/85244417&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/wmdshhzsmile/article/details/85244417&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>linux fdopen fileno</title>
            <link>/language/clang/linux-fdopen-fileno/</link>
            <pubDate>Thu, 19 Dec 2019 14:17:10 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/clang/linux-fdopen-fileno/</guid>
            <description>

&lt;p&gt;函数fopen()就是返回打开文件的指针。其实文件描述符和文件指针是可以互相转换的。这要通过fdopen和fileno两个函数实现。它们都包含在头文件stdio.h中。先看fdopen的原型：&lt;br /&gt;
FILE * fdopen(int filedes, const char *opentype);&lt;br /&gt;
第一个参数filedes是一个打开的文件描述符，opentype是表示打开方式的字符串，和fopen函数具有相同的取值，比如&amp;quot;w&amp;quot;或&amp;quot;w+&amp;quot;等。但是你必须保证该字符串的描述和文件实际的打开方式是匹配的。&lt;br /&gt;
文件返回一个新的文件流（stream）的指针。如果操作失败，返回空指针null。&lt;/p&gt;

&lt;h3 id=&#34;把文件流指针转换成文件描述符用fileno函数-其原型为&#34;&gt;把文件流指针转换成文件描述符用fileno函数，其原型为：&lt;/h3&gt;

&lt;p&gt;int fileno(FILE *stream);&lt;br /&gt;
它返回和stream文件流对应的文件描述符。如果失败，返回-1。&lt;br /&gt;
以前知道，当程序执行时，就已经有三个文件流打开了，它们分别是标准输入stdin，标准输出stdout和标准错误输出stderr。和流式文件相对应的是，也有三个文件描述符被预先打开，它们分别是0，1，2，代表标准输入、标准输出和标准错误输出。&lt;br /&gt;
需要指出的是，上面的流式文件输入、输出和文件描述符的输入输出方式不能混用，否则会造成混乱。所以上面的函数使用的机会并不多。以后会讲到使用的场合。&lt;/p&gt;

&lt;p&gt;相关函数： open, fopen&lt;br /&gt;
表头文件：#include &lt;stdio.h&gt;&lt;br /&gt;
定义函数： int fileno(FILE *stream)&lt;br /&gt;
函数说明：fileno()用来取得参数stream指定的文件流所使用的文件描述词&lt;br /&gt;
返回值   ：返回文件描述词&lt;br /&gt;
范例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
main()
{
    FILE  *fp;
    int  fd;
    fp = fopen(&amp;quot;/etc/passwd&amp;quot;, &amp;quot;r&amp;quot;);
    fd = fileno(fp);
    printf(&amp;quot;fd = %d\n&amp;quot;, fd);
    fclose(fp);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>linux mmap</title>
            <link>/language/clang/linux-mmap/</link>
            <pubDate>Thu, 19 Dec 2019 13:41:04 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/clang/linux-mmap/</guid>
            <description>&lt;p&gt;由于在应用层没法用writel，所以参考himm.c写了一个设置，代码如下：&lt;/p&gt;

&lt;p&gt;void uart1_rtsn_high(void)&lt;br /&gt;
{  &lt;br /&gt;
  void * pMem  = NULL;&lt;br /&gt;
  pMem = memmap(0x201d0010, DEFAULT_MD_LEN);&lt;br /&gt;
  &lt;em&gt;(U32&lt;/em&gt;)pMem = 0xff;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;文件名是rs485.c&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「苏西守护者」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/u013308744/article/details/77964483&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/u013308744/article/details/77964483&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>linux fopen fwrite fflush fsync</title>
            <link>/language/clang/linux-fopen-fwrite-fflush-fsync/</link>
            <pubDate>Thu, 19 Dec 2019 11:28:34 CST</pubDate>
            <author>rinetd</author>
            <guid>/language/clang/linux-fopen-fwrite-fflush-fsync/</guid>
            <description>

&lt;p&gt;fwrite函数只是将所写内容存入用户缓存,并不立刻写入文件.&lt;/p&gt;

&lt;p&gt;fflush函数将用户缓存中的内容写入内核缓冲区&lt;/p&gt;

&lt;p&gt;fsync函数则是将内核缓冲写入文件&lt;/p&gt;

&lt;p&gt;fclose则先执行fflush,再关闭文件的读写.&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;因此,如果使用fwrite,要想让数据立刻落地,必须使用fflush(fp);fsync(fileno(fp))才可以!&lt;/p&gt;

&lt;h3 id=&#34;fwrite写到文件中之后多了0d这个字符&#34;&gt;fwrite写到文件中之后多了0d这个字符&lt;/h3&gt;

&lt;p&gt;问题是在于我用fwrite函数打开文件时没有加上二进制打开方式“b”的这个方式打开，用的是w+，正确代码应该是 wb+&lt;/p&gt;

&lt;p&gt;fopen(&amp;quot;路径.prn&amp;quot;, wb+&amp;quot;)；因为如果没有用二进制形式打开文件，遇到0X0a时，它会把它默认做换行标志然后给你补上0X0d；因为在windows下0x0a 和 0x0d 加在一起表示的是换行&lt;/p&gt;

&lt;h3 id=&#34;fwrite在任意位置写入文件-并可修改文件内容&#34;&gt;fwrite在任意位置写入文件,并可修改文件内容&lt;/h3&gt;

&lt;p&gt;想实现类似迅雷那样下载时可以从文件半中间写入的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
    int main()
    {
        FILE *fp;
        fp=fopen(&amp;quot;overwrite.bin&amp;quot;,&amp;quot;rb+&amp;quot;); //使用rb+模式,可以往半中间插入数据,而且是覆盖插入,若使用&amp;quot;ab+&amp;quot;每次都插入到最后面,调用fseek也没用
        if(NULL != fp)
        {
            if(-1 == (fseek(fp,9, SEEK_SET)))  // 寻找到第9个位置
                    printf(&amp;quot;seek error\n&amp;quot;);
            fwrite(&amp;quot;abcde&amp;quot;,1, 5, fp);      // 写入【大小为1，数量为5】个字符
            fclose(fp);
        }
        else
        {
            printf(&amp;quot;fopen error&amp;quot;);
            return 0;
        }
        return 0;
    }
    ```
刚开始用ab+模式打开, 每次都写入到最后面. 用rb+就可以定位到任意位置写入了.
在linux下已测试,因为用&amp;quot;rb+&amp;quot;打开要保证文件已存在. 使用命令  #touch overwrite.bin  新建文件
将上述代码 编译运行.
用vi 打开overwrite.bin 看到内容为第9字节开始abcde
然后再将fseek(fp,9,SEEK_SET)中的9改成11:fseek(fp,11,SEEK_SET), 编译运行. 再用vi打开overwrite.bin可以看到在第9字节开始的内容为&amp;quot;ababcde&amp;quot;.
之前写入的cde被覆盖了
转:http://www.cnblogs.com/rusty/archive/2011/11/17/2253069.html
http://bbs.chinaunix.net/thread-1794396-1-1.html


#### fread fwrite 
```cpp
#include&amp;lt;stdio.h&amp;gt;
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *FP);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *FP);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2个函数返回：读或写的对象数&lt;br /&gt;
fread函数用于执行直接输出操作，参数ptr是读取数据的缓冲区指针，size是读取对象的大小，nmemb表示读取的对象个数，fp是FILE的结构指针&lt;br /&gt;
fwrite函数用于执行直接输入操作，参数ptr是要输入数据的缓冲区指针，size是写入对象的大小，nmemb表示写入的对象个数，fp是FILE的结构指针&lt;br /&gt;
fopen()函数：&lt;/p&gt;

&lt;p&gt;1.作用: 在C语言中fopen()函数用于打开指定路径的文件，获取指向该文件的指针。&lt;/p&gt;

&lt;p&gt;2.函数原型：&lt;/p&gt;

&lt;p&gt;FILE * fopen(const char * path,const char * mode);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- path: 文件路径，如：&amp;quot;F:\Visual Stdio 2012\test.txt&amp;quot;
-- mode: 文件打开方式，例如：
        &amp;quot;r&amp;quot; 以只读方式打开文件，该文件必须存在。
        &amp;quot;w&amp;quot; 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
        &amp;quot;w+&amp;quot; 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
        &amp;quot;a&amp;quot; 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
        &amp;quot;a+&amp;quot; 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。（原来的EOF符不保留）
        &amp;quot;wb&amp;quot; 只写打开或新建一个二进制文件，只允许写数据。
        &amp;quot;wb+&amp;quot; 读写打开或建立一个二进制文件，允许读和写。
        &amp;quot;ab&amp;quot; 追加打开一个二进制文件，并在文件末尾写数据。
        &amp;quot;ab+&amp;quot;读写打开一个二进制文件，允许读，或在文件末追加数据。
--返回值: 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno中。        
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fwrite-函数&#34;&gt;fwrite()函数：&lt;/h3&gt;

&lt;p&gt;1.作用：在C语言中fwrite()函数常用语将一块内存区域中的数据写入到本地文本。&lt;/p&gt;

&lt;p&gt;2.函数原型：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- buffer: 指向数据块的指针
-- size: 每个数据的大小，单位为Byte(例如：sizeof(int)就是4)
-- count: 写入数据个数
-- stream: 文件指针
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：返回值随着调用格式的不同而不同：&lt;/p&gt;

&lt;p&gt;    (1) 调用格式：fwrite(buf,sizeof(buf),1,fp);  成功写入返回值为1(即count)&lt;br /&gt;
    (2)调用格式：fwrite(buf,1,sizeof(buf),fp);   成功写入则返回实际写入的数据个数(单位为Byte)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注意事项:&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;    写完数据后要调用fclose()关闭流，不关闭流的情况下，每次读或写数据后，文件指针都会指向下一个待写或者读数据位置的指针。&lt;/p&gt;

&lt;p&gt;示例说明:&lt;/p&gt;

&lt;p&gt;fread()函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作用：从一个文件流中读取数据&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数原型如下：&lt;/p&gt;

&lt;p&gt;size_t fread(void *buffer, size_t size, size_t count, FILE *stream);&lt;br /&gt;
  -- buffer: 指向数据块的指针&lt;br /&gt;
  -- size:   每个数据的大小，单位为Byte(例如：sizeof(int)就是4)&lt;br /&gt;
  -- count:  数据个数&lt;br /&gt;
  -- stream: 文件指针&lt;br /&gt;
注意：返回值随着调用格式的不同而不同：&lt;br /&gt;
(1) 调用格式：fread(buf,sizeof(buf),1,fp);&lt;br /&gt;
读取成功时：当读取的数据量正好是sizeof(buf)个Byte时，返回值为1(即count)&lt;br /&gt;
                       否则返回值为0(读取数据量小于sizeof(buf))&lt;br /&gt;
(2)调用格式：fread(buf,1,sizeof(buf),fp);&lt;br /&gt;
读取成功返回值为实际读回的数据个数(单位为Byte)&lt;br /&gt;
代码参考：&lt;br /&gt;
```cpp&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;br /&gt;
	FILE &lt;em&gt;filp = NULL;&lt;br /&gt;
	char fileDir[] = &amp;quot;/home/yangzhiyuan/Documents/test.txt&amp;quot;;&lt;br /&gt;
	char dataPtr[] = &amp;quot;Helloworld&amp;quot;;&lt;br /&gt;
	printf(&amp;quot;sizeof(dataPtr) = %ld\n&amp;quot;,sizeof(dataPtr));&lt;br /&gt;
	filp = fopen(fileDir,&amp;quot;w+&amp;quot;);  /&lt;/em&gt; 可读可写，不存在则创建 &lt;em&gt;/&lt;br /&gt;
	int writeCnt = fwrite(dataPtr,sizeof(dataPtr),1,filp);  /&lt;/em&gt; 返回值为1 &lt;em&gt;/&lt;br /&gt;
	//int writeCnt = fwrite(dataPtr,1,sizeof(dataPtr),filp);  /&lt;/em&gt; 返回值为11 */&lt;br /&gt;
	printf(&amp;quot;writeCnt = %d\n&amp;quot;,writeCnt);&lt;br /&gt;
	fclose(filp);&lt;/p&gt;

&lt;p&gt;	FILE &lt;em&gt;fp = NULL;&lt;br /&gt;
	fp = fopen(fileDir,&amp;quot;r&amp;quot;);&lt;br /&gt;
	char buffer[256];&lt;br /&gt;
	int readCnt = fread(buffer,sizeof(buffer),1,fp);  /&lt;/em&gt; 返回值为0 &lt;em&gt;/&lt;br /&gt;
	//int readCnt = fread(buffer,1,sizeof(buffer),fp);  /&lt;/em&gt; 返回值为11 */	&lt;br /&gt;
	printf(&amp;quot;readCnt = %d\n&amp;quot;,readCnt);&lt;br /&gt;
	fclose(fp);&lt;/p&gt;

&lt;p&gt;	printf(&amp;quot;%s\n&amp;quot;,buffer);&lt;br /&gt;
	exit(0);&lt;br /&gt;
}&lt;br /&gt;
```&lt;br /&gt;
注意：本例代码中定义了两个FILE变量，一个用于write，一个用于read，写完后要close掉，然后再打开，然后读。如果直接使用一个FILE变量，会出错！&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「yangzhiyuan0928」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/yang2011079080010/article/details/52528261&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/yang2011079080010/article/details/52528261&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>mpp venc</title>
            <link>/hardware/hisilicon/mpp/mpp-venc/</link>
            <pubDate>Thu, 19 Dec 2019 10:42:47 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/mpp/mpp-venc/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/skdkjzz/article/details/17073263&#34; target=&#34;_blank&#34;&gt;(1条消息)嵌入式 视频编码（H264）hi3518 - skdkjxy的专栏&lt;/a&gt;&lt;br /&gt;
这几天在编写视频录制模块，所以，闲暇之余，又粗粗的整理了一下，主要是API，以备不时之用   大笑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;摄像头获取的模拟信号通过经芯片处理（我们使用的是CX25825），将模拟信号转成数字信号，产生标准的ITU 656 YUV格式的数字信号以帧为单位送到编码卡上的DSP和内存中。分别供视频实时预览、移动侦测处理以及编码等使用。其中编码的作用是将编码卡内存中的 YUV数据送到H264编码器中，进过H.264编码产生压缩好的码流，送到主机内存中，供录像或网络传输使用。编码模块完成各个协议编码，协调 MD、VPP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关模块的管理、同步和控制，配合软件调度和硬件共同完成视频编码相关功能。&lt;br /&gt;
一、重要概念&lt;br /&gt;
主次码流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主次码流是指硬件逻辑单元启动一次同时产生的 2 路码流，即 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路主码流和 1 路次码流。主码流和次码流可以为不同的编码协议，但其宽高比例都必须满足 1:1、1:2 或 1:4，次码流不能单独存在（必须和 1 路主码流在同一个通道组中） 。&lt;br /&gt;
双码流&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;双码流是指硬件逻辑单元启动 2 次分时产生的 2 个码流，即 2 路主码流。双码流可以为不同的编码协议，双码流之间的大小比例没有约束关系。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通道组&lt;br /&gt;
通道组是指芯片能够同时处理的编码通道的集合，相当于一个容器。一个通道组最多可同时包含 1 路主码流（H.264/MJPEG） 、1路次码流（H.264/MJPEG） ，或者仅包含 1 路 JPEG抓拍（即 JPEG抓拍时，不允许包含任何其他通道） ，或者 1 路MPEG4 编码通道。&lt;br /&gt;
H264&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;H.264 的功能分为两层：视频编码层（VCL,VideoCoding Layer）和网络提取层（NAL, NetworkAbstraction Layer）。VCL数据即编码处理的输出，它表示被压缩编码后的视频数序列。在VCL数据传输或存储之前，这些编码的VCL数据，先被映射或封装进 NAL单元中。每个NAL单元包括一个原始字节序列负荷（RBSP,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Raw Byte SequencePayload）、一组对应于视频编码的 NAL 头信息。RBSP 的基本结构是：在原始编码数据的后面填加了结尾比特。一个bit“1”若干比特“0”，以便字节对齐。H.264的编码视频序列包括一系列的NAL单元，每个 NAL单元包含一个RBSP。编码片（包括数据分割片 IDR片）和序列RBSP结束符被定义为VCL&lt;br /&gt;
NAL单元，其余为 NAL 单元。典型的 RBSP 单元序列如图 2 所示。每个单元都按独立的 NAL 单元传送。单元的信息头（一个字节）定义了RBSP 单元的类型，NAL单元的其余部分为 RBSP 数据。&lt;/p&gt;

&lt;p&gt;二、相关结构&lt;br /&gt;
1.定义编码通道属性结构体：&lt;br /&gt;
```cpp&lt;br /&gt;
typedef struct hiVENC_CHN_ATTR_S&lt;br /&gt;
{&lt;br /&gt;
 PAYLOAD_TYPE_E enType;     //编码协议类型&lt;br /&gt;
 HI_VOID  *pValue;          //编码属性指针&lt;br /&gt;
}VENC_CHN_ATTR_S;&lt;/p&gt;

&lt;p&gt;2.定义 H.264编码属性结构体：&lt;br /&gt;
typedef struct hiVENC_ATTR_H264_S&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HI_U32 u32Priority;         //通道优先级。 目前未使用，取值不限。
HI_U32 u32PicWidth;         //编码图像宽度。 取值范围：[160, 2048]，以像素为单位。静态属性。
HI_U32 u32PicHeight;        //编码图像高度。 取值范围：[112, 1536]，以像素为单位。 静态属性。
HI_U32 u32ViFramerate;      //VI 输入的帧率（原始帧率）。 取值范围： P制：(0, 25]，以帧为单位。 N制：(0, 30]，以帧为单位。 静态属性。
HI_BOOL bMainStream;        //主次码流标识。 取值范围：{HI_TRUE, HI_FALSE}。 HI_TRUE：主码流。 HI_FALSE：次码流。 静态属性。
HI_BOOL bVIField;           //输入图像的帧场标志。 取值范围：{HI_TRUE, HI_FALSE}。 HI_TRUE：场。  HI_FALSE：帧。 静态属性。目前未使用。
HI_BOOL bField;             //帧场编码模式。 取值范围：{HI_TRUE, HI_FALSE}。 HI_TRUE：场编码。 HI_FALSE：帧编码。 静态属性。
//推荐值：一幅YUV420编码图像大小。以编码 D1 图像为例，推荐值为 704×576×1.5 byte。 最小值：一幅YUV420编码图像大小的的 1/2。 最大值：无限制，但是会消耗更多的内存。
HI_U32 u32BufSize;          // 码流 buffer大小。 取值范围：[Min, Max]，以 byte 为单位。静态属性。  
HI_BOOL bByFrame;           // 帧/包模式获取码流。 取值范围：{HI_TRUE, HI_FALSE}。 HI_TRUE：按帧获取。  HI_FALSE：按包获取。静态属性。  
HI_U32 u32TargetFramerate;      // 目标帧率。 取值范围： P制：[1/16, 25]，N制：[1/16, 30]，以帧/秒为单位。整数：高 16bit 为0。 分数：高 16bit 为分母，低 16bit 为分子。 动态属性。   
HI_U32 u32Gop;              //I帧间隔。 取值范围：[0, 1000]，以帧为单位。 动态属性。
HI_U32 u32MaxDelay;         // 最大延迟。取值范围：最大延迟，以帧为单位。目前未使用。  动态属性。
RC_MODE_E enRcMode;         // 码率控制模式。 取值范围：[0, 3]。 0：VBR 模式。 1：CBR 模式。 2：ABR 模式。 3：FIXQP。 动态属性。
HI_U32 u32Bitrate;          // CBR/ABR 模式，表示平均码率。 VBR模式，表示最大码率。 FIXQP 模式，该值无效。 取值范围：[1, 20000]，单位 Kbps。动态属性。
HI_U32 u32PicLevel;         // 图像等级，仅 VBR/CBR模式下有效。 VBR 模式下，表示图像的质量等级。 取值范围：[0, 5]，值越小，图像质量越好。
HI_S32 s32QpI;              // I帧 QP。FIXQP 模式下有效。取值范围：[10, 50]。
HI_S32 s32QpP;                //P帧 QP。FIXQP 模式下有效。取值范围：[10, 50]。
HI_S32 s32Minutes;           //码率统计时段。ABR 模式下有效。ABR，即码率短时间波动，长时间平稳。 长时间码率的统计，以此时间为准。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}VENC_ATTR_H264_S;&lt;/p&gt;

&lt;p&gt;3.定义编码的数字水印的结构体：&lt;br /&gt;
#define   DWM_KEY_LEN 8        //密钥字符的最大个数&lt;br /&gt;
#define   DWM_CHAR_LEN 16      //水印字符个数&lt;br /&gt;
typedef struct hiVENC_WM_ATTR_S&lt;br /&gt;
{&lt;br /&gt;
 HI_U8 au8Key[DWM_KEY_LEN];    //数字水印的密钥字符串。最多 8 个字符，不满 8 个字符填充 0。&lt;br /&gt;
 HI_U8 au8User[DWM_CHAR_LEN];  //数字水印用户字符。个数最多不超过 DWM_CHAR_LEN。&lt;br /&gt;
}VENC_WM_ATTR_S;&lt;/p&gt;

&lt;p&gt;4.定义编码通道的状态结构体:&lt;br /&gt;
typedef struct hiVENC_CHN_STAT_S&lt;br /&gt;
{&lt;br /&gt;
 HI_BOOL bRegistered;            // 注册到通道组标志:取值范围：{HI_TRUE, HI_FALSE}。&lt;br /&gt;
 HI_U32 u32LeftPics;             // 待编码的图像数。&lt;br /&gt;
 HI_U32 u32LeftStreamBytes;      // 码流 buffer剩余的 byte数。&lt;br /&gt;
 HI_U32 u32CurPacks;             // 当前帧的码流包个数。&lt;br /&gt;
}VENC_CHN_STAT_S;&lt;/p&gt;

&lt;p&gt;5.定义帧码流类型结构体:&lt;br /&gt;
typedef struct hiVENC_STREAM_S&lt;br /&gt;
{&lt;br /&gt;
 VENC_PACK_S *pstPack;      // 帧码流包结构。&lt;br /&gt;
 HI_U32 u32PackCount;       // 一帧码流的所有包的个数。&lt;br /&gt;
 HI_U32 u32Seq;             // 码流序列号。 按帧获取帧序号；按包获取包序号。&lt;br /&gt;
}VENC_STREAM_S;&lt;/p&gt;

&lt;p&gt;6.定义帧码流包结构体:&lt;br /&gt;
typedef struct hiVENC_PACK_S&lt;br /&gt;
{&lt;br /&gt;
 HI_U32   u32PhyAddr[2];    // 码流包首地址。&lt;br /&gt;
 HI_U8   *pu8Addr[2];       // 码流包物理地址。&lt;br /&gt;
 HI_U32   u32Len[2];        // 码流包长度。&lt;br /&gt;
 VENC_DATA_TYPE_U DataType; // 码流类型。&lt;br /&gt;
 HI_U64   u64PTS;           // 时间戳。单位：us。&lt;br /&gt;
 HI_BOOL   bFieldEnd;       // 场结束标识。 取值范围： HI_TRUE：该码流包是该场的最后一个包。 HI_FALSE：该码流包不是该场的最后一个包。&lt;br /&gt;
 HI_BOOL   bFrameEnd;       // 帧结束标识。 取值范围： HI_TRUE：该码流包是该帧的最后一个包。 HI_FALSE：该码流包不是该场的最后一个包。&lt;br /&gt;
}VENC_PACK_S;&lt;/p&gt;

&lt;p&gt;7.定义码流结果类型&lt;br /&gt;
typedef union hiVENC_DATA_TYPE_U&lt;br /&gt;
{&lt;br /&gt;
 H264E_NALU_TYPE_E enH264EType;  //H.264 码流包类型&lt;br /&gt;
 JPEGE_PACK_TYPE_E enJPEGEType;&lt;br /&gt;
 MPEG4E_PACK_TYPE_E enMPEG4EType;&lt;br /&gt;
}VENC_DATA_TYPE_U;&lt;/p&gt;

&lt;p&gt;8.定义 JPEG码流的 PACK类型&lt;br /&gt;
typedef enum hiJPEGE_PACK_TYPE_E&lt;br /&gt;
{&lt;br /&gt;
  JPEGE_PACK_ECS = 5, //ECS类型&lt;br /&gt;
  JPEGE_PACK_APP = 6,&lt;br /&gt;
  JPEGE_PACK_VDO = 7,&lt;br /&gt;
  JPEGE_PACK_PIC = 8,&lt;br /&gt;
 JPEGE_PACK_BUTT&lt;br /&gt;
} JPEGE_PACK_TYPE_E;&lt;/p&gt;

&lt;p&gt;9.定义 MPEG4码流的PACK类型&lt;br /&gt;
typedef enum hiMPEG4E_PACK_TYPE_E&lt;br /&gt;
{&lt;br /&gt;
  MPEG4E_PACK_VO  = 1, //VO类型&lt;br /&gt;
  MPEG4E_PACK_VOS = 2,&lt;br /&gt;
  MPEG4E_PACK_VOL = 3,&lt;br /&gt;
  MPEG4E_PACK_VOP = 4,&lt;br /&gt;
  MPEG4E_PACK_SLICE = 5&lt;br /&gt;
} MPEG4E_PACK_TYPE_E;&lt;/p&gt;

&lt;p&gt;10.定义 H.264码流 NALU类型&lt;br /&gt;
typedef enum hiH264E_NALU_TYPE_E&lt;br /&gt;
{&lt;br /&gt;
 H264E_NALU_PSLICE = 1, //PSLICE 类型&lt;br /&gt;
 H264E_NALU_ISLICE = 5,&lt;br /&gt;
 H264E_NALU_SEI = 6,&lt;br /&gt;
 H264E_NALU_SPS = 7,&lt;br /&gt;
 H264E_NALU_PPS = 8,&lt;br /&gt;
 H264E_NALU_BUTT&lt;br /&gt;
} H264E_NALU_TYPE_E;&lt;/p&gt;

&lt;p&gt;11.定义 H.264编码的 NALU大小设置结构体&lt;br /&gt;
typedef struct hiVENC_ATTR_H264_NALU_S&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HI_BOOL bNaluSplitEnable;   //是否打开 NALU划分,HI_TURE：打开。
HI_U32 u32NaluSize;         //NALU划分使能的情况下指定 NALU的大小，以字节为单位，在关闭使能的情况下，此参数无效。 必须满足 128 &amp;lt;=u32NaluSize &amp;lt;= 图象大小(包括色度)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} VENC_ATTR_H264_NALU_S;&lt;/p&gt;

&lt;p&gt;12.定义 H.264编码的码率控制模式&lt;br /&gt;
typedef enum hiRC_MODE_E&lt;br /&gt;
{&lt;br /&gt;
   RC_MODE_VBR = 0,      //可变码率模式。该模式下，码率波动大，图像质量稳定&lt;br /&gt;
   RC_MODE_CBR,          //恒定码率模式。该模式下，码率始终保持平稳。&lt;br /&gt;
   RC_MODE_ABR,          //平均码率模式。该模式下，码率长时间平稳，短时间内波动。&lt;br /&gt;
   RC_MODE_FIXQP,        //固定 QP模式。该模式下，使用固定的 QP分别编码 I帧和 P帧。&lt;br /&gt;
   RC_MODE_BUTT,&lt;br /&gt;
} RC_MODE_E;&lt;/p&gt;

&lt;p&gt;三、API 参考&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;视频编码功能实际包含 VENC（视频编码）和 GROUP（通道组管理）两个重要的部分， 主要提供视频编码通道组的创建和销毁、通道组 GROUP 与视频输入通道的绑定和解绑定、视频编码通道的创建和销毁、注册和反注册到通道组、开启和停止接收图像、设置和获取编码通道属性、获取和释放码流、设置和
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取数字水印属性、启用和禁用数字水印、视频编码通道属性的设置和查询等功能。&lt;br /&gt;
1.创建/销毁编码通道组&lt;br /&gt;
HI_S32 HI_MPI_VENC_CreateGroup(VENC_GRP VeGroup);&lt;br /&gt;
HI_S32 HI_MPI_VENC_DestroyGroup(VENC_GRP VeGroup);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A.本文档中含有通道组号的接口的通道组号的取值范围为[0, VENC_MAX_GRP_NUM)，否则返回 HI_ERR_VENC_INVALID_CHNID。
B.编码通道组是指芯片能够同时处理的编码通道的集合，一个通道组最多可同时包含 1 路主码流（H.264/MJPEG）和一路次码流（H.264/MJPEG） ，或者包含 1 路JPEG抓拍，或者仅包含 1 路 MPEG4通道。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C.如果指定的通道组已经存在，则返回错误码 HI_ERR_VENC_EXIST。&lt;br /&gt;
   D.销毁通道组时，必须保证通道组为空，即没有任何通道在通道组中注册，否则会返回错误码 HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   E.销毁并不存在的通道组，返回错误码 HI_ERR_VENC_UNEXIST。&lt;/p&gt;

&lt;p&gt;2.绑定/解绑定 VI 到通道组&lt;br /&gt;
HI_S32 HI_MPI_VENC_BindInput(VENC_GRP VeGroup, VI_DEV ViDevId, VI_CHN ViChn);&lt;br /&gt;
HI_S32 HI_MPI_VENC_UnbindInput(VENC_GRP VeGroup);&lt;br /&gt;
   A.绑定并不存在的通道组，则返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   B.如果 VI 设备或者 VI 通道超出范围，则返回 HI_ERR_VENC_INVALID_DEVID或者 HI_ERR_VENC_INVALID_CHNID。&lt;br /&gt;
   C.此接口并不判断 VI 的状态，ViDevId 和 ViChn 可以对应实际的 VI 设备，也可以对应虚拟的 VI 设备，对应虚拟的 VI 设备主要用于用户手动发送图像编码， HI_MPI_VENC_SendFrame 会对此作   出详细的说明。&lt;br /&gt;
   D.如果通道组已经绑定了某个 VI 通道，则返回错误码HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   E.一个通道组只能绑定一个 VI 通道，但一个 VI 通道可以被多个通道组绑定。&lt;br /&gt;
   F.在编码过程中，可以动态解绑定和绑定 VI，达到编码不同图像源的目的。&lt;br /&gt;
   G.解绑定并不存在的通道组，返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   H.解绑定之后，VI 通道如果满足条件，可以再绑定到其他任意通道组。&lt;br /&gt;
   I.可以重复解绑定，返回 HI_SUCCESS。&lt;/p&gt;

&lt;p&gt;3.创建/销毁编码通道&lt;br /&gt;
HI_S32 HI_MPI_VENC_CreateChn(VENC_CHN VeChn, const VENC_CHN_ATTR_S *pstAttr, const VENC_WM_ATTR_S *pstWm);&lt;br /&gt;
HI_S32 HI_MPI_VENC_DestroyChn(VENC_CHN VeChn);&lt;br /&gt;
   A.Hi3520 支持对主次码流进行编码。在创建编码通道的时候必须指定该通道是主码流还是次码流。&lt;br /&gt;
   B.在创建编码通道的时候，编码通道属性除需要输入各个协议的特有的编码属性之外，一般还需要输入主次码流（MPEG4 编码协议无此属性） 、编码协议、编码的帧场模式、输入图像的帧场模式、获取码流的方式（按帧还是按包获取码流） 、编码图像大小属性，这些属性受表 6-1约束，并且这些属性都为静态属性，不允许动态设置。&lt;br /&gt;
   C.若输入图像大于大码流的宽高，但相差 16 像素以内（含 16像素） ，则大码流编码图像通过输入图像做切边得到。&lt;br /&gt;
   D.若输入图像小于大码流的宽高，会丢弃这些图像，而不会对其放大进行编码。该出错信息会在 log 中显示。&lt;br /&gt;
   E.推荐的大码流编码宽高为：2048×1536（3M 像素） 、1280×1024（1.3M 像素） 、1920×1080（1080P） 、1280×720（720P） 、704×576、704×480、352×288、352×240。&lt;br /&gt;
   F.对于 H.264主码流，编码图像大小不为 D1 时，其编码方式推荐使用帧编码。&lt;br /&gt;
   G.当参数 pstWm为空时，表示该编码通道不需要使用水印，否则认为需要使用数字水印。如果创建成功，数字水印默认使能。目前只有 H.264 编码的大码流可以设置数字水印，其他的情况设置数字水印时均返回错误码HI_ERR_VENC_NOT_SUPPORT。&lt;br /&gt;
   H.销毁并不存在的通道，返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   I.销毁前必须保证通道已经从通道组反注册，否则返回错误码HI_ERR_VENC_NOT_PERM。&lt;/p&gt;

&lt;p&gt;4.注册/反注册编码通道到通道组&lt;br /&gt;
HI_S32 HI_MPI_VENC_RegisterChn(VENC_GRP VeGroup,VENC_CHN VeChn);&lt;br /&gt;
HI_S32 HI_MPI_VENC_UnRegisterChn(VENC_CHN VeChn);&lt;br /&gt;
   A.注册并不存在的通道，返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   B.注册通道到不存在的通道组，返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   C.同一个编码通道只能注册到一个通道组，如果该通道已经注册到某个通道组，则返回 HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   D.主次码流注册的时候需要判定以下约束关系：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  −  主码流要先于次码流注册，否则返回 HI_ERR_VENC_NOT_PERM。 
  −  如果编码通道已经注册，则在反注册前不能再进行注册，否则返回HI_ERR_VENC_NOT_PERM。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E.MD通道注册必须在编码通道注册成功之后进行，否则返回HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   F.同组的主次码流若为 1:1的关系，则编码方式必须同为帧编码，否则返回HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   G.同组的主次码流宽高必须符合如下约束：D/s – d = R（主次码流宽或高分别为 D和 d，s 为1、2 或者4，R 为0 到 16） 。&lt;br /&gt;
   H.如果通道未注册，则返回错误码 HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   I.如果编码通道未停止接收图像编码（HI_MPI_VENC_StopRecvPic 可停止接收） ，则返回错误码 HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   J.反注册后会将编码通道复位，如果用户还在使用未及时释放的码流 buffer，将不能保证此 buffer 数据的正确性。用户可以使用 HI_MPI_VENC_Query接口来查询状态，确认自己所有的操作都完成之后再反注册通道。&lt;/p&gt;

&lt;p&gt;5.开启/停止编码通道接收输入图像&lt;br /&gt;
HI_S32 HI_MPI_VENC_StartRecvPic(VENC_CHN VeChn);&lt;br /&gt;
HI_S32 HI_MPI_VENC_StopRecvPic(VENC_CHN VeChn);&lt;br /&gt;
   A.如果通道未创建，则返回 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   B.如果通道没有注册到通道组，则返回 HI_ERR_VENC_NOT_PERM。&lt;br /&gt;
   C.此接口不判断当前是否已经开启接收，直接将状态设置为开启接收。&lt;br /&gt;
   D.此接口用于开启编码通道接收图像来编码，请注意它和绑定通道组的区别。&lt;br /&gt;
   E.开始接收输入是针对通道的，只有开启接收之后编码器才开始接收图像编码。&lt;br /&gt;
   F.此接口并不判断当前是否停止接收，直接将状态设置为停止接收。&lt;br /&gt;
   G.此接口用于编码通道停止接收图像来编码，在编码通道反注册前必须停止接收图像。&lt;br /&gt;
   H.调用此接口仅停止接收原始数据编码，码流 buffer并不会被清除。&lt;/p&gt;

&lt;p&gt;6.获取编码通道对应的设备文件句柄&lt;br /&gt;
HI_S32 HI_MPI_VENC_GetFd(VENC_CHN VeChn);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     A. 用户可以获取文件句柄实现多通道 select 获取视频帧数据
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.查询编码通道状态&lt;br /&gt;
HI_S32 HI_MPI_VENC_Query(VENC_CHN VeChn, VENC_CHN_STAT_S *pstStat);&lt;br /&gt;
   A.如果通道未创建，则返回 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   B.此接口用于查询此函数调用时刻的编码器状态，pstStat 包含三个主要的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  −  在编码通道状态结构体中，u32LeftPics表示待编码的帧个数。
在反注册通道前，可以通过查询是否还有图像待编码来决定反注册时机，防反注册时将可能需要编码的帧清理出去。 
  −  在编码通道状态结构体中，u32LeftStreamBytes表示码流 buffer 中剩余的 by数目。
在反注册通道前，可以通过查询是否还有码流没有被处理来决定反注册时机防止反注册时将可能需要的码流清理出去。 
  −  在编码通道状态结构体中，u32CurPacks 表示当前帧的码流包个数。
在按包获取时当前帧可能不是一个完整帧（被取走一部分） ，按帧获取时表示当前一个完整帧的包个数（如果没有一帧数据则为 0） 。用户在需要按帧获取码流时，需要查询一个完整帧的包个数，在这种情况下，通常可以在 select 成功之后执行 query操作，此时 u32CurPacks是当前完整帧中包的个数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.获取/释放编码的码流&lt;br /&gt;
HI_S32 HI_MPI_VENC_GetStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream, HI_U32 u32BlockFlag);&lt;br /&gt;
HI_S32 HI_MPI_VENC_ReleaseStream(VENC_CHN VeChn, VENC_STREAM_S *pstStream);&lt;br /&gt;
   A.如果通道未创建，返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   B.如果 pstStream为空，返回错误码 HI_ERR_VENC_NULL_PTR。&lt;br /&gt;
   C.支持阻塞或非阻塞两种方式获取。同时可支持 select/poll 系统调用,u32BlockFlag:HI_IO_BLOCK(阻塞) HI_IO_NOBLOCK(非阻塞)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  −  非阻塞获取时，如果缓冲无数据，则返回 HI_ERR_VENC_BUF_EMPTY。 
  −  阻塞时，如果缓冲无数据，则会等待有数据时才返回 HI_SUCCESS。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D.支持按包或按帧方式获取码流。如果按包获取，则：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  −  对于 H.264编码协议，每次获取的是一个 NAL 单元。 
  −  对于 JPEG编码协议（包括 JPEG抓拍和 MJPEG） ，每次获取的是一个 ECS或图像参数码流包。 
  −  对于 MPEG4编码协议，每次获取的是一帧一个包，因此按帧获取或者按包获取，结果相同。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E.码流结构体 VENC_STREAM_S包含3 个部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  −  码流包信息指针 
      pstPack 指向一组 VENC_PACK_S 的内存空间，该空间由调用者分配。如果是按包获取，则此空间不小于 sizeof（VENC_PACK_S）的大小；如果按帧获取，则此空间不小于 N × sizeof（VENC_PACK_S）的大小，其中 N代表当前帧之中的包的个数，可以在 select之后通过查询接口获得。 
  −  码流包个数 u32PackCount  
      在输入时，此值指定 pstPack 中 VENC_PACK_S 的个数。按包获取时，u32PackCount 必须不小于1；按帧获取时，包个数。在函数调用成功后，u32PackCount 返回实际填充 pstPack 的包的个数。 
  −  序列号 u32Seq 
      按帧获取时是帧序列号；按包获取时为包序列号。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;F.如果用户长时间不获取码流，那么码流缓冲区就会满。一个编码通道如果发生码流缓冲区满，就会停止该编码通道编码，等有足够的码流缓冲可以用来编码时，才开始继续编码，这种情况对于主次码流编码通道来说，相互不受影响。&lt;br /&gt;
   G.用户应该及时获取码流，防止由于码流 buffer阻塞导致编码器停止工作。&lt;br /&gt;
   H.如果通道未创建，则返回错误码 HI_ERR_VENC_UNEXIST。&lt;br /&gt;
   I.如果 pstStream为空，则返回错误码 HI_ERR_VENC_NULL_PTR。&lt;br /&gt;
   J.此接口应当和 HI_MPI_VENC_GetStream配对起来使用，用户获取码流后必须及时释放已经获取的码流缓存，否则可能会导致码流 buffer满，影响编码器编码，并且用户必须按先获取先释放的顺序释放已经获取的码流缓存。&lt;br /&gt;
   K.在编码通道反注册以后，所有未释放的码流包均无效，不能再使用或者释放这部分无效的码流缓存。&lt;br /&gt;
   L.释放无效的码流会返回 HI_ERR_VENC_ILLEGAL_PARAM。&lt;br /&gt;
附：编码过程为1-2-3-4-5-6-7-8&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>hi3516 mpp venc snap</title>
            <link>/hardware/hisilicon/hi3516-mpp-venc-snap/</link>
            <pubDate>Wed, 18 Dec 2019 14:57:19 CST</pubDate>
            <author>rinetd</author>
            <guid>/hardware/hisilicon/hi3516-mpp-venc-snap/</guid>
            <description>&lt;p&gt;海思3518ev200芯片的sdk中没有专用的抓图接口，在特定场合下需要jpeg图片的情况下，采用将h264数据编码为图片比较麻烦，因此可以采用海思自己的JPEG编码。&lt;/p&gt;

&lt;p&gt;    不多说直接上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *pic_addr;
int VencFd, s32Ret;
INT32U maxfd = 0;
 
struct timeval TimeoutVal;
fd_set read_fds;
VENC_CHN_STAT_S stStat;
VENC_STREAM_S stStream;	
VIDEO_FRAME_INFO_S stFrame;
 
if (HI_MPI_VI_SetFrameDepth(0, 1))    //设置VI通道缓存的视频图像帧数   必须的
{
    printf(&amp;quot;HI_MPI_VI_SetFrameDepth err, vi chn %d \n&amp;quot;, 0);
     return -1;
}
 
usleep(90 * 1000);
 
VencFd = HI_MPI_VENC_GetFd(1);        //JPEG编码通道为1，获取通道句柄
if (VencFd &amp;lt; 0)
{
    printf(&amp;quot;HI_MPI_VENC_GetFd failed with %#x!\n&amp;quot;, VencFd);
    return -1;
}
	
maxfd = VencFd;
	
s32Ret = HI_MPI_VI_GetFrame(0, &amp;amp;stFrame, VIDEO_GET_FRAME_TIMEOUT);        //从VI获取一张原画
if (HI_SUCCESS != s32Ret)
{
    printf(&amp;quot;HI_MPI_VI_GetFrame ext chn(%d) fail,Error(%#x)\n&amp;quot;, 0 ,s32Ret);
    return -1;
}
	
s32Ret = HI_MPI_VENC_SendFrame(1, &amp;amp;stFrame, VIDEO_GET_FRAME_TIMEOUT);       //将VI原画发送到JPEG编码器
if (HI_SUCCESS != s32Ret)
{
    printf(&amp;quot;HI_MPI_VENC_SendFrame ext chn(%d) fail,Error(%#x)\n&amp;quot;, 1 ,s32Ret);
    return -1;
}
 
while(1)
{
    FD_ZERO(&amp;amp;read_fds);
    FD_SET(VencFd, &amp;amp;read_fds);
		
    TimeoutVal.tv_sec  = 0;
    TimeoutVal.tv_usec = 50 * 1000;
    s32Ret = select(maxfd + 1, &amp;amp;read_fds, NULL, NULL, &amp;amp;TimeoutVal);        //等待JPEG编码完成
    if (s32Ret &amp;lt; 0)
    {
        printf(&amp;quot;select failed!\n&amp;quot;);
        return -1;
    }
    else if (s32Ret == 0)
    {
        printf(&amp;quot;get venc stream time out\n&amp;quot;);
        continue;
    }
    else
    {
        if (FD_ISSET(VencFd, &amp;amp;read_fds))
        {
            memset(&amp;amp;stStream, 0, sizeof(stStream));
            s32Ret = HI_MPI_VENC_Query(1, &amp;amp;stStat);        //查询编码通道状态，是否创建成功
	    if (VIDEO_SUCC != s32Ret)
	    {
	        printf(&amp;quot;HI_MPI_VENC_Query chn[%d] failed with %#x!\n&amp;quot;, 1, s32Ret);
		return -1;
	    }
				
	    if(0 == stStat.u32CurPacks)
            {
		printf(&amp;quot;NOTE: Current frame is NULL!\n&amp;quot;);
		return -1;
	    }
	    stStream.pstPack = (VENC_PACK_S*)malloc(sizeof(VENC_PACK_S) * stStat.u32CurPacks);
	    if (NULL == stStream.pstPack)
	    {
		printf(&amp;quot;malloc stream pack failed!\n&amp;quot;);
		return -1;
	    }
			
	    stStream.u32PackCount = stStat.u32CurPacks;
	    s32Ret = HI_MPI_VENC_GetStream(1, &amp;amp;stStream, VIDEO_GET_FRAME_TIMEOUT);        //获取JPEG图片
	    if (VIDEO_SUCC != s32Ret)
            {
                free(stStream.pstPack);
                stStream.pstPack = NULL;
                printf(&amp;quot;HI_MPI_VENC_GetStream failed with %#x!\n&amp;quot;, s32Ret);
                return -1;
            }
	    else
	    {
	    	printf(&amp;quot;\npicture data len is %d\n&amp;quot;, stStream.pstPack-&amp;gt;u32Len);
		pic_addr = (char *)stStream.pstPack[0].pu8Addr + stStream.pstPack[0].u32Offset;
					
		memcpy(picture_data, pic_addr, stStream.pstPack-&amp;gt;u32Len);
		*data_len = stStream.pstPack-&amp;gt;u32Len;
		break;
	    }
        }
    }	
free(stStream.pstPack);
HI_MPI_VI_ReleaseFrame(0, &amp;amp;stFrame);        //释放
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「我是诗人不唱歌」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/ayuedreamer/article/details/79459309&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/ayuedreamer/article/details/79459309&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
