<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈 on 时光小栈</title><link>/</link><language>zh-CN</language><author>rinetd</author><rights>Copyright (c) 2015, rinetd; all rights reserved.</rights><updated>Sun, 07 Jun 2020 17:00:55 CST</updated><item><title>CMake---优雅地构建软件项目实践</title><link>/language/cpp/cmake-grace/</link><pubDate>Sun, 07 Jun 2020 17:00:55 CST</pubDate><author>rinetd</author><guid>/language/cpp/cmake-grace/</guid><description>
&lt;p&gt;首先说明的是本篇文章不从cmake的整个语法上去讲述，而是从一个实际项目的构建上入手，去了解如何优雅的去构建一个软件项目，搭建一个&lt;code&gt;C/C++&lt;/code&gt;软件项目基本的依赖组件，最后形成一个构建&lt;code&gt;C/C++&lt;/code&gt;软件项目的模板，方便后面新项目的重复使用。相信对我们日常的软件项目构建都会有很好的收获。废话不都说，开始。&lt;/p&gt;
&lt;h2 id=&#34;1-我们需要知道的基础&#34;&gt;1 我们需要知道的基础&lt;/h2&gt;
&lt;p&gt;首先熟悉cmake的一些基操，我们就可以信手捏来的、优雅去构建一个项目，避免踩到不必要的坑。涉及到的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cmake的变量作用域？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;cmake中的数据结构？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;宏函数与函数？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何去构建动静态库和找到这些库？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何去实现支持多平台的项目构建？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何去构建一个应用？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何实现项目的最后install？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何很友好的去展示构建过程的各种级别信息？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如何适配cmake-gui，采用友好的ccmake或者cmake-gui实现构建？&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里概括性说明下常用的cmake知识，总的来说cmake的作用就是让我们找到依赖的头文件和库文件，去编译源文件、链接目标文件(静态库也是目标文件的一个集合)，最后生成可执行文件或动/静态库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; 将给定的目录添加到编译器用于搜索包含文件(如头文件)的目录中，相对路径被解释为相对于当前源目录。注意目录仅是被添加到当前CMakeLists文件，作用于当前CMakeLists文件相关的库、可执行文件或者&lt;code&gt;子模块&lt;/code&gt;编译，对于两个不同CMakeLists.cmake并列的作用是无效的。区别于&lt;code&gt;TARGET_INCLUDE_DIRECTORIES&lt;/code&gt;，这个命令的作用只是作用于指定的目标，为指定的目标添加搜索路径。类似的还有&lt;code&gt;TARGET_LINK_LIBRARIES&lt;/code&gt;命令(添加需要链接的库文件目录)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;PROJECT_SOURCE_DIR&lt;/code&gt;: 无疑只要是有包含最新PROJECT()命令声明的CMakeLists.txt，则都是相对当该CMakeLists.txt路径。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CMAKE_SOURCE_DIR&lt;/code&gt;: 构建整个项目时，可能你依赖的第三方项目，这个变量的值就是最顶层CMakeLists.txt的路径。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;find_path&lt;/code&gt; 和 &lt;code&gt;find_library&lt;/code&gt;以及 &lt;code&gt;find_package&lt;/code&gt; 时，会搜索一些默认的路径。当我们将一些lib安装在非默认搜索路径时，cmake就没法搜索到了，可设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SET(CMAKE_INCLUDE_PATH &amp;quot;include_path&amp;quot;) // find_path，查找头文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SET(CMAKE_LIBRARY_PATH &amp;quot;lib_path&amp;quot;) // find_library，查找库文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SET(CMAKE_MODULE_PATH &amp;quot;module_path&amp;quot;) // find_package&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;寻找3rdparty也不一定需要自己去编写FindXX.cmake，也可以直接用include(xxx.cmake)结合&lt;code&gt;find_file&lt;/code&gt;命令实现寻找依赖库，find_file寻找到的结果存放到CACHE变量，示例：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;# Once done, this will define
#
# NANOMSG_INCLUDE_DIR - the NANOMSG include directory
# NANOMSG_LIBRARY_DIR - the SPDLOG library directory
# NANOMSG_LIBS - link these to use NANOMSG
#
# SPDLOG_INCLUDE_DIR - the SPDLOG include directory
# SPDLOG_LIBRARY_DIR - the SPDLOG library directory
# SPDLG_LIBS - link these to use SPDLOG
MACRO(LOAD_LIBNANOMSG os arch)
SET(3RDPARTY_DIR ${PROJECT_SOURCE_DIR}/3rdparty/target/${${os}}_${${arch}})
MESSAGE(STATUS &amp;quot;3RDPARTY_DIR: ${3RDPARTY_DIR}&amp;quot;)
FIND_FILE(NANOMSG_INCLUDE_DIR include ${3RDPARTY_DIR} NO_DEFAULT_PATH)
FIND_FILE(NANOMSG_LIBRARY_DIR lib ${3RDPARTY_DIR} NO_DEFAULT_PATH)
SET(NANOMSG_LIBS
nanomsg
pthread
anl
PARENT_SCOPE
)
IF(NANOMSG_INCLUDE_DIR)
MESSAGE(STATUS &amp;quot;NANOMSG_LIBS : ${NANOMSG_LIBS}&amp;quot;)
ELSE()
MESSAGE(FATAL_ERROR &amp;quot;NANOMSG_LIBS not found!&amp;quot;)
ENDIF()
ENDMACRO()复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;条件控制切换示例：&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;# set target
if (NOT YOUR_TARGET_OS)
set(YOUR_TARGET_OS linux)
endif()
if (NOT YOUR_TARGET_ARCH)
set(YOUR_TARGET_ARCH x86_64)
endif()
if (NOT YOUR_BUILD_TYPE)
set (YOUR_BUILD_TYPE Release)
endif()
......
if(${YOUR_TARGET_ARCH} MATCHES &amp;quot;(arm*)|(aarch64)&amp;quot;)
......
elseif(${YOUR_TARGET_ARCH} MATCHES x86*)
......复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;交叉编译: &lt;code&gt;CMAKE_TOOLCHAIN_FILE&lt;/code&gt;变量，&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;MESSAGE(STATUS &amp;quot;Configure Cross Compiler&amp;quot;)
IF(NOT TOOLCHAIN_ROOTDIR)
MESSAGE(STATUS &amp;quot;Cross-Compiler defaut root path: $ENV{HOME}/Softwares/arm-himix200-linux&amp;quot;)
SET(TOOLCHAIN_ROOTDIR &amp;quot;$ENV{HOME}/Softwares/arm-himix200-linux&amp;quot;)
ENDIF()
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR arm)
SET(CMAKE_C_COMPILER ${TOOLCHAIN_ROOTDIR}/bin/arm-himix200-linux-gcc)
SET(CMAKE_CXX_COMPILER ${TOOLCHAIN_ROOTDIR}/bin/arm-himix200-linux-g++)
# set searching rules for cross-compiler
SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(YOUR_TARGET_OS linux)
SET(YOUR_TARGET_ARCH armv7-a)
SET(CMAKE_CXX_FLAGS &amp;quot;-std=c++11 -march=armv7-a -mfloat-abi=softfp -mfpu=neon-vfpv4 ${CMAKE_CXX_FLAGS}&amp;quot;)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AUX_SOURCE_DIRECTORY&lt;/code&gt; 不会递归包含子目录，仅包含指定的dir目录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_SUBDIRECTORY&lt;/code&gt;子模块的编译，可以将子文件夹中或者指定外部文件夹下CMakeLists.txt执行相关编译工作。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_LIBRARY&lt;/code&gt;编译一个动/静态库或者模块，设定的名字需在整个工程中是独一无二的，而且在整个同一个工程中，跟父子文件夹路径无关，我们便可以通过&lt;code&gt;TARGET_LINK_LIBRARIES&lt;/code&gt;依赖该模块。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_DEFINITIONS(-DTEST -DFOO=&amp;quot;foo&amp;quot;)&lt;/code&gt;添加&lt;code&gt;FOO&lt;/code&gt;和&lt;code&gt;TEST&lt;/code&gt;宏定义。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-我们要优雅做到的构建&#34;&gt;2 我们要优雅做到的构建&lt;/h2&gt;
&lt;p&gt;对于一个较大的软件项目，我们会依赖很多第三方的项目，包括源码依赖或者库依赖，然后完整的构建自己的软件项目，则需要去构建依赖项目或者找到我们所需要库；另外，软件项目会考虑到可移植性，即能够在不同的平台上也能够很好友的去构建项目以及将项目转移到另一个开发环境时能够快速的开始构建。&lt;/p&gt;
&lt;p&gt;除了上面所说的，我们还需要考虑我们实际软件项目的架构结构，源码结构，可以让开发人员更清晰的、更快速的了解整个项目。&lt;/p&gt;
&lt;p&gt;除此之外，C/C++ 程序员长期以来手动管理依赖，即手动查找、安装依赖，再配置构建工具（如 cmake）使用依赖。 cmake 还提供了一系列 find_package 方法帮助简化配置依赖， cmake 还支持多项目/模块管理，如果依赖源码同时被 cmake 管理构建，那么情况会简单很多，这种方式称为源码级依赖管理。 随着代码管理工具 git 出现并被广泛使用，git submodule 提供了一种不错的源码级依赖管理办法。&lt;/p&gt;
&lt;p&gt;综上，优雅的构建软件项目，我们实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件项目源码依赖第三方项目&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目库依赖第三方项目&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目结构清晰&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目构建在转换新环境下快速实现构建&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目构建过程中的信息友好展示&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目构建完成后打包发布&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目支持跨平台构建&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;软件项目支持交叉构建&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;git submodule &amp;amp; cmake管理/构建源码级依赖&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我们还实现一个可复用的C/C++最小开发框架（这个到后续文章中讲述）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持日志记录&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持任务池/线程池&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持常用相关基础操作组件&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;时间日期操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;文件读写操作&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;支持valgrind内存泄露检查工具&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持静态代码检查&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持项目文档自动化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;.....&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-优雅的软件项目结构模板&#34;&gt;3 优雅的软件项目结构模板&lt;/h2&gt;
&lt;h3 id=&#34;3-1-模板一&#34;&gt;3.1 模板一&lt;/h3&gt;
&lt;p&gt;一个独立的应用，应用模块之间是相互联系的，彼此难以分开，这样简单的将所有源文件放一起，头文件放一起，这个对于不是很复杂的应用是很快速的去开始构建和源文件修改操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-txt&#34;&gt;.
├── 3rdparty
├── cmake
├── include
├── src
├── doc
├── tests
├── benchmarks
├── docker
├── CMakeLists.txt复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-2-模板二&#34;&gt;3.2 模板二&lt;/h3&gt;
&lt;p&gt;源文件与头文件分功能模块存放，这种方式是比较简单，但是如果成为其他项目的3rdparty，则需要在安装上将头文件分离出来，不能很方便的被其他项目直接引用，个人觉得适用于App类项目，而非SDK项目(比如nanomsg这个开源消息中间件库就是将头文件和源文件放一起，但是作为SDK供外部链接就不是很直接、很方便了，需要做install操作之后才可以或者是将头文件搜索范围设置到依赖项目的src级别，且src目录下模块分类很明确)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-txt&#34;&gt;├── 3rdparty
├── submodule # 存放源码依赖
├── target # 存放库依赖
├── CMakeLists.txt
├── cmake # 存放 find_package cmake文件
├── cmake
├── platforms
│   └── linux
│   └── arm.toolchain.cmake
├── src
├── moudle1
├── source &amp;amp; include file
├── moudle2
├── source &amp;amp; include file
├── ......
├── doc
├── tests
├── samples
├── benchmarks
├── docker
├── CMakeLists.txt复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-3-模板三&#34;&gt;3.3 模板三&lt;/h3&gt;
&lt;p&gt;该软件项目可以分为很多模块，各个模块可以互相独立，也可以组合在一起，典型的如opencv项目，当然这个也适用于应用项目，但是应用项目的话目录结构太深，开发编辑上稍有不便：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-txt&#34;&gt;├── 3rdparty
├── cmake
├── platforms
│   └── linux
│   └── arm.toolchain.cmake
├── include 该目录只是各功能模块头文件的一个汇总包含
├── modules
├── moudle1
├── src
├── include
├── moudle2
├── ......
├── doc
├── tests
├── samples
├── benchmarks
├── docker
├── CMakeLists.txt复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-优雅的软件项目结构模板cmake实现&#34;&gt;4 优雅的软件项目结构模板CMake实现&lt;/h2&gt;
&lt;p&gt;这里我们只去实现模板二，其他模板大同小异。如上面模板章节所述，我们&lt;/p&gt;
&lt;h3 id=&#34;4-1-目录结构确定&#34;&gt;4.1 目录结构确定&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;.
├── 3rdparty # 第三方库源码依赖和库依赖存放位置
│   ├── CMakeLists.txt # 第三方库源码依赖编译CMakeLists文件
│   ├── spdlog # 源码依赖示例项目spdlog(github可搜索)
│   └── target # 库依赖存放目录
│   ├── linux_armv7-a # 以平台和架构命名区分
│   │   ├── include # 头文件存放目录
│   │   └── lib # 库文件存放目录
│   └── linux_x86-64
│   ├── include
│   └── lib
├── cmake # 存放项目相关的cmakem模块文件
│   ├── load_3rdparty.cmake
│   ├── messagecolor.cmake
│   ├── toolchain_options.cmake
│   └── utils.cmake
├── CMakeLists.txt # 项目根目录CMakeLists文件，cmake入口文件
├── conf # 项目配置文件存放目录
├── doc # 项目文档存放目录
├── platforms # 项目平台性相关内容存放目录，包括交叉编译
│   └── linux
│   └── arm.himix200.cmake
├── README.md # 项目说明
├── scripts # 相关脚本存放目录，包括持续集成和部署相关
├── src # 项目源码目录
│   ├── CMakeLists.txt
│   ├── common
│   ├── logger
│   └── main
└── tests # 测试示例源码存放目录
├── CMakeLists.txt
└── test_logger.cpp复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-2-项目版本的管理&#34;&gt;4.2 项目版本的管理&lt;/h3&gt;
&lt;p&gt;不管是SDK或者是APP项目，都会有一个版本，用来记录软件发布的每个节点。软件版本可以方便用户或者自己清楚的知道每个版本都有哪些内容的更新，可以对版本做出使用的选择或者解决版本中遇到的bug。实现版本的管理，需要能够在编译过程中清楚的体现当前版本号，在软件中也能够获取版本号。这里版本编号的管理使用常见的&lt;code&gt;major.minor(.patch)&lt;/code&gt;格式，major是最大的版本编号，minor为其次，patch对应着小版本里的补丁级别。当有极大的更新时，会增加major的版号，而当有大更新，但不至于更新major时，会更新minor的版号，若更新比较小，例如只是bug fixing，则会更新patch的版号。版本号格式示例：&lt;code&gt;v1.0&lt;/code&gt; 、&lt;code&gt;v1.2.2&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;在优雅的构建软件模板中，我们将版本信息放置于&lt;code&gt;src/common/version.hpp&lt;/code&gt;文件中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：所有的文件路径都是相对项目根目录而言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-c&#34;&gt;#pragma once
// for cmake
// 用于在CMakeLists文件中解析用
// 0.1.0
#define HELLO_APP_VER_MAJOR 0
#define HELLO_APP_VER_MINOR 1
#define HELLO_APP_VER_PATCH 0
#define HELLO_APP_VERSION (HELLO_APP_VER_MAJOR * 10000 + HELLO_APP_VER_MINOR * 100 + HELLO_APP_VER_PATCH)
// for source code
// 用于在项目源码中获取版本号字符串
// v0.1.0
#define _HELLO_APP_STR(s) #s
#define HELLO_PROJECT_VERSION(major, minor, patch) &amp;quot;v&amp;quot; _HELLO_APP_STR(major.minor.patch)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在CMakeLists模块文件中我们去解析该文件获取版本号到CMake变量中，在&lt;code&gt;cmake/utils.cmake&lt;/code&gt;添加宏函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;FUNCTION(hello_app_extract_version)
FILE(READ &amp;quot;${CMAKE_CURRENT_LIST_DIR}/src/common/version.hpp&amp;quot; file_contents)
STRING(REGEX MATCH &amp;quot;HELLO_APP_VER_MAJOR ([0-9]+)&amp;quot; _ &amp;quot;${file_contents}&amp;quot;)
IF(NOT CMAKE_MATCH_COUNT EQUAL 1)
MESSAGE(FATAL_ERROR &amp;quot;Could not extract major version number from version.hpp&amp;quot;)
ENDIF()
SET(ver_major ${CMAKE_MATCH_1})
STRING(REGEX MATCH &amp;quot;HELLO_APP_VER_MINOR ([0-9]+)&amp;quot; _ &amp;quot;${file_contents}&amp;quot;)
IF(NOT CMAKE_MATCH_COUNT EQUAL 1)
MESSAGE(FATAL_ERROR &amp;quot;Could not extract minor version number from version.hpp&amp;quot;)
ENDIF()
SET(ver_minor ${CMAKE_MATCH_1})
STRING(REGEX MATCH &amp;quot;HELLO_APP_VER_PATCH ([0-9]+)&amp;quot; _ &amp;quot;${file_contents}&amp;quot;)
IF(NOT CMAKE_MATCH_COUNT EQUAL 1)
MESSAGE(FATAL_ERROR &amp;quot;Could not extract patch version number from version.hpp&amp;quot;)
ENDIF()
SET(ver_patch ${CMAKE_MATCH_1})
SET(HELLO_APP_VERSION_MAJOR ${ver_major} PARENT_SCOPE)
SET (HELLO_APP_VERSION &amp;quot;${ver_major}.${ver_minor}.${ver_patch}&amp;quot; PARENT_SCOPE)
ENDFUNCTION()复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在根目录CMakeLists中调用版本宏：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;CMAKE_MINIMUM_REQUIRED(VERSION 3.4)
#--------------------------------------------
# Project setting
#--------------------------------------------
INCLUDE(cmake/utils.cmake)
HELLO_APP_EXTRACT_VERSION()
PROJECT(HelloApp VERSION ${HELLO_APP_VERSION} LANGUAGES CXX)
MESSAGE(INFO &amp;quot;--------------------------------&amp;quot;)
MESSAGE(STATUS &amp;quot;Build HelloApp: ${HELLO_APP_VERSION}&amp;quot;)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在后面的动静态库生成中就可以设定SOVERSION了，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;SET_TARGET_PROPERTIES(MyLib PROPERTIES VERSION ${HELLO_APP_VERSION}
SOVERSION ${HELLO_APP_VERSION_MAJOR})复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就会生成一个&lt;code&gt;liMyLibr.so =&amp;gt; liMyLib.so.0 =&amp;gt; libMyLib.so.0.1.1&lt;/code&gt;的库和相关软链接。不过这个操作谨慎使用，因为在android平台jni依赖带版本的库是无法找到的。&lt;/p&gt;
&lt;h3 id=&#34;4-3-第三方库库依赖&#34;&gt;4.3 第三方库库依赖&lt;/h3&gt;
&lt;p&gt;第三方库依赖需要我们自己写库和头文件查找函数，三方库存放位置以平台和架构作为区分，目录结构随着工程的创建就基本不会改变了。库发现宏函数如下示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;# Once done, this will define
#
# SPDLOG_INCLUDE_DIR - the SPDLOG include directory
# SPDLOG_LIBRARY_DIR - the SPDLOG library directory
# SPDLG_LIBS - link these to use SPDLOG
#
# ......
MACRO(LOAD_LIBSPDLOG os arch)
SET(3RDPARTY_DIR ${PROJECT_SOURCE_DIR}/3rdparty/target/${${os}}_${${arch}})
MESSAGE(STATUS &amp;quot;3RDPARTY_DIR: ${3RDPARTY_DIR}&amp;quot;)
FIND_FILE(SPDLOG_INCLUDE_DIR include ${3RDPARTY_DIR} NO_DEFAULT_PATH)
FIND_FILE(SPDLOG_LIBRARY_DIR lib ${3RDPARTY_DIR} NO_DEFAULT_PATH)
SET(SPDLOG_LIBS
spdlog
pthread
#PARENT_SCOPE no parent
)
IF(SPDLOG_INCLUDE_DIR)
SET(SPDLOG_LIBRARY_DIR &amp;quot;${SPDLOG_LIBRARY_DIR}/spdlog&amp;quot;)
MESSAGE(STATUS &amp;quot;SPDLOG_INCLUDE_DIR : ${SPDLOG_INCLUDE_DIR}&amp;quot;)
MESSAGE(STATUS &amp;quot;SPDLOG_LIBRARY_DIR : ${SPDLOG_LIBRARY_DIR}&amp;quot;)
MESSAGE(STATUS &amp;quot;SPDLOG_LIBS : ${SPDLOG_LIBS}&amp;quot;)
ELSE()
MESSAGE(FATAL_ERROR &amp;quot;SPDLOG_LIBS not found!&amp;quot;)
ENDIF()
ENDMACRO()复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如&lt;code&gt;SPDLOG_LIBS&lt;/code&gt;变量如果宏函数在根目录CMakeLists中调用，所以变量作用域可以作用到所有子目录，如果不是在根目录调用，则需要设置&lt;code&gt;PARENT_SCOPE&lt;/code&gt;属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在主CMakeLists中调用宏函数实现三方库的信息导入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;INCLUDE(cmake/load_3rdparty.cmake)
IF(NOT YOUR_TARGET_OS)
SET(YOUR_TARGET_OS linux)
ENDIF()
IF(NOT YOUR_TARGET_ARCH)
SET(YOUR_TARGET_ARCH x86-64)
ENDIF()
MESSAGE(STATUS &amp;quot;Your target os : ${YOUR_TARGET_OS}&amp;quot;)
MESSAGE(STATUS &amp;quot;Your target arch : ${YOUR_TARGET_ARCH}&amp;quot;)
LOAD_LIBSPDLOG(YOUR_TARGET_OS YOUR_TARGET_ARCH)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-4-第三方库源码依赖&#34;&gt;4.4 第三方库源码依赖&lt;/h3&gt;
&lt;p&gt;如果你想依赖第三方项目源码，一起编译，则我们可以通过&lt;code&gt;git submodule&lt;/code&gt;来管理第三方源码，实现源码依赖和它的版本管理。当然你可以不用git submodule，直接将源码手动放入&lt;code&gt;3rdparty&lt;/code&gt;目录中。&lt;/p&gt;
&lt;p&gt;添加一个git submodule:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;# url为git项目地址
# path为项目存放目录，可以多级目录，目录名一般为项目名称
# git add &amp;lt;url.git&amp;gt; &amp;lt;path&amp;gt;
# 示例，执行后，会直接拉取项目源码到3rdparty/spdlog目录下，并创建.gitmodule在仓库根目录下
$ git submodule add https://github.com/gabime/spdlog.git 3rdparty/spdlog复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以做到带指定分支进行添加操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;# 注意：命令需要在项目根目录下执行，第一次会直接拉取源码，不用update
$ git submodule add -b v1.x https://github.com/gabime/spdlog.git 3rdparty/spdlog
$ git submodule update --remote 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后的&lt;code&gt;.gitmodules&lt;/code&gt;文件为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-.gitmodules&#34;&gt;[submodule &amp;quot;3rdparty/spdlog&amp;quot;]
path = 3rdparty/spdlog
url = https://github.com/gabime/spdlog.git
branch = v1.x复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现三方项目源码编译（首先你依赖的三方项目源码是支持CMake构建方式的），在&lt;code&gt;3rdparty/CMakeLists.txt&lt;/code&gt;中编写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;CMAKE_MINIMUM_REQUIRED(VERSION 3.4)
PROJECT(HiApp3rdparty)
ADD_SUBDIRECTORY(spdlog) 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在根目录CMakeLists.txt中包含3rdparty中CMakeLists.txt，就可以编译第三方库了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;ADD_SUBDIRECTORY(3rdparty)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;TARGET_LINK_LIBRARIES&lt;/code&gt;就可以指定第三方项目名称实现链接。&lt;/p&gt;
&lt;h3 id=&#34;4-5-功能模块添加&#34;&gt;4.5 功能模块添加&lt;/h3&gt;
&lt;h3 id=&#34;4-5-1-功能模块编译&#34;&gt;4.5.1 功能模块编译&lt;/h3&gt;
&lt;p&gt;比如我们要添加一个日志模块，实现对&lt;code&gt;spdlog&lt;/code&gt;项目的一个二次封装，更好的在自己的项目中使用，那么我们建立&lt;code&gt;src/logger&lt;/code&gt;目录，里面新建&lt;code&gt;logger.hpp&lt;/code&gt;、&lt;code&gt;logger.cpp&lt;/code&gt;和&lt;code&gt;CMakeLists.txt&lt;/code&gt;三个文件，其中CMakeLists.txt内容是对该日志模块实现编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;CMAKE_MINIMUM_REQUIRED(VERSION 3.4)
AUX_SOURCE_DIRECTORY(. CURRENT_DIR_SRCS)
ADD_LIBRARY(module_logger ${CURRENT_DIR_SRCS})
# SPDLOG_LIBS 为spdlog项目库名称
TARGET_LINK_LIBRARIES(module_logger ${SPDLOG_LIBS}) 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;src/CMakeLists.txt&lt;/code&gt;中包含该日志模块的编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;ADD_SUBDIRECTORY(logger)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在根目录&lt;code&gt;CMakeLists.txt&lt;/code&gt;中包含子目录&lt;code&gt;src&lt;/code&gt;，从而实现功能模块的构建：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;ADD_SUBDIRECTORY(src)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注： 为了演示，库依赖和源码依赖都是用的spdlog，这里实现日志模块的话需要选择其中一种方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-5-2-可执行文件编译&#34;&gt;4.5.2 可执行文件编译&lt;/h3&gt;
&lt;p&gt;如果我们需要实现可执行文件对日志模块的调用，我们可以添加&lt;code&gt;src/main/main.cpp&lt;/code&gt;文件，在&lt;code&gt;src/CMakeLists.txt&lt;/code&gt;中添加对可执行文件的编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;# main app
SET(SRC_LIST ./main/main.cpp)
ADD_EXECUTABLE(HiApp ${SRC_LIST})
# 配置可执行文件输出目录
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
TARGET_LINK_LIBRARIES(HelloApp module_logger) 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，如果使用&lt;code&gt;c++11&lt;/code&gt;的特性，我们可以专门创建一个cmake文件&lt;code&gt;cmake/toolchain_options.cmake&lt;/code&gt;来配置编译选项，在其中配置&lt;code&gt;c++11&lt;/code&gt;编译选项，并在主CMakeLists.txt中包含该cmake文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;# compiler configuration
# 从cmake3.1版本开始才支持CMAKE_CXX_STANDARD配置项
IF(CMAKE_VERSION VERSION_LESS &amp;quot;3.1&amp;quot;)
IF(CMAKE_CXX_COMPILER_ID STREQUAL &amp;quot;GNU&amp;quot;)
SET(CMAKE_CXX_FLAGS &amp;quot;${CMAKE_CXX_FLAGS} -std=gnu++11&amp;quot;)
ENDIF()
ELSE()
SET(CMAKE_CXX_STANDARD 11)
ENDIF() 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-6-测试样例添加&#34;&gt;4.6 测试样例添加&lt;/h3&gt;
&lt;p&gt;测试样例放于&lt;code&gt;tests&lt;/code&gt;目录，并在该目录下建立CMakeLists.txt文件用于构建所有测试demo，并在主CMakeLists.txt下包含&lt;code&gt;tests&lt;/code&gt;目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;CMAKE_MINIMUM_REQUIRED(VERSION 3.4)
PROJECT(Tests)
INCLUDE_DIRECTORIES(
${SPDLOG_INCLUDE_DIR}
${CMAKE_SOURCE_DIR}/src
)
LINK_DIRECTORIES(
${SPDLOG_LIBRARY_DIR}
)
FILE(GLOB APP_SOURCES *.cpp)
FOREACH(testsourcefile ${APP_SOURCES})
STRING(REGEX MATCH &amp;quot;[^/]+$&amp;quot; testsourcefilewithoutpath ${testsourcefile})
STRING(REPLACE &amp;quot;.cpp&amp;quot; &amp;quot;&amp;quot; testname ${testsourcefilewithoutpath})
ADD_EXECUTABLE( ${testname} ${testsourcefile})
SET(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin/tests)
TARGET_LINK_LIBRARIES(${testname}
${SPDLOG_LIBS}
module_logger
)
ENDFOREACH(testsourcefile ${APP_SOURCES})复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后就可以在&lt;code&gt;tests&lt;/code&gt;目录下添加测试程序了，比如&lt;code&gt;test_logger.cpp&lt;/code&gt;或者更多的测试demo，&lt;code&gt;tests/CMakeLists.txt&lt;/code&gt;会自动将&lt;code&gt;tests&lt;/code&gt;目录下所有源文件逐个进行可执行文件生成构建。整个测试样例的构建就完成了。&lt;/p&gt;
&lt;h3 id=&#34;4-7-交叉编译配置&#34;&gt;4.7 交叉编译配置&lt;/h3&gt;
&lt;p&gt;CMake给我们提供了交叉编译的变量设置，即&lt;code&gt;CMAKE_TOOLCHAIN_FILE&lt;/code&gt;这个变量，只要我们指定交叉编译的cmake配置文件，那么cmake会导入该配置文件的中编译器配置，编译选项配置等。我们设计的交叉编译工具链配置文件存放目录在&lt;code&gt;platforms/&lt;/code&gt;下，这里我们使用华为海思的一个编译工具，我们按类别命名，创建一个工具栏cmake配置文件&lt;code&gt;platforms/linux/arm.himix200.cmake&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;MESSAGE(STATUS &amp;quot;Configure Cross Compiler&amp;quot;)
SET(CMAKE_SYSTEM_NAME Linux)
SET(CMAKE_SYSTEM_PROCESSOR arm)
SET(CMAKE_C_COMPILER arm-himix200-linux-gcc)
SET(CMAKE_CXX_COMPILER arm-himix200-linux-g++)
# set searching rules for cross-compiler
SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
SET(YOUR_TARGET_OS linux)
SET(YOUR_TARGET_ARCH armv7-a)
SET(CMAKE_SKIP_BUILD_RPATH TRUE)
SET(CMAKE_SKIP_RPATH TRUE)
# set ${CMAKE_C_FLAGS} and ${CMAKE_CXX_FLAGS}flag for cross-compiled process
#SET(CROSS_COMPILATION_ARM himix200)
#SET(CROSS_COMPILATION_ARCHITECTURE armv7-a)
# set g++ param
# -fopenmp link libgomp
SET(CMAKE_CXX_FLAGS &amp;quot;-std=c++11 -march=armv7-a -mfloat-abi=softfp -mfpu=neon-vfpv4 \
-ffunction-sections \
-fdata-sections -O2 -fstack-protector-strong -lm -ldl -lstdc++\
${CMAKE_CXX_FLAGS}&amp;quot;)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：交叉编译工具链是需要在编译主机上安装好的。另外第三方库库依赖也需要对应编译出工具链版本（源码依赖除外）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令行执行交叉编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;$ mkdir build
$ cd build
$ cmake .. -DCMAKE_TOOLCHAIN_FILE=../platforms/linux/arm.himix200.cmake
$ make -j复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就实现了交叉编译，你也可以配置其他的交叉编译工具链。&lt;/p&gt;
&lt;h3 id=&#34;4-8-其他&#34;&gt;4.8 其他&lt;/h3&gt;
&lt;h4 id=&#34;4-8-1-cmake-message命令颜色凸显&#34;&gt;4.8.1 cmake message命令颜色凸显&lt;/h4&gt;
&lt;p&gt;我们还可以自定义初始化cmake构建的&lt;code&gt;message&lt;/code&gt;命令打印颜色，可以方便快速的凸显出错误信息，我们可以创建一个文件&lt;code&gt;cmake/messagecolor.cmake&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;IF(NOT WIN32)
STRING(ASCII 27 Esc)
SET(ColourReset &amp;quot;${Esc}[m&amp;quot;)
SET(ColourBold &amp;quot;${Esc}[1m&amp;quot;)
SET(Red &amp;quot;${Esc}[31m&amp;quot;)
SET(Green &amp;quot;${Esc}[32m&amp;quot;)
SET(Yellow &amp;quot;${Esc}[33m&amp;quot;)
SET(Blue &amp;quot;${Esc}[34m&amp;quot;)
SET(MAGENTA &amp;quot;${Esc}[35m&amp;quot;)
SET(Cyan &amp;quot;${Esc}[36m&amp;quot;)
SET(White &amp;quot;${Esc}[37m&amp;quot;)
SET(BoldRed &amp;quot;${Esc}[1;31m&amp;quot;)
SET(BoldGreen &amp;quot;${Esc}[1;32m&amp;quot;)
SET(BoldYellow &amp;quot;${Esc}[1;33m&amp;quot;)
SET(BOLDBLUE &amp;quot;${Esc}[1;34m&amp;quot;)
SET(BOLDMAGENTA &amp;quot;${Esc}[1;35m&amp;quot;)
SET(BoldCyan &amp;quot;${Esc}[1;36m&amp;quot;)
SET(BOLDWHITE &amp;quot;${Esc}[1;37m&amp;quot;)
ENDIF()
FUNCTION(message)
LIST(GET ARGV 0 MessageType)
IF(MessageType STREQUAL FATAL_ERROR OR MessageType STREQUAL SEND_ERROR)
LIST(REMOVE_AT ARGV 0)
_message(${MessageType} &amp;quot;${BoldRed}${ARGV}${ColourReset}&amp;quot;)
ELSEIF(MessageType STREQUAL WARNING)
LIST(REMOVE_AT ARGV 0)
_message(${MessageType}
&amp;quot;${BoldYellow}${ARGV}${ColourReset}&amp;quot;)
ELSEIF(MessageType STREQUAL AUTHOR_WARNING)
LIST(REMOVE_AT ARGV 0)
_message(${MessageType} &amp;quot;${BoldCyan}${ARGV}${ColourReset}&amp;quot;)
ELSEIF(MessageType STREQUAL STATUS)
LIST(REMOVE_AT ARGV 0)
_message(${MessageType} &amp;quot;${Green}${ARGV}${ColourReset}&amp;quot;)
ELSEIF(MessageType STREQUAL INFO)
LIST(REMOVE_AT ARGV 0)
_message(&amp;quot;${Blue}${ARGV}${ColourReset}&amp;quot;)
ELSE()
_message(&amp;quot;${ARGV}&amp;quot;)
ENDIF() 复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主CMakeLists.txt中导入该cmake文件，则可以改变message命令各个级别打印的颜色显示。&lt;/p&gt;
&lt;h4 id=&#34;4-8-2-debug与release构建&#34;&gt;4.8.2 Debug与Release构建&lt;/h4&gt;
&lt;p&gt;为了方便debug，我们在开发过程中一般是编译&lt;code&gt;Debug&lt;/code&gt;版本的库或者应用，可以利用gdb调试很轻松的就可以发现错误具体所在。在主cmake文件中我们只需要加如下设置即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;IF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_BUILD_TYPE &amp;quot;Debug&amp;quot; CACHE STRING &amp;quot;Choose Release or Debug&amp;quot; FORCE)
ENDIF()
MESSAGE(STATUS &amp;quot;Build type: &amp;quot; ${CMAKE_BUILD_TYPE})复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行cmake命令的时候可以设置&lt;code&gt;CMAKE_BUILD_TYPE&lt;/code&gt;变量值切换&lt;code&gt;Debug&lt;/code&gt;或者&lt;code&gt;Release&lt;/code&gt;版本编译：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;$ cmake .. -DCMAKE_BUILD_TYPE=Release复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-8-3-构建后安装&#34;&gt;4.8.3 构建后安装&lt;/h4&gt;
&lt;p&gt;对于SDK项目，我们需要对外提供头文件和编译完成后的库文件，就需要用到cmake提供的&lt;code&gt;install&lt;/code&gt;命令了。&lt;/p&gt;
&lt;p&gt;我们安装需求是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;目录下的每个模块头文件都能够安装，并按原目录存放安装&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;库文件安装放于&lt;code&gt;lib&lt;/code&gt;目录下&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可执行文件包括测试文件放于&lt;code&gt;bin&lt;/code&gt;目录&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先模块头文件的安装实现均在&lt;code&gt;src/{module}/CMakeLists.txt&lt;/code&gt;中实现，这里是安装目录，并过滤掉&lt;code&gt;.cpp&lt;/code&gt;或者&lt;code&gt;.c&lt;/code&gt;文件以及&lt;code&gt;CMakeLists.txt&lt;/code&gt;文件，以&lt;code&gt;logger&lt;/code&gt;模块为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
DESTINATION ${CMAKE_INSTALL_PREFIX}/include
FILES_MATCHING
PATTERN &amp;quot;*.h&amp;quot;
PATTERN &amp;quot;*.hpp&amp;quot;
PATTERN &amp;quot;CMakeLists.txt&amp;quot; EXCLUDE
)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在UNIX系统上，&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;变量默认指向&lt;code&gt;/usr/local&lt;/code&gt;，在Windows系统上，默认指向&lt;code&gt;c:/Program Files/${PROJECT_NAME}&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后是库文件的安装，也相关&lt;code&gt;ADD_LIBRARY&lt;/code&gt;命令调用后中实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;INSTALL(TARGETS module_logger
ARCHIVE DESTINATION lib
LIBRARY DESTINATION lib
RUNTIME DESTINATION bin)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后是可执行文件的安装，跟安装库是一样的，添加到&lt;code&gt;ADD_EXECUTABLE&lt;/code&gt;命令调用的后面，只是因为是可执行文件，属于&lt;code&gt;RUNTIME&lt;/code&gt;类型，cmake会自动安装到我们设置的bin目录，这里以&lt;code&gt;HelloApp&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-cmake&#34;&gt;INSTALL(TARGETS HelloApp
ARCHIVE DESTINATION lib
LIBRARY DESTINATION lib
RUNTIME DESTINATION bin)复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行安装命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;$ make install DESTDIR=$PWD/install复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则会在相对当前目录&lt;code&gt;install/usr/local&lt;/code&gt;目录下生成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-txt&#34;&gt;.
├── bin
│   ├── HelloApp
│   └── test_logger
├── include
│   ├── common
│   │   ├── common.hpp
│   │   └── version.hpp
│   └── logger
│   └── logger.hpp
└── lib
└── libmodule_logger.a复制代码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，安装完成。&lt;/p&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5 总结&lt;/h2&gt;
&lt;p&gt;“工欲善其事，必先利其器”，把基础筑好，在软件开发过程中也是很重要的，就如项目中需求明确一样，本篇文章我把&lt;code&gt;C/C++&lt;/code&gt;项目开发的整体框架形成一个模板，不断总结改进，方便后续类似项目的快速开发。本篇文章也主要实现项目构建方面的内容，下一篇准备实现一个基本&lt;code&gt;C/C++&lt;/code&gt;框架所必须的基础模块，包括日志模块、线程池、常用基础功能函数模块、配置导入模块、单元测试、内存泄露检查等。如有问题或者改进，一起来交流学习，最后欢迎大家关注我的公众号&lt;code&gt;小白AI&lt;/code&gt;，不打广告，不为了写而写，只为了分享自己的学习过程^_^。&lt;/p&gt;
&lt;p&gt;整个构建模板源码可以在我的github上找到，欢迎star： &lt;a href=&#34;https://github.com/yicm/CMakeCppProjectTemplate&#34; target=&#34;_blank&#34;&gt;github.com/yicm/CMakeC…&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-参考资料&#34;&gt;6 参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oolap.com/cxx-dependency-management-old&#34; target=&#34;_blank&#34;&gt;www.oolap.com/cxx-depende…&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yeolar.com/note/2014/12/16/cmake-how-to-find-libraries/&#34; target=&#34;_blank&#34;&gt;www.yeolar.com/note/2014/1…&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>linux time elapsed</title><link>/language/clang/linux-time-elapsed/</link><pubDate>Fri, 05 Jun 2020 15:58:23 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-time-elapsed/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;long elapsed(START_TIME_TYPE start_time)
{
struct timeval now, res;
gettimeofday(&amp;amp;now, NULL);
timersub(&amp;amp;now, &amp;amp;start_time, &amp;amp;res);
return (res.tv_sec)*1000 + (res.tv_usec)/1000;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux socket ifreq 设置IP地址</title><link>/language/clang/socket/linux-socket-ifreq/</link><pubDate>Thu, 04 Jun 2020 19:27:59 CST</pubDate><author>rinetd</author><guid>/language/clang/socket/linux-socket-ifreq/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000005138358&#34; target=&#34;_blank&#34;&gt;Linux网络接口操作之ioctl-1_接口参数 - 反刍动物 - SegmentFault 思否&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;strace ./ifconfig
socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 5
ioctl(5, SIOCSIFADDR, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_addr={AF_INET, inet_addr(&amp;quot;192.168.1.202&amp;quot;)}}) = 0
ioctl(5, SIOCGIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0
ioctl(5, SIOCSIFFLAGS, {ifr_name=&amp;quot;eth0:8&amp;quot;, ifr_flags=IFF_UP|IFF_BROADCAST|IFF_RUNNING|IFF_MULTICAST}) = 0
close(5) = 0
Complete source code:
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt; /* offsetof */
#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;linux/sockios.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#if __GLIBC__ &amp;gt;=2 &amp;amp;&amp;amp; __GLIBC_MINOR &amp;gt;= 1
#include &amp;lt;netpacket/packet.h&amp;gt;
#include &amp;lt;net/ethernet.h&amp;gt;
#else
#include &amp;lt;asm/types.h&amp;gt;
#include &amp;lt;linux/if_ether.h&amp;gt;
#endif
#define IFNAMSIZ 16
#define IFNAME &amp;quot;eth0:2&amp;quot;
#define HOST &amp;quot;192.168.1.204&amp;quot;
#define ifreq_offsetof(x) offsetof(struct ifreq, x)
int main(int argc, char **argv) {
struct ifreq ifr;
struct sockaddr_in sai;
int sockfd; /* socket fd we use to manipulate stuff with */
int selector;
unsigned char mask;
char *p;
/* Create a channel to the NET kernel. */
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
/* get interface name */
strncpy(ifr.ifr_name, IFNAME, IFNAMSIZ);
memset(&amp;amp;sai, 0, sizeof(struct sockaddr));
sai.sin_family = AF_INET;
sai.sin_addr.s_addr = inet_addr(HOST);
sai.sin_port = 0;
p = (char *) &amp;amp;sai;
memcpy( (((char *)&amp;amp;ifr + ifreq_offsetof(ifr_addr) )),
p, sizeof(struct sockaddr));
ioctl(sockfd, SIOCSIFADDR, &amp;amp;ifr);
// set the interface to up
ioctl(sockfd, SIOCGIFFLAGS, &amp;amp;ifr);
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
// ifr.ifr_flags &amp;amp;= ~selector; // unset something
ioctl(sockfd, SIOCSIFFLAGS, &amp;amp;ifr);
close(sockfd);
return 0;
}
Perhaps you forgot to set the interface to up?
ioctl(sockfd, SIOCGIFFLAGS, &amp;amp;ifr);
ifr.ifr_flags |= IFF_UP | IFF_RUNNING;
ioctl(sockfd, SIOCSIFFLAGS, &amp;amp;ifr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux提供了一系列网络接口操作相关的命令集，其中，一些传统的工具，如net-tools软件包中的ifconfig(8)，arp(8)，route(8)等都是通过ioctl(2)系统调用实现&lt;br /&gt;
本篇介绍使用ioctl(2)进行网络接口参数的获取与设置&lt;/p&gt;
&lt;p&gt;函数原型&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
int ioctl(int d, int request, ...);&lt;br /&gt;
第一个参数fd指定一个由open(2)/socket(2)创建的文件描述符&lt;br /&gt;
第二个参数request指定操作的类型，即对该文件描述符执行何种操作&lt;br /&gt;
第三个参数为一块内存区域，通常依赖于request指定的操作类型&lt;/p&gt;
&lt;p&gt;接口参数与操作的相关定义&lt;br /&gt;
内核版本：2.6.32.5&lt;/p&gt;
&lt;p&gt;ioctl(2)使用struct ifreq与/或struct ifconf结构执行网络接口相关的操作，这两个结构的地址作为ioctl(2)的第三个参数&lt;/p&gt;
&lt;p&gt;/* include/linux/if.h */&lt;/p&gt;
&lt;p&gt;#define IFNAMSIZ 16&lt;br /&gt;
#define IFALIASZ 256&lt;/p&gt;
&lt;p&gt;struct ifreq&lt;br /&gt;
{&lt;br /&gt;
#define IFHWADDRLEN 6&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;union
{
char ifrn_name[IFNAMSIZ];
} ifr_ifrn;
union {
struct sockaddr ifru_addr;
struct sockaddr ifru_dstaddr;
struct sockaddr ifru_broadaddr;
struct sockaddr ifru_netmask;
struct sockaddr ifru_hwaddr;
short ifru_flags;
int ifru_ivalue;
int ifru_mtu;
struct ifmap ifru_map;
char ifru_slave[IFNAMSIZ];
char ifru_newname[IFNAMSIZ];
void __user * ifru_data;
struct if_settings ifru_settings;
} ifr_ifru;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;#define ifr_name ifr_ifrn.ifrn_name /* interface name &lt;em&gt;/&lt;br /&gt;
#define ifr_hwaddr ifr_ifru.ifru_hwaddr /&lt;/em&gt; MAC address &lt;em&gt;/&lt;br /&gt;
#define ifr_addr ifr_ifru.ifru_addr /&lt;/em&gt; address &lt;em&gt;/&lt;br /&gt;
#define ifr_dstaddr ifr_ifru.ifru_dstaddr /&lt;/em&gt; other end of p-p lnk &lt;em&gt;/&lt;br /&gt;
#define ifr_broadaddr ifr_ifru.ifru_broadaddr /&lt;/em&gt; broadcast address &lt;em&gt;/&lt;br /&gt;
#define ifr_netmask ifr_ifru.ifru_netmask /&lt;/em&gt; interface net mask &lt;em&gt;/&lt;br /&gt;
#define ifr_flags ifr_ifru.ifru_flags /&lt;/em&gt; flags &lt;em&gt;/&lt;br /&gt;
#define ifr_metric ifr_ifru.ifru_ivalue /&lt;/em&gt; metric &lt;em&gt;/&lt;br /&gt;
#define ifr_mtu ifr_ifru.ifru_mtu /&lt;/em&gt; mtu &lt;em&gt;/&lt;br /&gt;
#define ifr_map ifr_ifru.ifru_map /&lt;/em&gt; device map &lt;em&gt;/&lt;br /&gt;
#define ifr_slave ifr_ifru.ifru_slave /&lt;/em&gt; slave device &lt;em&gt;/&lt;br /&gt;
#define ifr_data ifr_ifru.ifru_data /&lt;/em&gt; for use by interface &lt;em&gt;/&lt;br /&gt;
#define ifr_ifindex ifr_ifru.ifru_ivalue /&lt;/em&gt; interface index &lt;em&gt;/&lt;br /&gt;
#define ifr_bandwidth ifr_ifru.ifru_ivalue /&lt;/em&gt; link bandwidth &lt;em&gt;/&lt;br /&gt;
#define ifr_qlen ifr_ifru.ifru_ivalue /&lt;/em&gt; Queue length &lt;em&gt;/&lt;br /&gt;
#define ifr_newname ifr_ifru.ifru_newname /&lt;/em&gt; New name &lt;em&gt;/&lt;br /&gt;
#define ifr_settings ifr_ifru.ifru_settings /&lt;/em&gt; Device/proto settings*/&lt;/p&gt;
&lt;p&gt;struct ifconf&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ifc_len;
union
{
char __user *ifcu_buf;
struct ifreq __user *ifcu_req;
} ifc_ifcu;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;#define ifc_buf ifc_ifcu.ifcu_buf /* buffer address &lt;em&gt;/&lt;br /&gt;
#define ifc_req ifc_ifcu.ifcu_req /&lt;/em&gt; array of structures */&lt;br /&gt;
操作类型，ioctl(2)的第二个参数&lt;/p&gt;
&lt;p&gt;/* include/linux/sockios.h */&lt;/p&gt;
&lt;p&gt;/* Socket configuration controls. &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFNAME 0x8910 /&lt;/em&gt; get iface name &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFLINK 0x8911 /&lt;/em&gt; set iface channel &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFCONF 0x8912 /&lt;/em&gt; get iface list &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFFLAGS 0x8913 /&lt;/em&gt; get flags &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFFLAGS 0x8914 /&lt;/em&gt; set flags &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFADDR 0x8915 /&lt;/em&gt; get PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFADDR 0x8916 /&lt;/em&gt; set PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFDSTADDR 0x8917 /&lt;/em&gt; get remote PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFDSTADDR 0x8918 /&lt;/em&gt; set remote PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFBRDADDR 0x8919 /&lt;/em&gt; get broadcast PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFBRDADDR 0x891a /&lt;/em&gt; set broadcast PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFNETMASK 0x891b /&lt;/em&gt; get network PA mask &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFNETMASK 0x891c /&lt;/em&gt; set network PA mask &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFMETRIC 0x891d /&lt;/em&gt; get metric &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFMETRIC 0x891e /&lt;/em&gt; set metric &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFMEM 0x891f /&lt;/em&gt; get memory address (BSD) &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFMEM 0x8920 /&lt;/em&gt; set memory address (BSD) &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFMTU 0x8921 /&lt;/em&gt; get MTU size &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFMTU 0x8922 /&lt;/em&gt; set MTU size &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFNAME 0x8923 /&lt;/em&gt; set interface name &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFHWADDR 0x8924 /&lt;/em&gt; set hardware address &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFENCAP 0x8925 /&lt;/em&gt; get/set encapsulations &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFENCAP 0x8926&lt;br /&gt;
#define SIOCGIFHWADDR 0x8927 /&lt;/em&gt; Get hardware address &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFSLAVE 0x8929 /&lt;/em&gt; Driver slaving support &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFSLAVE 0x8930&lt;br /&gt;
#define SIOCADDMULTI 0x8931 /&lt;/em&gt; Multicast address lists &lt;em&gt;/&lt;br /&gt;
#define SIOCDELMULTI 0x8932&lt;br /&gt;
#define SIOCGIFINDEX 0x8933 /&lt;/em&gt; name -&amp;gt; if_index mapping &lt;em&gt;/&lt;br /&gt;
#define SIOGIFINDEX SIOCGIFINDEX /&lt;/em&gt; misprint compatibility :-) &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFPFLAGS 0x8934 /&lt;/em&gt; set/get extended flags set &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFPFLAGS 0x8935&lt;br /&gt;
#define SIOCDIFADDR 0x8936 /&lt;/em&gt; delete PA address &lt;em&gt;/&lt;br /&gt;
#define SIOCSIFHWBROADCAST 0x8937 /&lt;/em&gt; set hardware broadcast addr &lt;em&gt;/&lt;br /&gt;
#define SIOCGIFCOUNT 0x8938 /&lt;/em&gt; get number of devices &lt;em&gt;/&lt;br /&gt;
...&lt;br /&gt;
#define SIOCETHTOOL 0x8946 /&lt;/em&gt; Ethtool interface */&lt;br /&gt;
结构字段与操作类型的含义在大都在注释中已注明&lt;/p&gt;
&lt;p&gt;一般步骤&lt;br /&gt;
通过ioctl(2)执行网络接口参数的获取/设置的一般步骤为：&lt;/p&gt;
&lt;p&gt;通过socket(2)创建IP套接字；由于ioctl(2)此时是与内核通信，因此对套接字的通信域与类型没有强制要求，通信域可以为AF_INET/AF_LOCAL，类型可以为SOCK_DGRAM/SOCK_STREAM/SOCK_RAW等&lt;/p&gt;
&lt;p&gt;初始化struct ifconf与/或struct ifreq结构&lt;/p&gt;
&lt;p&gt;对套接字描述符调用ioctl(2)，执行相应类型的SIO操作&lt;/p&gt;
&lt;p&gt;获取返回至truct ifconf与/或struct ifreq结构中的相关信息&lt;/p&gt;
&lt;p&gt;示例程序&lt;br /&gt;
本地网络接口信息：eth0网线已连接且已配置IPv4地址，eth1网线未连接且未配置IPv4地址&lt;/p&gt;
&lt;h1 id=&#34;ip-l&#34;&gt;ip l&lt;/h1&gt;
&lt;p&gt;1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/ether 00:0c:29:ed:9d:28 brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3: eth1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN qlen 1000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/ether 00:0c:29:ed:9d:32 brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ip-a&#34;&gt;ip a&lt;/h1&gt;
&lt;p&gt;1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
inet6 ::1/128 scope host
valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/ether 00:0c:29:ed:9d:28 brd ff:ff:ff:ff:ff:ff
inet 192.168.56.139/24 brd 192.168.56.255 scope global eth0
inet6 fe80::20c:29ff:feed:9d28/64 scope link
valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3: eth1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN qlen 1000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;link/ether 00:0c:29:ed:9d:32 brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1 . 通过SIOCGIFCONF操作获取系统中所有的网络接口&lt;/p&gt;
&lt;p&gt;/* list_network_interfaces_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;/p&gt;
&lt;p&gt;#define BUFSIZE 1024&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, if_count, i;
struct ifconf ifc;
struct ifreq ifr[10];
char ipaddr[INET_ADDRSTRLEN] = {&#39;\0&#39;};
memset(&amp;amp;ifc, 0, sizeof(struct ifconf));
sfd = socket(AF_INET, SOCK_DGRAM, 0);
ifc.ifc_len = 10 * sizeof(struct ifreq);
ifc.ifc_buf = (char *)ifr;
/* SIOCGIFCONF is IP specific. see netdevice(7) */
ioctl(sfd, SIOCGIFCONF, (char *)&amp;amp;ifc);
if_count = ifc.ifc_len / (sizeof(struct ifreq));
for (i = 0; i &amp;lt; if_count; i++) {
printf(&amp;quot;Interface %s : &amp;quot;, ifr[i].ifr_name);
inet_ntop(AF_INET,
&amp;amp;(((struct sockaddr_in *)&amp;amp;(ifr[i].ifr_addr))-&amp;gt;sin_addr),
ipaddr, INET_ADDRSTRLEN);
printf(&amp;quot;%s\n&amp;quot;, ipaddr);
}
close(sfd);
exit(EXIT_SUCCESS);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-list-network-interfaces-ioctl-c-g-o-list-network-interfaces-ioctl&#34;&gt;gcc list_network_interfaces_ioctl.c -g -o list_network_interfaces_ioctl&lt;/h1&gt;
&lt;h1 id=&#34;list-network-interfaces-ioctl&#34;&gt;./list_network_interfaces_ioctl&lt;/h1&gt;
&lt;p&gt;Interface lo : 127.0.0.1&lt;br /&gt;
Interface eth0 : 192.168.56.139&lt;br /&gt;
SIOCGIFCONF操作需要同时使用struct ifconf与struct ifreq&lt;br /&gt;
初始化struct ifconf时，ifc_ifcu指定一个缓冲区的首地址，缓冲区中保存若干个连续的struct ifreq，ifc_len指定该缓冲区的长度；ioctl(2)返回后，内核将为每一个配置了IPv4地址的本地网络接口分配一个struct ifreq并保存到初始化的缓冲区中，struct ifreq中保存单个网络接口的名称及IPv4地址，struct ifconf的ifc_len被更新为初始化缓冲区中实际返回的数据长度&lt;/p&gt;
&lt;p&gt;2 . 通过SIOCGIFADDR操作获取指定网络接口的IPv4地址&lt;/p&gt;
&lt;p&gt;/* get_interface_ip_address_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;/p&gt;
&lt;p&gt;static char *get_ipaddr(const char *);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 2) {
fprintf(stderr, &amp;quot;Usage: %s [network interface name]\n&amp;quot;, argv[0]);
exit(EXIT_FAILURE);
}
char ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(ifname, argv[1], IFNAMSIZ-1);
char *ip = get_ipaddr(ifname);
printf(&amp;quot;Interface %s : %s\n&amp;quot;, ifname, ip);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static char *get_ipaddr(const char *dev)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, saved_errno, ret;
struct ifreq ifr;
char *ipaddr;
ipaddr = (char *)malloc(INET_ADDRSTRLEN);
memset(&amp;amp;ifr, 0, sizeof(ifr));
ifr.ifr_addr.sa_family = AF_INET;
strncpy(ifr.ifr_name, dev, IFNAMSIZ);
sfd = socket(AF_INET, SOCK_DGRAM, 0);
errno = saved_errno;
ret = ioctl(sfd, SIOCGIFADDR, &amp;amp;ifr);
if (ret == -1) {
if (errno == 19) {
fprintf(stderr, &amp;quot;Interface %s : No such device.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
if (errno == 99) {
fprintf(stderr, &amp;quot;Interface %s : No IPv4 address assigned.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
}
saved_errno = errno;
inet_ntop(AF_INET, &amp;amp;(((struct sockaddr_in *)&amp;amp;ifr.ifr_addr)-&amp;gt;sin_addr), ipaddr, INET_ADDRSTRLEN);
close(sfd);
return ipaddr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-get-interface-ip-address-ioctl-c-g-o-get-interface-ip-address-ioctl&#34;&gt;gcc get_interface_ip_address_ioctl.c -g -o get_interface_ip_address_ioctl&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-ip-address-ioctl-eth0&#34;&gt;./get_interface_ip_address_ioctl eth0&lt;/h1&gt;
&lt;p&gt;Interface eth0 : 192.168.56.139&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-ip-address-ioctl-eth1&#34;&gt;./get_interface_ip_address_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : No IPv4 address assigned.&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-ip-address-ioctl-eth2&#34;&gt;./get_interface_ip_address_ioctl eth2&lt;/h1&gt;
&lt;p&gt;Interface eth2 : No such device.&lt;br /&gt;
SIOCGIFADDR操作使用struct ifreq中的ifr_ifru.ifru_addr字段；ifr_ifrn.ifrn_name指定为网络接口名称并调用ioctl(SIOCGIFADDR)，返回后将ifr_ifru.ifru_addr转换为IPv4套接字地址结构，IPv4地址保存在该结构中的sin_addr字段中&lt;/p&gt;
&lt;p&gt;SIOCGIFCONF与SIOCGIFADDR属于IPv4特定的操作，对于未配置IPv4地址的网络接口，ioctl(SIOCGIFCONF)返回时不会分配struct ifreq结构，因而不会返回该接口的名称，而ioctl(SIOCGIFADDR)将以errno值99(Cannot assign requested address)而调用失败&lt;br /&gt;
若指定了系统中不存在的网络接口，则errno的值为19(No such device)&lt;/p&gt;
&lt;p&gt;SIOCGIFCONF与SIOCGIFADDR无法获取网络接口的IPv6地址，ioctl的内核源码中通过读取/proc/net/if_inet6获取&lt;/p&gt;
&lt;p&gt;3 . 通过SIOCGIFHWADDR操作获取指定网络接口的mac地址&lt;/p&gt;
&lt;p&gt;/* get_interface_mac_address_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;netinet/if_ether.h&gt;&lt;br /&gt;
#include &lt;net/if_arp.h&gt;&lt;/p&gt;
&lt;p&gt;static unsigned char *get_if_mac(const char *);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 2) {
fprintf(stderr, &amp;quot;Usage: %s [network interface name]\n&amp;quot;, argv[0]);
exit(EXIT_FAILURE);
}
char ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(ifname, argv[1], IFNAMSIZ-1);
unsigned char *mac = get_if_mac(ifname);
printf(&amp;quot;Interface %s : %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&amp;quot;,
ifname, *mac, *(mac+1), *(mac+2), *(mac+3), *(mac+4), *(mac+5));
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static unsigned char *get_if_mac(const char *dev)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, ret, saved_errno, i;
unsigned char *mac_addr;
struct ifreq ifr;
mac_addr = (unsigned char *)malloc(ETH_ALEN);
sfd = socket(AF_INET, SOCK_DGRAM, 0);
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, dev, IFNAMSIZ);
saved_errno = errno;
ret = ioctl(sfd, SIOCGIFHWADDR, &amp;amp;ifr);
if (ret == -1 &amp;amp;&amp;amp; errno == 19) {
fprintf(stderr, &amp;quot;Interface %s : No such device.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
errno = saved_errno;
if (ifr.ifr_addr.sa_family == ARPHRD_LOOPBACK) {
printf(&amp;quot;Interface %s : A Loopback device.\n&amp;quot;, dev);
printf(&amp;quot;MAC address is always 00:00:00:00:00:00\n&amp;quot;);
exit(EXIT_SUCCESS);
}
if (ifr.ifr_addr.sa_family != ARPHRD_ETHER) {
fprintf(stderr, &amp;quot;Interface %s : Not an Ethernet device.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
memcpy(mac_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
return (unsigned char *)mac_addr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-get-interface-mac-address-ioctl-c-g-o-get-interface-mac-address-ioctl&#34;&gt;gcc get_interface_mac_address_ioctl.c -g -o get_interface_mac_address_ioctl&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-mac-address-ioctl-lo&#34;&gt;./get_interface_mac_address_ioctl lo&lt;/h1&gt;
&lt;p&gt;Interface lo : A Loopback device.&lt;br /&gt;
MAC address is always 00:00:00:00:00:00&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-mac-address-ioctl-eth0&#34;&gt;./get_interface_mac_address_ioctl eth0&lt;/h1&gt;
&lt;p&gt;Interface eth0 : 00:0c:29:ed:9d:28&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-mac-address-ioctl-eth1&#34;&gt;./get_interface_mac_address_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : 00:0c:29:ed:9d:32&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-mac-address-ioctl-eth2&#34;&gt;./get_interface_mac_address_ioctl eth2&lt;/h1&gt;
&lt;p&gt;Interface eth2 : No such device.&lt;br /&gt;
SIOCGIFHWADDR操作使用struct ifreq中的ifr_ifru.ifru_hwaddr字段，在ifr_ifrn.ifrn_name中填充指定的网络接口名称后，该接口的mac地址按顺序返回到ifr_ifru.ifru_hwaddr.sa_data数组的前6个字节中&lt;/p&gt;
&lt;p&gt;4 . 通过SIOCGIFFLAGS操作获取指定网络接口的标志&lt;/p&gt;
&lt;p&gt;/* get_interface_flags_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;netinet/if_ether.h&gt;&lt;br /&gt;
#include &lt;net/if_arp.h&gt;&lt;/p&gt;
&lt;p&gt;static short get_if_flags(int, char *);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 2) {
fprintf(stderr, &amp;quot;Usage: %s [network interface name]\n&amp;quot;, argv[0]);
exit(EXIT_FAILURE);
}
int sfd;
short flags;
char ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(ifname, argv[1], IFNAMSIZ-1);
sfd = socket(AF_INET, SOCK_DGRAM, 0);
flags = get_if_flags(sfd, ifname);
printf(&amp;quot;Interface %s : &amp;quot;, ifname);
if (flags &amp;amp; IFF_UP)
printf(&amp;quot;UP &amp;quot;);
if (flags &amp;amp; IFF_RUNNING)
printf(&amp;quot;RUNNING &amp;quot;);
if (flags &amp;amp; IFF_LOOPBACK)
printf(&amp;quot;LOOPBACK &amp;quot;);
if (flags &amp;amp; IFF_BROADCAST)
printf(&amp;quot;BROADCAST &amp;quot;);
if (flags &amp;amp; IFF_MULTICAST)
printf(&amp;quot;MULTICAST &amp;quot;);
if (flags &amp;amp; IFF_PROMISC)
printf(&amp;quot;PROMISC&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#ifndef IFF_LOWER_UP&lt;br /&gt;
#define IFF_LOWER_UP 0x10000&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (flags &amp;amp; IFF_LOWER_UP)
printf(&amp;quot;LOWER_UP&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#endif&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;\n&amp;quot;);
close(sfd);
exit(EXIT_SUCCESS);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static short get_if_flags(int s, char *dev)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int saved_errno, ret;
short if_flags;
struct ifreq ifr;
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, dev, IFNAMSIZ);
saved_errno = errno;
ret = ioctl(s, SIOCGIFFLAGS, &amp;amp;ifr);
if (ret == -1 &amp;amp;&amp;amp; errno == 19) {
fprintf(stderr, &amp;quot;Interface %s : No such device.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
errno = saved_errno;
if_flags = ifr.ifr_flags;
return if_flags;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-get-interface-flags-ioctl-c-g-o-get-interface-flags-ioctl&#34;&gt;gcc get_interface_flags_ioctl.c -g -o get_interface_flags_ioctl&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-lo&#34;&gt;./get_interface_flags_ioctl lo&lt;/h1&gt;
&lt;p&gt;Interface lo : UP RUNNING LOOPBACK&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-eth0&#34;&gt;./get_interface_flags_ioctl eth0&lt;/h1&gt;
&lt;p&gt;Interface eth0 : UP RUNNING BROADCAST MULTICAST&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-eth1&#34;&gt;./get_interface_flags_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : UP BROADCAST MULTICAST&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-eth2&#34;&gt;./get_interface_flags_ioctl eth2&lt;/h1&gt;
&lt;p&gt;Interface eth2 : No such device.&lt;br /&gt;
ifr_ifrn.ifrn_name指定为网络接口名称后，ioctl(SIOCGIFFLAGS)调用将标志返回到ifr_ifru.ifru_flags字段&lt;/p&gt;
&lt;p&gt;IFF_RUNNING表示该接口已被激活，且可以正常传输数据&lt;/p&gt;
&lt;p&gt;IFF_UP表示giant接口已被激活，但可能无法正常传输数据，如网线未连接的情况&lt;/p&gt;
&lt;p&gt;IFF_LOWER_UP表示网络的物理连接已就绪，即网线连接正常；由于struct ifreq的ifr_ifru.ifru_flags类型为short，用16进制表示仅为4位，因而无法获取与设置5位16进制的IFF_LOWER_UP标志(0x10000)&lt;/p&gt;
&lt;p&gt;5 .通过SIOCSIFADDR操作设置指定网络接口的IPv4地址&lt;/p&gt;
&lt;p&gt;/* set_interface_ip_address_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;/p&gt;
&lt;p&gt;static void set_ipaddr(const char *, const char *);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 3) {
fprintf(stderr, &amp;quot;Usage: %s [network interface name] [ip address]\n&amp;quot;,
argv[0]);
exit(EXIT_FAILURE);
}
char ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(ifname, argv[1], IFNAMSIZ-1);
char ipaddr[INET_ADDRSTRLEN] = {&#39;\0&#39;};
strncpy(ipaddr, argv[2], INET_ADDRSTRLEN);
set_ipaddr(ifname, ipaddr);
printf(&amp;quot;Interface %s : ip address is set to %s\n&amp;quot;, ifname, ipaddr);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static void set_ipaddr(const char *dev, const char *ip)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, saved_errno, ret;
struct ifreq ifr;
struct sockaddr_in sin;
sfd = socket(AF_INET, SOCK_DGRAM, 0);
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, dev, IFNAMSIZ);
memset(&amp;amp;sin, 0, sizeof(sin));
sin.sin_family = AF_INET;
inet_pton(AF_INET, ip, &amp;amp;(sin.sin_addr));
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;sin, sizeof(struct sockaddr));
errno = saved_errno;
ret = ioctl(sfd, SIOCSIFADDR, &amp;amp;ifr);
if (ret == -1) {
if (errno == 19) {
fprintf(stderr, &amp;quot;Interface %s : No such device.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
if (errno == 99) {
fprintf(stderr, &amp;quot;Interface %s : No IPv4 address assigned.\n&amp;quot;, dev);
exit(EXIT_FAILURE);
}
}
saved_errno = errno;
close(sfd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-set-interface-ip-address-ioctl-c-g-o-set-interface-ip-address-ioctl&#34;&gt;gcc set_interface_ip_address_ioctl.c -g -o set_interface_ip_address_ioctl&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;set-interface-ip-address-ioctl-eth1-10-0-0-1&#34;&gt;./set_interface_ip_address_ioctl eth1 10.0.0.1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : ip address is set to 10.0.0.1&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-ip-address-ioctl-eth1-1&#34;&gt;./get_interface_ip_address_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : 10.0.0.1&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;set-interface-ip-address-ioctl-eth1-10-0-0-2&#34;&gt;./set_interface_ip_address_ioctl eth1 10.0.0.2&lt;/h1&gt;
&lt;p&gt;Interface eth1 : ip address is set to 10.0.0.2&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-ip-address-ioctl-eth1-2&#34;&gt;./get_interface_ip_address_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : 10.0.0.2&lt;br /&gt;
与ifconfig(8)相同，多次指定同一网络接口名称设置IP地址时，最后的设置将覆盖先前的设置而生效&lt;/p&gt;
&lt;p&gt;6 . 通过SIOCGIFFLAGS操作设置指定网络接口的标志&lt;br /&gt;
使用ifconfig(8)将eth1设置为混杂模式，并关闭该接口，然后在程序中关闭混杂模式，并开启该接口&lt;/p&gt;
&lt;h1 id=&#34;ifconfig-eth1-promisc&#34;&gt;ifconfig eth1 promisc&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;ifconfig-eth1-down&#34;&gt;ifconfig eth1 down&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-eth1-1&#34;&gt;./get_interface_flags_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : BROADCAST MULTICAST PROMISC&lt;br /&gt;
/* set_interface_flags_ioctl.c */&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;/p&gt;
&lt;p&gt;static short get_if_flags(int, struct ifreq&lt;em&gt;);&lt;br /&gt;
static void set_if_flags(int, struct ifreq&lt;/em&gt;);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 2) {
fprintf(stderr, &amp;quot;Usage: %s [network interface name]\n&amp;quot;, argv[0]);
exit(EXIT_FAILURE);
}
int sfd;
short flags;
struct ifreq ifr;
char ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(ifname, argv[1], IFNAMSIZ-1);
sfd = socket(AF_INET, SOCK_DGRAM, 0);
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
flags = get_if_flags(sfd, &amp;amp;ifr);
ifr.ifr_flags = flags;
/* set IFF_UP if cleared */
if (!(flags &amp;amp; IFF_UP)) {
ifr.ifr_flags |= IFF_UP;
set_if_flags(sfd, &amp;amp;ifr);
printf(&amp;quot;Interface %s : UP set.\n&amp;quot;, ifname);
}
flags = ifr.ifr_flags;
/* clear IFF_PROMISC if set */
if (flags &amp;amp; IFF_PROMISC) {
ifr.ifr_flags &amp;amp;= ~IFF_PROMISC;
set_if_flags(sfd, &amp;amp;ifr);
printf(&amp;quot;Interface %s : PROMISC cleared.\n&amp;quot;, ifname);
}
close(sfd);
exit(EXIT_SUCCESS);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static short get_if_flags(int s, struct ifreq *ifr)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ret, saved_errno;
short if_flags;
saved_errno = errno;
ret = ioctl(s, SIOCGIFFLAGS, ifr);
if (ret == -1 &amp;amp;&amp;amp; errno == 19) {
fprintf(stderr, &amp;quot;Interface %s : No such device.\n&amp;quot;, ifr-&amp;gt;ifr_name);
exit(EXIT_FAILURE);
}
errno = saved_errno;
if_flags = ifr-&amp;gt;ifr_flags;
return if_flags;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static void set_if_flags(int s, struct ifreq *ifr)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int ret, saved_errno;
saved_errno = errno;
ret = ioctl(s, SIOCSIFFLAGS, ifr);
if (ret == -1) {
fprintf(stderr, &amp;quot;Interface %s : %s\n&amp;quot;, ifr-&amp;gt;ifr_name, strerror(errno));
exit(EXIT_FAILURE);
}
errno = saved_errno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
编译并运行&lt;/p&gt;
&lt;h1 id=&#34;gcc-set-interface-flags-ioctl-c-g-o-set-interface-flags-ioctl&#34;&gt;gcc set_interface_flags_ioctl.c -g -o set_interface_flags_ioctl&lt;/h1&gt;
&lt;p&gt;#&lt;/p&gt;
&lt;h1 id=&#34;set-interface-flags-ioctl-eth1&#34;&gt;./set_interface_flags_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : UP set.&lt;br /&gt;
Interface eth1 : PROMISC cleared.&lt;br /&gt;
#&lt;/p&gt;
&lt;h1 id=&#34;get-interface-flags-ioctl-eth1-2&#34;&gt;./get_interface_flags_ioctl eth1&lt;/h1&gt;
&lt;p&gt;Interface eth1 : UP BROADCAST MULTICAST&lt;br /&gt;
7 .通过SIOCSIFNAME操作更改网络接口的名称&lt;/p&gt;
&lt;p&gt;/* change_ifname_ioctl.c */&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;net/if.h&gt;&lt;br /&gt;
#include &lt;sys/ioctl.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;/p&gt;
&lt;p&gt;static void change_ifname(char *, char *);&lt;br /&gt;
static void shutdown_if_up(char *);&lt;/p&gt;
&lt;p&gt;int main(int argc, char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc != 3) {
fprintf(stderr, &amp;quot;%s [old ifname] [new ifname]\n&amp;quot;, argv[0]);
exit(EXIT_FAILURE);
}
char old_ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(old_ifname, argv[1], IFNAMSIZ);
char new_ifname[IFNAMSIZ] = {&#39;\0&#39;};
strncpy(new_ifname, argv[2], IFNAMSIZ);
change_ifname(old_ifname, new_ifname);
printf(&amp;quot;Interface name %s has been changed to %s\n&amp;quot;, old_ifname, new_ifname);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void change_ifname(char *old_dev, char *new_dev)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, ret, saved_errno;
struct ifreq ifr;
shutdown_if_up(old_dev);
sfd = socket(AF_INET, SOCK_DGRAM, 0);
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, old_dev, IFNAMSIZ);
strncpy(ifr.ifr_newname, new_dev, IFNAMSIZ);
saved_errno = errno;
ret = ioctl(sfd, SIOCSIFNAME, &amp;amp;ifr);
if (ret == -1) {
fprintf(stderr, &amp;quot;Interface %s : %s\n&amp;quot;, dev, strerror(errno));
exit(EXIT_FAILURE);
}
errno = saved_errno;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;static void shutdown_if_up(char *dev)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int sfd, ret, saved_errno;
short flags;
struct ifreq ifr;
sfd = socket(AF_INET, SOCK_DGRAM, 0);
memset(&amp;amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, dev, IFNAMSIZ);
saved_errno = errno;
ret = ioctl(sfd, SIOCGIFFLAGS, &amp;amp;ifr);
if (ret == -1) {
fprintf(stderr, &amp;quot;Interface %s : %s\n&amp;quot;, dev, strerror(errno));
exit(EXIT_FAILURE);
}
errno = saved_errno;
flags = ifr.ifr_flags;
if (flags &amp;amp; IFF_UP) {
ifr.ifr_flags &amp;amp;= ~IFF_UP;
saved_errno = errno;
ret = ioctl(sfd, SIOCSIFFLAGS, &amp;amp;ifr);
if (ret == -1) {
fprintf(stderr, &amp;quot;Interface %s : %s\n&amp;quot;,dev, strerror(errno));
exit(EXIT_FAILURE);
}
errno = saved_errno;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
将struct ifreq的ifr_ifrn.ifrn_name指定为网络接口名称后，ioctl(SIOCSIFNAME)将指定的新名称写入到ifr_ifru.ifru_newname中；该操作要求网络接口为关闭状态，即(~IFF_UP)&lt;/p&gt;</description></item><item><title>linux socket hton innet_pton</title><link>/language/clang/socket/linux-socket-hton-innet_pton/</link><pubDate>Thu, 04 Jun 2020 18:51:49 CST</pubDate><author>rinetd</author><guid>/language/clang/socket/linux-socket-hton-innet_pton/</guid><description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/ZWE7616175/article/details/80252048?&amp;amp;depth_1-&#34; target=&#34;_blank&#34;&gt;(1条消息)sockaddr_in与sockaddr的区别，以及对网络字节序和主机字节序的理解和转换函数_ZWE7616175的博客-CSDN博客_sockaddr_insockaddr&lt;/a&gt;&lt;br /&gt;
我们使用socket进行通信的时候，我们需要指定三个元素：通信域（地址族）、IP地址、端口号，这三个元素由SOCKADDR_IN结构体定义，为了简化编程一般将IP地址设置为INADDR_ANY，如果需要使用特定的IP地址则需要使用inet_addr 和inet_ntoa完成字符串和in_addr结构体的互换，in_addr是SOCKADDR_IN成员，其代表IP地址。&lt;/p&gt;
&lt;p&gt;一、sockaddr&lt;br /&gt;
sockaddr在/usr/include/bits/socket.h下，查看sockaddr的结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct sockaddr
{
__SOCKADDR_COMMON (sa_); /* Common data: address family and length. 协议族 */
char sa_data[14]; /* Address data. 地址+端口号*/
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sockaddr的缺陷：sa_data把目标地址和端口信息混在一起了。而sockaddr_in就解决了这一缺陷，将端口号和IP地址分开存储。&lt;/p&gt;
&lt;p&gt;二、sockaddr_in&lt;br /&gt;
sockaddr_in在/usr/include/netinet/in.h下，&lt;br /&gt;
查看sockaddr_in的结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef uint32_t in_addr_t;
struct in_addr
{
in_addr_t s_addr; //32位IPV4地址
};
struct sockaddr_in
{
__SOCKADDR_COMMON (sin_);/* Common data: address family and length. 协议族 */
in_port_t sin_port; /* Port number. 16位端口号*/
struct in_addr sin_addr; /* Internet address. 32位IP地址*/
/* Pad to size of `struct sockaddr&#39;. 用于填充的0字节*/
unsigned char sin_zero[sizeof (struct sockaddr) -
__SOCKADDR_COMMON_SIZE -
sizeof (in_port_t) -
sizeof (struct in_addr)];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、两者之间的区别与联系&lt;br /&gt;
我们来看一下sockaddr_in与sockaddr的结构：&lt;/p&gt;
&lt;p&gt;联系：二者的占用的内存大小是一致的，因此可以互相转化，从这个意义上说，他们并无区别。&lt;br /&gt;
区别：sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。&lt;br /&gt;
而sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作。使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「ZWE7616175」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/ZWE7616175/article/details/80252048&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/ZWE7616175/article/details/80252048&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsigned long inet_addr(const char* cp);&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp代表点分十进制的IP地址，如&amp;quot;1.2.3.4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
struct sockaddr_in local_addr, remote_addr;
int slen = sizeof(remote_addr);
remote_addr.sin_family = AF_INET;
remote_addr.sin_port = htons(port);//htons(atoi(port));
remote_addr.sin_addr.s_addr = inet_addr(&amp;quot;192.168.1.111&amp;quot;);
memset(remote_addr.sin_zero, &#39;\0&#39;, sizeof(remote_addr.sin_zero));
bzero(&amp;amp;(remote_addr.sin_zero), 8);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数使用代码如下：&lt;br /&gt;
&lt;code&gt;char* inet_ntoa(struct in_addr in);&lt;/code&gt;&lt;br /&gt;
参数：&lt;br /&gt;
    in代码in_addr的结构体,其结构体如下：&lt;/p&gt;
&lt;p&gt;//将in_addr类型转换为字符串&lt;br /&gt;
&lt;code&gt;printf(&amp;quot;inet_ntoa ip = %s\n&amp;quot;,inet_ntoa(sock.sin_addr));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printf(&amp;quot;\nrecv from ip = %s port = %d to ip = %s port = %d msg &amp;gt; %s\n&amp;quot;, inet_ntoa(si.sin_addr), ntohs(si.sin_port), inet_ntoa(si2.sin_addr), ntohs(si2.sin_port), buf);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结果输出：&lt;br /&gt;
inet_ntoa ip = 192.168.1.111&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「Jimmy1224」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/c_base_jin/article/details/60469622&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/c_base_jin/article/details/60469622&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网络编程inet_pton inet_ntop inet_addr htonl htons ntohl ntohs&lt;br /&gt;
把给定系统所采用的字节序成为主机字节序，为了避免不同类型主机之间在数据交换的时候育有对于字节序的不同而导致的差错，引入网络字节序。&lt;/p&gt;
&lt;p&gt;例一：IP地址的主机字节序与网络字节序的转换以用IP地址：127.0.0.1为例&lt;br /&gt;
1&lt;br /&gt;
第一步 127 . 0 . 0 . 1 把IP地址每一部分转换为8位的二进制数。&lt;br /&gt;
第二步 01111111 00000000 00000000 00000001 = 2130706433 （主机字节序）&lt;br /&gt;
然后把上面的四部分二进制数从右往左按部分重新排列，那就变为：&lt;br /&gt;
第三步 00000001 00000000 00000000 01111111 = 16777343 （网络字节序）&lt;/p&gt;
&lt;p&gt;internet协议地址结构体中，in_addr.sin_addr必须是负值IP地址的网络字节序&lt;br /&gt;
htonl是上述第二步到第三步的转换&lt;br /&gt;
inet_addr是上述第一步到第三步的转换&lt;/p&gt;
&lt;p&gt;addrSrv.sin_addr.S_un.S_addr=htonl(2130706433);这句还可以写为：&lt;br /&gt;
addrSrv.sin_addr.S_un.S_addr=inet_addr(“127.0.0.1”); 结果是完全一样的。&lt;/p&gt;
&lt;p&gt;例二：端口的主机字节序与网络字节序的转换。以6000端口为例&lt;br /&gt;
1&lt;br /&gt;
端口号其实就已经是主机字节序了，首先要把端口号写为16位的二进制数，分前8位和后8位。&lt;br /&gt;
第一步 00010111 01110000 = 6000 （主机字节序）&lt;br /&gt;
然后把主机字节序的前八位与后八位调换位置组成新的16位二进制数，这新的16位二进制数就是网络字节序的二进制表示了。&lt;br /&gt;
第二步 01110000 00010111 = 28695 （网络字节序）&lt;/p&gt;
&lt;p&gt;如果你知道6000端口的网络字节序是28695的话。&lt;br /&gt;
addrSrv.sin_port=htons(6000);还可以写为&lt;br /&gt;
addrSrv.sin_port=28695;结果是一样的，&lt;/p&gt;
&lt;p&gt;网络字节序与主机字节序互转 （例1一中的第二步到第三步；例2的第一步到第二步）&lt;br /&gt;
1&lt;br /&gt;
uint32_t htonl(uint32_t hostlong);&lt;br /&gt;
uint16_t htons(uint16_t hostshort);&lt;br /&gt;
uint32_t ntohl(uint32_t netlong);&lt;br /&gt;
uint16_t ntohs(uint16_t netshort);&lt;/p&gt;
&lt;p&gt;点分十进制串转换成网络字节序（例一中的第一步到第三步）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int inet_pton(int family,const char * strptr,void * addrptr);&lt;/code&gt;&lt;br /&gt;
功能同inet_addr&lt;br /&gt;
将点分十进制串转换成网络字节序二进制值，此函数对IPv4地址和IPv6地址都能处理。&lt;br /&gt;
&lt;code&gt;const char * inet_ntop(int family,const void *addrptr,char * strptr,size_t len);&lt;/code&gt;&lt;br /&gt;
将网络字节序二进制值转换成点分十进制串。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「wx+15954853403」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/weixin_38534337/article/details/84316251&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/weixin_38534337/article/details/84316251&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;inet_pton()源码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int inet_pton(int family, const char *strptr, void *addrptr)
{
if (family == AF_INET) {
struct in_addr in_val;
if (inet_aton(strptr, &amp;amp;in_val)) {
memcpy(addrptr, &amp;amp;in_val, sizeof(in_val));
return (1);
}
}
errno = EAFNOSUPPOPT;
return (-1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;inet_ntop()源码&lt;br /&gt;
&lt;code&gt;cpp
const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len)
{
const u_char *p = (const u_char*)addrptr;
if (family == AF_INET) {
char temp[INET_ADDRSTRLEN];
snprintf(temp, sizeof(temp), &amp;quot;%d.%d.%d.%d&amp;quot;, p[0], p[1], p[2], p[3]);
if (strlen(temp) &amp;gt;= len) {
errno = ENOSPC;
rturn (NULL);
}
strcpy(strptr, temp);
return (strptr);
}
errno = EAFNOSUPPOPT;
return (NULL);
}
&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inet_addr()&lt;br /&gt;
转换网络主机地址（点分十进制）为网络字节序二进制值，如果参数 char *cp 无效则返回-1(INADDR_NONE)，但这个函数有个缺点：在处理地址为255.255.255.255时也返回-1，虽然它是一个有效地址，但inet_addr()无法处理这个地址。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;in_addr_t inet_addr(const char *cp);&lt;br /&gt;
1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;inet_ntoa()-------&amp;gt;静态函数&lt;br /&gt;
inet_ntoa()函数转换网络字节序地址-&amp;gt;标准的点分十进制地址。该函数返回值指向保存点分十进制的字符串地址的指针，该字符串的空间为静态分配 的，所以在第二次调用这个函数时，意味着上一次调用并保存的结果将会被覆盖(重写)。so creazy!!!&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;char *inet_ntoa(struct in_addr in);&lt;br /&gt;
1&lt;br /&gt;
好了那就来证实一下，inet_ntoa()的静态返回值吧！！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char *add1,add2;
src.sin_addr.s_addr = inet_addr(&amp;quot;192.168.1.123&amp;quot;);
add1 =inet_ntoa(src.sin_addr);
src.sin_addr.s_addr = inet_addr(&amp;quot;192.168.1.124&amp;quot;);
add2 = inet_ntoa(src.sin_addr);
printf(&amp;quot;a1:%s\n&amp;quot;,add1);
printf(&amp;quot;a2:%s\n&amp;quot;,add2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终的printf结果是：&lt;br /&gt;
a1:192.168.1.124&lt;br /&gt;
a2:192.168.1.124&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这样来看的话，我认为如果有需要最好是用inet_pton()、inet_ntop()代替inet_ntoa()、inet_addr().&lt;br /&gt;
用&lt;br /&gt;
&lt;code&gt;inet_pton(AF_INET, cp, &amp;amp;src.sin_addr);&lt;/code&gt;&lt;br /&gt;
代替&lt;br /&gt;
&lt;code&gt;src.sin_addr.s_addr = inet_addr(cp);&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;char str[INET_ADDRATRLEN];&lt;br /&gt;
&lt;code&gt;ptr = inet_ntop(AF_INET, &amp;amp;src.sin_addr, str, sizeof(str));&lt;/code&gt;&lt;br /&gt;
代替&lt;br /&gt;
&lt;code&gt;ptr = inet_ntoa(src.sin_addr);&lt;/code&gt;&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「lockin.」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/weixin_43858843/article/details/98960756&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/weixin_43858843/article/details/98960756&lt;/a&gt;&lt;/p&gt;</description></item><item><title>linux socket udp</title><link>/language/clang/socket/linux-socket-udp/</link><pubDate>Thu, 04 Jun 2020 17:22:32 CST</pubDate><author>rinetd</author><guid>/language/clang/socket/linux-socket-udp/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
int udp_send_resp(int fd, char *ip, uint16_t port, char *in, int in_len, char *out, int *out_len)
{
// int sockfd;
// if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
// {
// perror(&amp;quot;Socket &amp;quot;);
// exit(1);
// }
struct sockaddr_in local_addr, remote_addr;
socklen_t slen = sizeof(remote_addr);
remote_addr.sin_family = AF_INET;
remote_addr.sin_port = htons(port); //htons(atoi(port));
remote_addr.sin_addr.s_addr = inet_addr(ip);
memset(remote_addr.sin_zero, &#39;\0&#39;, sizeof(remote_addr.sin_zero));
// recvfrom 超时时间
struct timeval timeout;
timeout.tv_sec = 3;
timeout.tv_usec = 0;
int received_bytes, sended_bytes;
// 重试次数
for (char i = 0; i &amp;lt; 4; i++)
{
if ((sended_bytes = sendto(fd, in, in_len, 0, (struct sockaddr *)&amp;amp;remote_addr, slen)) == -1)
{
perror(&amp;quot;sendto &amp;quot;);
continue;
}
// 设置超时阻塞模式，超时时间设置为3S
setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &amp;amp;timeout, sizeof(struct timeval));
if ((received_bytes = recvfrom(fd, out, *out_len, MSG_WAITALL, (struct sockaddr *)&amp;amp;remote_addr, (socklen_t *)&amp;amp;slen)) &amp;gt; 0)
{
out[received_bytes] = &#39;\0&#39;;
*out_len = received_bytes;
break;
}
if (errno == EINTR || errno == EAGAIN)
{
// if (++cnt &amp;gt; 100) {
// printf(&amp;quot;reach max retry count\n&amp;quot;);
// break;
// }
printf(&amp;quot; retry \n&amp;quot;);
// continue;
}
}
// close(sockfd);
return received_bytes;
}
int main(int argc, char **argv)
{
if (argc != 3)
{
puts(&amp;quot;Usage : ./tcpclient hostname port&amp;quot;);
exit(1);
}
char buffer[1024], buffer_to_send[1024];
int len;
uint16_t port = atoi(argv[2]);
char *ip = argv[1];
printf(&amp;quot;Message : &amp;quot;);
fgets(buffer_to_send, sizeof(buffer) - 1, stdin);
int i;
struct timeval res;
gettimeofday(&amp;amp;res, NULL);
int sockfd;
if ((sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
{
perror(&amp;quot;Socket &amp;quot;);
return -1;
}
while (1)
{
len = sizeof(buffer);
udp_send_resp(sockfd, ip, port, buffer_to_send, strlen(buffer_to_send), buffer, &amp;amp;len);
// printf(&amp;quot;%s %d\n&amp;quot;,buffer,len);
if (i++ &amp;gt; 100000)
{
break;
}
}
close(sockfd);
struct timeval now;
gettimeofday(&amp;amp;now, NULL);
printf(&amp;quot;%d\n&amp;quot;, (now.tv_sec) * 1000 + (now.tv_usec) / 1000 - (res.tv_sec) * 1000 + (res.tv_usec) / 1000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基于udp的socket通信时，linux系统调用recvfrom函数。&lt;/p&gt;
&lt;p&gt;函数功能如下&lt;/p&gt;
&lt;p&gt;从套接字上接收一个消息。&lt;br /&gt;
recvfrom ：可同时应用于面向连接（TCP）的和无连接（UDP）的套接字。&lt;br /&gt;
recv：一般只用在面向连接（TCP）的套接字，几乎等同于recvfrom，只要将recvfrom的第五个参数设置NULL。&lt;br /&gt;
存在的问题：阻塞等待超时&lt;/p&gt;
&lt;p&gt;假如套接字上没有消息可以读取，除非套接字已被设置为非阻塞模式，否则接收recvfrom一直阻塞等待消息的到来。&lt;br /&gt;
在涉及套接字的I/O操作上设置超时的方法有以下三种:&lt;/p&gt;
&lt;p&gt;调用alarm。&lt;br /&gt;
它在指定超时期满时产生SIGALARM。这个方法涉及信号处理，而信号处理在不同的实现上存在差异，而且可能干扰进程中现有的alarm调用。&lt;br /&gt;
调用select。&lt;br /&gt;
select有内置的时间限制，在select中阻塞等待I/O，以此替代直接阻塞在read或write调用上。&lt;br /&gt;
调用套接字函数setsockopt&lt;br /&gt;
使用SO_RECVTIMEO和SO_SNDTIMEO套接字选项&lt;br /&gt;
这里介绍比较简单的setsockopt设置超时时间的方法&lt;/p&gt;
&lt;p&gt;重点内容&lt;br /&gt;
示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 设置阻塞超时 */
struct timeval timeOut;
timeOut.tv_sec = 5; //设置5s超时
timeOut.tv_usec = 0;
if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;amp;timeOut, sizeof(timeOut)) &amp;lt; 0)
{
printf(&amp;quot;time out setting failed\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;// You can use the SO_RCVTIMEO and SO_SNDTIMEO socket options to set timeouts for any socket operations, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct timeval timeout;
timeout.tv_sec = 10;
timeout.tv_usec = 0;
if (setsockopt (sockfd, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;amp;timeout,
sizeof(timeout)) &amp;lt; 0)
error(&amp;quot;setsockopt failed\n&amp;quot;);
if (setsockopt (sockfd, SOL_SOCKET, SO_SNDTIMEO, (char *)&amp;amp;timeout,
sizeof(timeout)) &amp;lt; 0)
error(&amp;quot;setsockopt failed\n&amp;quot;);
/* 数据阻塞接收 */
int receivePacketLen = recvfrom(sockfd,buffer,sizeof(buffer),0,(struct sockaddr*)&amp;amp;svr_addr,&amp;amp;addrLen);
if (receivePacketLen == -1 &amp;amp;&amp;amp; errno == EAGAIN) //阻塞接收超时
{
printf(&amp;quot;timeout, no input!\n&amp;quot;);
exit(1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;recvfrom函数返回值&lt;br /&gt;
成功执行时，返回接收到的字节数。&lt;br /&gt;
另一端已关闭则返回0。&lt;br /&gt;
失败返回-1，errno（需添加errno.h头文件）被设为以下的某个值&lt;br /&gt;
EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时&lt;br /&gt;
EBADF：sock不是有效的描述词&lt;br /&gt;
ECONNREFUSE：远程主机阻绝网络连接&lt;br /&gt;
EFAULT：内存空间访问出错&lt;br /&gt;
EINTR：操作被信号中断&lt;br /&gt;
EINVAL：参数无效&lt;br /&gt;
ENOMEM：内存不足&lt;br /&gt;
ENOTCONN：与面向连接关联的套接字尚未被连接上&lt;br /&gt;
ENOTSOCK：sock索引的不是套接字&lt;/p&gt;
&lt;p&gt;Acknowledgements:&lt;br /&gt;
&lt;a href=&#34;http://www.cnblogs.com/lidabo/p/3804245.html&#34; target=&#34;_blank&#34;&gt;http://www.cnblogs.com/lidabo/p/3804245.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/su_linux/article/details/7057874&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/su_linux/article/details/7057874&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/daiyudong2020/article/details/50675219?locationNum=12&amp;amp;fps=1&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/daiyudong2020/article/details/50675219?locationNum=12&amp;amp;fps=1&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/mingcz/article/details/20814263&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/mingcz/article/details/20814263&lt;/a&gt;&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「shuaixio」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/baidu_35692628/article/details/75913684&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/baidu_35692628/article/details/75913684&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/******************************************************************************
* Function: Socket udp communication.
* Author: forwarding2012@yahoo.com.cn
* Date: 2012.01.01
* Compile: gcc -Wall socket_udp.c -o socket_udp
******************************************************************************/
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;resolv.h&amp;gt;
#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;sys/un.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;netinet/tcp.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
static int check_model()
{
int choices;
printf(&amp;quot;Test program as follow: \n&amp;quot;);
printf(&amp;quot; 1: creat a time application by udp protocol\n&amp;quot;);
printf(&amp;quot; 2: creat a client by udp protocol\n&amp;quot;);
printf(&amp;quot; 3: creat a server by udp protocol\n&amp;quot;);
printf(&amp;quot; 4: creat a broadcast client by udp protocol\n&amp;quot;);
printf(&amp;quot; 5: creat a broadcast server by udp protocol\n&amp;quot;);
printf(&amp;quot; 6: creat a groupcast client by udp protocol\n&amp;quot;);
printf(&amp;quot; 7: creat a groupcast server by udp protocol\n&amp;quot;);
printf(&amp;quot;Please input test type: &amp;quot;);
scanf(&amp;quot;%d&amp;quot;, &amp;amp;choices);
return choices;
}
int udp_point_app()
{
char buf[128];
socklen_t len;
int sockfd, ret;
struct hostent *hostinfo;
struct servent *servinfo;
struct sockaddr_in saddr;
hostinfo = gethostbyname(&amp;quot;localhost&amp;quot;);
if (hostinfo == NULL) {
perror(&amp;quot;gethostbyname&amp;quot;);
exit(EXIT_FAILURE);
}
servinfo = getservbyname(&amp;quot;daytime&amp;quot;, &amp;quot;udp&amp;quot;);
if (servinfo == NULL) {
perror(&amp;quot;getservbyname&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;daytime port is %d\n&amp;quot;, ntohs(servinfo-&amp;gt;s_port));
if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct sockaddr);
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = servinfo-&amp;gt;s_port;
saddr.sin_addr = *(struct in_addr *)*hostinfo-&amp;gt;h_addr_list;
ret = sendto(sockfd, buf, 1, 0, (struct sockaddr *)&amp;amp;saddr, len);
if (ret &amp;lt; 0) {
perror(&amp;quot;sendto&amp;quot;);
exit(EXIT_FAILURE);
}
memset(buf, 0, 128);
ret = recvfrom(sockfd, buf, 128, 0, (struct sockaddr *)&amp;amp;saddr, &amp;amp;len);
if (ret &amp;lt; 0) {
perror(&amp;quot;recvfrom&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;read %d bytes: %s&amp;quot;, ret, buf);
close(sockfd);
return 0;
}
int udp_point_client()
{
int sockfd;
char buf[128];
socklen_t len;
struct sockaddr_in saddr;
if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
memset(buf, 0, 128);
strcpy(buf, &amp;quot;hello beike!&amp;quot;);
len = sizeof(struct sockaddr);
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(9001);
saddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);
if (sendto(sockfd, buf, 128, 0, (struct sockaddr *)&amp;amp;saddr, len) &amp;lt; 0) {
perror(&amp;quot;sendto&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;sendto success.\n&amp;quot;);
return 0;
}
int udp_point_server()
{
char buf[128];
socklen_t len;
int sockfd, ret;
struct sockaddr_in saddr, caddr;
if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct sockaddr);
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(9001);
saddr.sin_addr.s_addr = INADDR_ANY;
if ((bind(sockfd, (struct sockaddr *)&amp;amp;saddr, len)) == -1) {
perror(&amp;quot;bind&amp;quot;);
exit(EXIT_FAILURE);
}
while (1) {
printf(&amp;quot;wait for new connect....\n&amp;quot;);
memset(buf, 0, 128);
ret = recvfrom(sockfd, buf, 127, 0, (struct sockaddr *)&amp;amp;caddr, &amp;amp;len);
if (ret &amp;lt; 0) {
perror(&amp;quot;recvfrom&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;recive come from %s port %d\n\t&amp;quot;,
inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));
printf(&amp;quot;message: %s\n&amp;quot;, buf);
}
close(sockfd);
return 0;
}
int udp_broadcast_client()
{
char buf[128];
socklen_t len;
int sockfd, on = 1;
struct sockaddr_in saddr;
if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(on);
if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;amp;on, len) == -1) {
perror(&amp;quot;setsockopt&amp;quot;);
exit(EXIT_FAILURE);
}
memset(buf, 0, 128);
strcpy(buf, &amp;quot;hello beike!&amp;quot;);
len = sizeof(struct sockaddr);
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(9001);
saddr.sin_addr.s_addr = inet_addr(&amp;quot;192.168.94.255&amp;quot;);
if (sendto(sockfd, buf, 128, 0, (struct sockaddr *)&amp;amp;saddr, len) &amp;lt; 0) {
perror(&amp;quot;sendto&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;send success\n&amp;quot;);
return 0;
}
int udp_broadcast_server()
{
char buf[128];
socklen_t len;
int sockfd, ret;
struct sockaddr_in saddr, caddr;
if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct sockaddr);
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(9001);
saddr.sin_addr.s_addr = INADDR_ANY;
if ((bind(sockfd, (struct sockaddr *)&amp;amp;saddr, len)) == -1) {
perror(&amp;quot;bind&amp;quot;);
exit(EXIT_FAILURE);
}
while (1) {
printf(&amp;quot;wait for new connect....\n&amp;quot;);
memset(buf, 0, 128);
ret = recvfrom(sockfd, buf, 127, 0, (struct sockaddr *)&amp;amp;caddr, &amp;amp;len);
if (ret &amp;lt; 0) {
perror(&amp;quot;recvfrom&amp;quot;);
exit(EXIT_FAILURE);
}
printf(&amp;quot;recive come from %s port %d\n\t&amp;quot;,
inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));
printf(&amp;quot;message: %s\n&amp;quot;, buf);
}
close(sockfd);
return 0;
}
int udp_groupcast_client()
{
int sockfd;
char buf[128];
socklen_t len;
struct sockaddr_in saddr, caddr;
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
if (sockfd &amp;lt; 0) {
perror(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(7838);
if (inet_pton(AF_INET, &amp;quot;230.1.1.1&amp;quot;, &amp;amp;saddr.sin_addr) &amp;lt;= 0) {
perror(&amp;quot;inet_pton&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct sockaddr);
bzero(&amp;amp;caddr, sizeof(caddr));
caddr.sin_family = AF_INET;
caddr.sin_port = htons(23456);
caddr.sin_addr.s_addr = INADDR_ANY;
if (bind(sockfd, (struct sockaddr *)&amp;amp;caddr, len) == -1) {
perror(&amp;quot;bind&amp;quot;);
exit(EXIT_FAILURE);
}
while (1) {
memset(buf, 0, 128);
printf(&amp;quot;input message to send: &amp;quot;);
if (fgets(buf, 255, stdin) == (char *)EOF)
exit(EXIT_FAILURE);
if (sendto(sockfd, buf, 128, 0, (struct sockaddr *)&amp;amp;saddr, len) &amp;lt; 0) {
perror(&amp;quot;sendto&amp;quot;);
exit(EXIT_FAILURE);;
}
printf(&amp;quot;\tsend message: %s\n&amp;quot;, buf);
}
close(sockfd);
return 0;
}
int udp_groupcast_server()
{
char buf[128];
socklen_t len;
int sockfd, ret;
char bcastip[128];
struct in_addr ia;
struct ip_mreq mreq;
struct hostent *group;
struct sockaddr_in saddr;
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
if (sockfd &amp;lt; 0) {
printf(&amp;quot;socket&amp;quot;);
exit(EXIT_FAILURE);
}
memset(bcastip, 0, 128);
strcpy(bcastip, &amp;quot;230.1.1.1&amp;quot;);
if ((group = gethostbyname(bcastip)) == (struct hostent *)0) {
perror(&amp;quot;gethostbyname&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct ip_mreq);
bzero(&amp;amp;mreq, sizeof(struct ip_mreq));
bcopy((void *)group-&amp;gt;h_addr, (void *)&amp;amp;ia, group-&amp;gt;h_length);
bcopy(&amp;amp;ia, &amp;amp;mreq.imr_multiaddr.s_addr, sizeof(struct in_addr));
if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;amp;mreq, len) == -1) {
perror(&amp;quot;setsockopt&amp;quot;);
exit(EXIT_FAILURE);
}
bzero(&amp;amp;saddr, sizeof(saddr));
saddr.sin_family = AF_INET;
saddr.sin_port = htons(7838);
if (inet_pton(AF_INET, bcastip, &amp;amp;saddr.sin_addr) &amp;lt;= 0) {
perror(&amp;quot;inet_pton&amp;quot;);
exit(EXIT_FAILURE);
}
len = sizeof(struct sockaddr);
if (bind(sockfd, (struct sockaddr *)&amp;amp;saddr, len) == -1) {
perror(&amp;quot;bind&amp;quot;);
exit(EXIT_FAILURE);
}
while (1) {
memset(buf, 0, 128);
ret = recvfrom(sockfd, buf, 127, 0, (struct sockaddr *)&amp;amp;saddr, &amp;amp;len);
if (ret &amp;lt; 0) {
perror(&amp;quot;recvfrom&amp;quot;);
exit(EXIT_FAILURE);
} else {
printf(&amp;quot;recive come from %s port %d\n\t&amp;quot;,
inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));
printf(&amp;quot;message: %s\n&amp;quot;, buf);
}
}
close(sockfd);
return 0;
}
int main(int argc, char *argv[])
{
int choice;
if (argc &amp;lt; 2)
choice = check_model();
switch (choice) {
//creat a time application by udp protocol
case 1:
udp_point_app();
break;
//creat a client by udp protocol
case 2:
udp_point_client();
break;
//creat a server by udp protocol
case 3:
udp_point_server();
break;
//creat a broadcast client by udp protocol
case 4:
udp_broadcast_client();
break;
//creat a broadcast server by udp protocol
case 5:
udp_broadcast_server();
break;
//creat a groupcast client by udp protocol
case 6:
udp_groupcast_client();
break;
//creat a groupcast server by udp protocol
case 7:
udp_groupcast_server();
break;
//default do nothing
default:
break;
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>clang linux epool socket</title><link>/language/clang/clang-linux-epool-socket/</link><pubDate>Thu, 04 Jun 2020 13:39:23 CST</pubDate><author>rinetd</author><guid>/language/clang/clang-linux-epool-socket/</guid><description>&lt;p&gt;第一篇 TCP server&lt;/p&gt;
&lt;p&gt;守护进程daemonize的源码可以借鉴redis的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void daemonize(void) { //come from /redis/server.c/daemonize()
int fd;
if (fork() != 0) exit(0); /* parent exits */
setsid(); /* create a new session */
/* Every output goes to /dev/null. If Redis is daemonized but
* the &#39;logfile&#39; is set to &#39;stdout&#39; in the configuration file
* it will not log at all. */
if ((fd = open(&amp;quot;/dev/null&amp;quot;, O_RDWR, 0)) != -1) {
dup2(fd, STDIN_FILENO);
dup2(fd, STDOUT_FILENO);
dup2(fd, STDERR_FILENO);
if (fd &amp;gt; STDERR_FILENO) close(fd);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一、echo源码1如下，main.c，注意是.c文件&lt;/p&gt;
&lt;p&gt; ```cpp&lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;/p&gt;
&lt;p&gt;#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;sys/epoll.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;/p&gt;
&lt;p&gt;#include &lt;sys/resource.h&gt; /*setrlimit */&lt;br /&gt;
#include &lt;signal.h&gt;&lt;br /&gt;
#include &lt;fcntl.h&gt;&lt;/p&gt;
&lt;p&gt;#define bool int //linux C中没有bool类型&lt;br /&gt;
#define false 0 //linux C中没有bool类型&lt;br /&gt;
#define true 1 //linux C中没有bool类型&lt;br /&gt;
#define IPADDRESS &amp;quot;127.0.0.1&amp;quot;&lt;br /&gt;
#define PORT 1883&lt;br /&gt;
#define MAXSIZE 1024&lt;br /&gt;
#define LISTENQ 512&lt;br /&gt;
#define FDSIZE 1024&lt;br /&gt;
#define EPOLLEVENTS 60000&lt;br /&gt;
#define MAXCONN 60000&lt;/p&gt;
&lt;p&gt;//函数声明&lt;br /&gt;
//创建套接字并进行绑定&lt;br /&gt;
static int socket_bind(const char* ip,int port);&lt;br /&gt;
//IO多路复用epoll&lt;br /&gt;
static void do_epoll(int listenfd);&lt;br /&gt;
//事件处理函数&lt;br /&gt;
static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf);&lt;br /&gt;
//处理接收到的连接&lt;br /&gt;
static void handle_accpet(int epollfd,int listenfd);&lt;br /&gt;
//读处理&lt;br /&gt;
static void do_read(int epollfd,int fd,char *buf);&lt;br /&gt;
//写处理&lt;br /&gt;
static void do_write(int epollfd,int fd,char *buf);&lt;br /&gt;
//添加事件&lt;br /&gt;
static void add_event(int epollfd,int fd,int state);&lt;br /&gt;
//修改事件&lt;br /&gt;
static void modify_event(int epollfd,int fd,int state);&lt;br /&gt;
//删除事件&lt;br /&gt;
static void delete_event(int epollfd,int fd,int state);&lt;/p&gt;
&lt;p&gt;void init_signal(void)//设置信号处理,SIG_IGN表示忽略信号,SIG_DFL表示使用信号的默认处理方式&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;signal(SIGCHLD, SIG_DFL);
signal(SIGPIPE, SIG_IGN);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int set_fdlimit()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置每个进程允许打开的最大文件数
//这项功能等价于linux终端命令 &amp;quot;ulimit -n 102400&amp;quot;
struct rlimit rt;
rt.rlim_max = rt.rlim_cur = MAXCONN;
if (setrlimit(RLIMIT_NOFILE, &amp;amp;rt) == -1)
{
perror(&amp;quot;setrlimit error&amp;quot;);
return -1;
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void daemon_run_method1()//来自&lt;a href=&#34;https://github.com/baloonwj/flamingo&#34; target=&#34;_blank&#34;&gt;https://github.com/baloonwj/flamingo&lt;/a&gt;&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int pid;
signal(SIGCHLD, SIG_IGN);
//1）在父进程中，fork返回新创建子进程的进程ID；
//2）在子进程中，fork返回0；
//3）如果出现错误，fork返回一个负值；
pid = fork();
if (pid &amp;lt; 0)
{
//std::cout &amp;lt;&amp;lt; &amp;quot;fork error&amp;quot; &amp;lt;&amp;lt; std::endl;
exit(-1);
}
//父进程退出，子进程独立运行
else if (pid &amp;gt; 0)
{
exit(0);
}
//之前parent和child运行在同一个session里,parent是会话（session）的领头进程,
//parent进程作为会话的领头进程，如果exit结束执行的话，那么子进程会成为孤儿进程，并被init收养。
//执行setsid()之后,child将重新获得一个新的会话(session)id。
//这时parent退出之后,将不会影响到child了。
setsid();
int fd;
fd = open(&amp;quot;/dev/null&amp;quot;, O_RDWR, 0);
if (fd != -1)
{
dup2(fd, STDIN_FILENO);
dup2(fd, STDOUT_FILENO);
dup2(fd, STDERR_FILENO);
}
if (fd &amp;gt; 2)
{
close(fd);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;bool daemon_run_method2() //Linux高性能服务器编程.pdf,游双&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建子进程，关闭父进程，这样可以使程序在后台进行
pid_t pid = fork();
if ( pid &amp;lt; 0 )
{
return false;
}
else if ( pid &amp;gt; 0 )
{
exit( 0 );
}
//设置文件权限掩码。当进程创建新文件时，文件的权限将是mode &amp;amp; 0777
umask( 0 );
//创建新的会话，设置本进程为进程组的首领
pid_t sid = setsid();
if ( sid &amp;lt; 0 )
{
return false;
}
//切换工作目录
if ( ( chdir( &amp;quot;/&amp;quot; ) ) &amp;lt; 0 )
{
/* Log the failure */
return false;
}
//关闭标准输入设备、标准输出设备和标准错误输出设备
close( STDIN_FILENO );
close( STDOUT_FILENO );
close( STDERR_FILENO );
//将标准输入、输出和错误输出都定向到/dev/null文件
open( &amp;quot;/dev/null&amp;quot;, O_RDONLY );
open( &amp;quot;/dev/null&amp;quot;, O_RDWR );
open( &amp;quot;/dev/null&amp;quot;, O_RDWR );
return true;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
int main(int argc,char *argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置信号处理
init_signal();
//设置每个进程允许打开的最大文件数,socket
if (set_fdlimit() &amp;lt; 0)
{
return -1;
}
//守护者进程
bool bdaemon = false;
if (bdaemon)
{
daemon_run_method1();
}
int listenfd;
listenfd = socket_bind(IPADDRESS,PORT);
listen(listenfd,LISTENQ);
do_epoll(listenfd);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static int socket_bind(const char* ip,int port)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int listenfd;
struct sockaddr_in servaddr;
listenfd = socket(AF_INET,SOCK_STREAM,0);
if (listenfd == -1)
{
perror(&amp;quot;socket error:&amp;quot;);
exit(1);
}
//一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
int reuse_addr = 1;
if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;reuse_addr, sizeof(reuse_addr)) == -1)
{
return -1;
}
bzero(&amp;amp;servaddr,sizeof(servaddr));
servaddr.sin_family = AF_INET;
//inet_pton(AF_INET,ip,&amp;amp;servaddr.sin_addr);
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//绑定所有网卡所有IP
//servaddr.sin_addr.s_addr = inet_addr(&amp;quot;172.16.6.178&amp;quot;);
//servaddr.sin_addr.s_addr = inet_addr(&amp;quot;127.0.0.1&amp;quot;);//这样写指代不明，当服务器有多网卡时，不知道绑定哪个IP，导致连接失败
servaddr.sin_port = htons(port);
if (bind(listenfd,(struct sockaddr*)&amp;amp;servaddr,sizeof(servaddr)) == -1)
{
perror(&amp;quot;bind error: &amp;quot;);
exit(1);
}
printf(&amp;quot;listen on: %d,listenfd=%d\n&amp;quot;,PORT,listenfd);
return listenfd;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void do_epoll(int listenfd)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int epollfd;
struct epoll_event events[EPOLLEVENTS];
int ret;
char buf[MAXSIZE];
memset(buf,0,MAXSIZE);
//创建一个描述符
epollfd = epoll_create(FDSIZE);
//添加监听描述符事件
add_event(epollfd,listenfd,EPOLLIN);
for ( ; ; )
{
//获取已经准备好的描述符事件
ret = epoll_wait(epollfd,events,EPOLLEVENTS,-1);
handle_events(epollfd,events,ret,listenfd,buf);
}
close(epollfd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int i;
int fd;
//进行选好遍历
for (i = 0;i &amp;lt; num;i++)
{
fd = events[i].data.fd;
//根据描述符的类型和事件类型进行处理
if ((fd == listenfd) &amp;amp;&amp;amp;(events[i].events &amp;amp; EPOLLIN))
handle_accpet(epollfd,listenfd);
else if (events[i].events &amp;amp; EPOLLIN)
do_read(epollfd,fd,buf);
else if (events[i].events &amp;amp; EPOLLOUT)
do_write(epollfd,fd,buf);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void handle_accpet(int epollfd,int listenfd)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int clifd;
struct sockaddr_in cliaddr;
socklen_t cliaddrlen = sizeof(cliaddr);
clifd = accept(listenfd,(struct sockaddr*)&amp;amp;cliaddr,&amp;amp;cliaddrlen);
if (clifd == -1)
perror(&amp;quot;accpet error:&amp;quot;);
else
{
printf(&amp;quot;accept a new client: %s:%d,fd=%d\n&amp;quot;,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port,clifd);
//添加一个客户描述符和事件
add_event(epollfd,clifd,EPOLLIN);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void do_read(int epollfd,int fd,char *buf)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int nread;
nread = read(fd,buf,MAXSIZE);
if (nread == -1)
{
perror(&amp;quot;read error:&amp;quot;);
close(fd);
delete_event(epollfd,fd,EPOLLIN);
}
else if (nread == 0)
{
fprintf(stderr,&amp;quot;client close,fd=%d\n&amp;quot;,fd);
close(fd);
delete_event(epollfd,fd,EPOLLIN);
}
else
{
printf(&amp;quot;read message is: %s,fd=%d\n&amp;quot;,buf,fd);
//修改描述符对应的事件，由读改为写
modify_event(epollfd,fd,EPOLLOUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void do_write(int epollfd,int fd,char *buf)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int nwrite;
nwrite = write(fd,buf,strlen(buf));
if (nwrite == -1)
{
perror(&amp;quot;write error:&amp;quot;);
close(fd);
delete_event(epollfd,fd,EPOLLOUT);
}
else
modify_event(epollfd,fd,EPOLLIN);
memset(buf,0,MAXSIZE);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void add_event(int epollfd,int fd,int state)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct epoll_event ev;
ev.events = state;//LT
ev.data.fd = fd;
epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;amp;ev);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void delete_event(int epollfd,int fd,int state)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct epoll_event ev;
ev.events = state;
ev.data.fd = fd;
epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;amp;ev);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
static void modify_event(int epollfd,int fd,int state)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct epoll_event ev;
ev.events = state;
ev.data.fd = fd;
epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;amp;ev);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
 &lt;/p&gt;
&lt;p&gt;二、echo源码2如下，main.c&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;sys/epoll.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;sys/resource.h&gt; /*setrlimit */&lt;/p&gt;
&lt;p&gt;#define ECHO_SERVER_PORT 1883&lt;br /&gt;
#define LISTEN_BACKLOG 16&lt;br /&gt;
#define MAX_EVENT_COUNT 32&lt;br /&gt;
#define BUF_SIZE 2048&lt;br /&gt;
#define MAXCONN 60000&lt;/p&gt;
&lt;p&gt;int set_fdlimit()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置每个进程允许打开的最大文件数
//这项功能等价于linux终端命令 &amp;quot;ulimit -n 102400&amp;quot;
struct rlimit rt;
rt.rlim_max = rt.rlim_cur = MAXCONN;
if (setrlimit(RLIMIT_NOFILE, &amp;amp;rt) == -1)
{
perror(&amp;quot;setrlimit error&amp;quot;);
return -1;
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置每个进程允许打开的最大文件数,socket
if (set_fdlimit() &amp;lt; 0)
{
return -1;
}
int ret, i;
int server_fd, client_fd, epoll_fd;
int ready_count;
struct sockaddr_in server_addr;
struct sockaddr_in client_addr;
socklen_t addr_len;
struct epoll_event event;
struct epoll_event* event_array;
char* buf;
event_array = (struct epoll_event*)
malloc(sizeof(struct epoll_event)*MAX_EVENT_COUNT);
buf = (char*)malloc(sizeof(char)*BUF_SIZE);
memset(&amp;amp;server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
server_addr.sin_port = htons(ECHO_SERVER_PORT);
server_fd = socket(AF_INET, SOCK_STREAM, 0);
if(server_fd == -1) {
perror(&amp;quot;create socket failed.\n&amp;quot;);
return 1;
}
//一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
int reuse_addr = 1;
if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;amp;reuse_addr, sizeof(reuse_addr)) == -1)
{
return -1;
}
ret = bind(server_fd, (struct sockaddr*)&amp;amp;server_addr, sizeof(server_addr));
if(ret == -1) {
perror(&amp;quot;bind failed.\n&amp;quot;);
return 1;
}
ret = listen(server_fd, LISTEN_BACKLOG);
if(ret == -1) {
perror(&amp;quot;listen failed.\n&amp;quot;);
return 1;
}
fprintf(stderr,&amp;quot;listen on,fd=%d\n&amp;quot;,server_fd);
epoll_fd = epoll_create(1);
if(epoll_fd == -1) {
perror(&amp;quot;epoll_create failed.\n&amp;quot;);
return 1;
}
event.events = EPOLLIN;
event.data.fd = server_fd;
ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;amp;event);
if(ret == -1) {
perror(&amp;quot;epoll_ctl failed.\n&amp;quot;);
return 1;
}
while(1) {
ready_count = epoll_wait(epoll_fd, event_array, MAX_EVENT_COUNT, -1);
if(ready_count == -1) {
perror(&amp;quot;epoll_wait failed.\n&amp;quot;);
return 1;
}
for(i = 0; i &amp;lt; ready_count; i++) {
if(event_array[i].data.fd == server_fd) {
client_fd = accept(server_fd,
(struct sockaddr*)&amp;amp;client_addr, &amp;amp;addr_len);
if(client_fd == -1) {
perror(&amp;quot;accept failed.\n&amp;quot;);
return 1;
}
event.events = EPOLLIN;
event.data.fd = client_fd;
ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &amp;amp;event);
if(ret == -1) {
perror(&amp;quot;epoll_ctl failed.\n&amp;quot;);
return 1;
}
fprintf(stderr,&amp;quot;accept,fd=%d\n&amp;quot;,client_fd);
}
else {
ret = recv(event_array[i].data.fd, buf, BUF_SIZE, 0);
if(ret &amp;lt;= 0) {
close(event_array[i].data.fd);
epoll_ctl(epoll_fd, EPOLL_CTL_DEL,
event_array[i].data.fd, &amp;amp;event);
continue;
}
ret = send(event_array[i].data.fd, buf, (size_t)ret, 0);
if(ret == -1) {
perror(&amp;quot;send failed.\n&amp;quot;);
}
}
} // for each event
} // while(1)
close(epoll_fd);
close(server_fd);
free(event_array);
free(buf);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
```&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「libaineu2004」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/libaineu2004/article/details/79128878&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/libaineu2004/article/details/79128878&lt;/a&gt;&lt;/p&gt;</description></item><item><title>linux clang warpper utils</title><link>/language/clang/linux-clang-warpper-utils/</link><pubDate>Fri, 29 May 2020 19:05:35 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-clang-warpper-utils/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
* =====================================================================================
*
* Filename: wrapper.h
*
* Description: wrapper
*
* Version:
* Created:
* Revision: none
* Compiler: gcc
*
* Author:
* Company:
* Modify:
*
* =====================================================================================
*/
#ifndef __WRAPPER_H__
#define __WRAPPER_H__
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;semaphore.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;net/if_arp.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/sem.h&amp;gt;
#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;inttypes.h&amp;gt;
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;sys/timeb.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;termios.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;
/* ------------ time ----------------- */
time_t os_make_time(int year,int month,int day
,int hour,int minute,int second);
void os_local_time(time_t utc
,unsigned int *pyear,unsigned int *pmonth,unsigned int *pday
,unsigned int *phour,unsigned int *pminute,unsigned int *psecond
,unsigned int *pweekday);
char *os_local_time_str(time_t time, char *time_str);
int os_get_days(int year, int month);
int os_set_time(time_t t);
int os_get_rand(int min, int max);
int os_get_time(unsigned int *pyear, unsigned int *pmonth, unsigned int *pday
,unsigned int *phour, unsigned int *pminute, unsigned int *psecond);
/* ------------ io &amp;amp;&amp;amp; string ----------------- */
ssize_t os_writen(int fd, const void *vptr, size_t n);
ssize_t os_readn(int fd, void *vptr, size_t n);
ssize_t os_readline(int fd, void *vptr, size_t maxlen);
char *os_strsep(char **stringp, const char *delim);
int os_str2number(char *str , uint32_t* pulValue);
/* ------------ mem ----------------- */
void *os_calloc(size_t nmemb, size_t size);
void *os_malloc(size_t size);
void *os_realloc(void *ptr, size_t size);
void os_free(void *ptr);
/* ------------ other ----------------- */
unsigned int os_crc32(const void *buf, unsigned int size);
pid_t os_gettid(void);
/* ------------ com port ----------------- */
int os_set_com_param(int fd, int baut, int parity, int stop, int databit);
/* ------------ net ----------------- */
#define OS_ETH0 &amp;quot;eth0&amp;quot;
#define OS_ETH1 &amp;quot;eth1&amp;quot;
#define OS_PPP0 &amp;quot;ppp0&amp;quot;
#define OS_PPP1 &amp;quot;ppp1&amp;quot;
int os_get_if_index(const char *if_name, int *ifindex);
int os_get_mac_addr(const char *if_name, char *macaddr, size_t len);
int os_get_ip_addr(const char *if_name, char *ipaddr, size_t len);
int os_get_net_mask(const char *if_name, char *netmask, size_t len);
int os_get_net_addr(const char *if_name, char *netaddr, size_t len);
int os_get_broad_cast(const char *if_name, char *broadcast, size_t len);
int os_get_gateway(const char *if_name, char *gateway, size_t len);
int os_get_dns(char *firstdns, char *seconddns, size_t len);
int os_check_mac_addr(const char *macaddr);
int os_check_ip_addr(const char *ipaddr);
int os_set_mac_addr(const char *if_name, const char *macaddr);
int os_set_mac_addr_2(const char *if_name, const char *pmac);
int os_set_ip_addr(const char* if_name, const char *ipaddr);
int os_set_net_mask(const char *if_name, const char *netmask);
int os_set_net_addr(const char *netaddr);
int os_set_broad_cast(const char *if_name, const char *broadcast);
int os_del_gateway(const char *gateway);
int os_set_gateway(const char *if_name, const char *gateway);
int os_set_dns(const char *firstdns, const char *seconddns);
int os_set_auto_dns(void);
int os_get_link_status(const char *if_name);
/* ------------ file ----------------- */
int os_is_file_exist(const char *pathname);
int os_get_file_length(const char *pathname);
int os_get_file_Name(const char *pathname, char *file, size_t len);
int os_get_file_path(const char *pathname, char *path, size_t len);
time_t os_get_file_Atime(const char *pathname);
time_t os_get_file_Mtime(const char *pathname);
int os_is_file_read(const char *pathname);
int os_is_file_write(const char *pathname);
int os_is_file_exec(const char *pathname);
int os_is_link_file(const char *pathname);
int os_is_device_file(const char *pathname);
int os_is_regular_file(const char *pathname);
int os_copy_file(const char *oldpath, const char *newpath, int flag);
int os_rm_file(const char *pathname);
int os_rename_file(const char *oldpath, const char *newpath);
int os_set_file_length(const char *pathname, int newlen);
int os_set_file_mode(const char *pathname, mode_t mode);
int os_read_lock(int fd, off_t offset, int whence, off_t len);
int os_readW_lock(int fd, off_t offset, int whence, off_t len);
int os_write_lock(int fd, off_t offset, int whence, off_t len);
int os_writeW_lock(int fd, off_t offset, int whence, off_t len);
int os_unlock(int fd, off_t offset, int whence, off_t len);
off_t os_seek(int fd, off_t offset, int whence);
off_t os_seek2begin(int fd);
off_t os_seek2end(int fd);
int os_set_Utime(const char *pathname, const struct utimbuf *times);
int os_fsync(int fd);
int os_fflush(FILE *stream);
int os_is_dir_exist(const char *pathname);
int os_is_dir(const char *pathname);
int os_get_dir_name(const char *pathname, char *dirname, size_t len);
int os_get_absolute_dir(const char *pathname, char *dirname, size_t len);
int os_is_dir_empty(const char *pathname);
long long os_get_dir_size(const char *pathname);
int os_get_dir_fileCount(const char *pathname);
int os_mk_dir(const char *pathname, mode_t mode);
int os_set_dir_mode(const char *pathname, mode_t mode);
int os_copy_dir(const char *oldpath, const char *newpath, int flag, long sleeptime);
int os_rename_dir(const char *oldpath, const char *newpath);
int os_rm_dir(const char *pathname);
int os_get_delFileCount(void);
int os_clear_delFileCount(void);
int os_stack_set_fd(FILE *fd);
void os_stack_trace(void);
#endif //__WRAPPER_H__
/*
* =====================================================================================
*
* Filename: wrapper.c
*
* Description: wrapper
*
* Version: 1.0
* Created: 2011年08月27日 17时43分18秒
* Revision: none
* Compiler: gcc
*
*
* =====================================================================================
*/
#include &amp;lt;stdarg.h&amp;gt;
//#include &amp;quot;log.h&amp;quot;
#include &amp;quot;wrapper.h&amp;quot;
time_t os_make_time(int year,int month,int day
,int hour,int minute,int second)
{
time_t ret;
struct tm t;
memset(&amp;amp;t, 0, sizeof(t));
t.tm_year = year-1900;
t.tm_mon = month-1;
t.tm_mday = day;
t.tm_hour = hour;
t.tm_min = minute;
t.tm_sec = second;
ret = mktime(&amp;amp;t);
if(ret &amp;lt; 0)
{
printf(&amp;quot;mktime error! errno:%s\n&amp;quot;, strerror(errno));
return 0;
}
return ret;
}
void os_local_time(time_t utc
,unsigned int *pyear,unsigned int *pmonth,unsigned int *pday
,unsigned int *phour,unsigned int *pminute,unsigned int *psecond
,unsigned int *pweekday)
{
struct timeval tv;
struct tm tm,*ret;
if(utc&amp;lt;0)
{
utc=0;
}
tv.tv_sec=utc;
tv.tv_usec=0;
ret=localtime_r(&amp;amp;tv.tv_sec,&amp;amp;tm);
if(ret == NULL)
{
return;
}
if(pyear != NULL) *pyear = tm.tm_year+1900;
if(pmonth != NULL) *pmonth = tm.tm_mon+1;
if(pday != NULL) *pday = tm.tm_mday;
if(phour != NULL) *phour = tm.tm_hour;
if(pminute != NULL) *pminute = tm.tm_min;
if(psecond != NULL) *psecond = tm.tm_sec;
if(pweekday!= NULL) *pweekday = tm.tm_wday;
}
char *os_local_time_str(time_t time, char *time_str)
{
if(time_str == NULL)return NULL;
unsigned int year,mon,day,hour,min,sec,weekday;
os_local_time(time, &amp;amp;year, &amp;amp;mon, &amp;amp;day, &amp;amp;hour, &amp;amp;min, &amp;amp;sec, &amp;amp;weekday);
sprintf(time_str, &amp;quot;%04d-%02d-%02d %02d:%02d:%02d weekday:%d&amp;quot;
, year
, mon
, day
, hour
, min
, sec
, weekday);
return time_str;
}
int os_set_time(time_t t)
{
struct timeval tv;
tv.tv_sec = t;
tv.tv_usec = 0;
printf(&amp;quot;-----------3---------settimeofday time:%d\n&amp;quot;,0);
if (settimeofday(&amp;amp;tv, NULL) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_get_time(unsigned int *pyear, unsigned int *pmonth, unsigned int *pday
,unsigned int *phour, unsigned int *pminute, unsigned int *psecond)
{
time_t seconds;
struct tm *p = NULL;
seconds = time((time_t *)NULL);
p = localtime(&amp;amp;seconds);
if (NULL == p)
{
printf(&amp;quot;localtime error!\n&amp;quot;);
return -1;
}
if(pyear != NULL) *pyear = 1900 + p-&amp;gt;tm_year;
if(pmonth != NULL) *pmonth = 1 + p-&amp;gt;tm_mon;
if(pday != NULL) *pday = p-&amp;gt;tm_mday;
if(phour != NULL) *phour = p-&amp;gt;tm_hour;
if(pminute != NULL) *pminute = p-&amp;gt;tm_min;
if(psecond != NULL) *psecond = p-&amp;gt;tm_sec;
return 0;
}
int os_get_days(int year, int month)
{
switch (month)
{
case 1:
case 3:
case 5:
case 7:
case 8:
case 10:
case 12:
return(31);
case 4:
case 6:
case 9:
case 11:
return(30);
case 2:
if (year%4 == 0)
return(29);
else
return(28);
default:
return(-1);
}
}
ssize_t os_writen(int fd, const void *vptr, size_t n)
{
size_t nleft;
ssize_t nwritten;
const char *ptr;
ptr = vptr;
nleft = n;
while (nleft &amp;gt; 0)
{
if ( (nwritten = write(fd, ptr, nleft)) &amp;lt;= 0)
{
if (errno == EINTR)
nwritten = 0; /* and call write() again */
else
return(-1); /* error */
}
if (errno == 5)
return(-1);
nleft -= nwritten;
ptr += nwritten;
}
return(n);
}
ssize_t os_readn(int fd, void *vptr, size_t n)
{
size_t nleft;
ssize_t nread;
char *ptr;
ptr = vptr;
nleft = n;
while (nleft &amp;gt; 0)
{
if ( (nread = read(fd, ptr, nleft)) &amp;lt; 0)
{
if (errno == EINTR)
nread = 0; /* and call read() again */
else
return(-1);
}
else if (nread == 0)
{
break; /* EOF */
}
nleft -= nread;
ptr += nread;
}
return(n - nleft); /* return &amp;gt;= 0 */
}
ssize_t os_readline(int fd, void *vptr, size_t maxlen)
{
ssize_t n, rc;
char c, *ptr;
ptr = vptr;
for (n = 1; n &amp;lt; maxlen; n++)
{
again:
if ((rc = read(fd, &amp;amp;c, 1)) == 1)
{
*ptr++ = c;
if (c == &#39;\n&#39;)
break; /* newline is stored, like fgets() */
}
else if (rc == 0)
{
*ptr = 0;
return(n - 1); /* EOF, n-1 bytes were read */
}
else
{
if (errno == EINTR)
goto again;
return(-1);
}
}
*ptr = 0; /* null terminate like fgets() */
return(n);
}
char *os_strsep(char **stringp, const char *delim)
{
char *p;
while (1)
{
p = strsep(stringp, delim);
if (p == NULL)
{
return NULL;
}
else
{
if (p[0] == &#39;\0&#39;)
continue;
else
break;
}
}
return p;
}
int os_get_rand(int min, int max)
{
struct timeval tv;
gettimeofday(&amp;amp;tv, NULL);
srand(tv.tv_usec);
return(min+(int) ((double)(max-min+1)*rand()/(RAND_MAX*1.0)));
}
//static pthread_mutex_t alloc_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
static pthread_mutex_t alloc_mutex = PTHREAD_MUTEX_INITIALIZER;
static unsigned int alloc_count = 0;
void *os_calloc(size_t nmemb, size_t size)
{
void *p;
pthread_mutex_lock(&amp;amp;alloc_mutex);
p = calloc(nmemb, size);
if(p != NULL){alloc_count++;};
pthread_mutex_unlock(&amp;amp;alloc_mutex);
return(p);
}
void *os_malloc(size_t size)
{
void *p;
pthread_mutex_lock(&amp;amp;alloc_mutex);
p = malloc(size);
if(p != NULL){alloc_count++;};
pthread_mutex_unlock(&amp;amp;alloc_mutex);
return(p);
}
void os_free(void *ptr)
{
pthread_mutex_lock(&amp;amp;alloc_mutex);
if(ptr != NULL)
{
free(ptr);
alloc_count--;
}
pthread_mutex_unlock(&amp;amp;alloc_mutex);
}
void *os_realloc(void *ptr, size_t size)
{
void *p;
pthread_mutex_lock(&amp;amp;alloc_mutex);
p = realloc(ptr, size);
if(p != NULL){alloc_count++;};
pthread_mutex_unlock(&amp;amp;alloc_mutex);
return(p);
}
#define NETWORK_FILE_EXIST 0
#define COMM_ADDRSIZE 20
#define COMM_FILELINE 256
#define COMM_ETHFILE &amp;quot;/etc/sysconfig/network-scripts/ifcfg-eth1&amp;quot;
#define COMM_GATEWAY &amp;quot;/etc/sysconfig/network&amp;quot;
#define COMM_RESOLVCONF &amp;quot;/etc/resolv.conf&amp;quot;
#define PROC_ROUTE &amp;quot;/proc/net/route&amp;quot;
#define ETHTOOL_GLINK 0x0000000a /* Get link status (ethtool_value) */
#define SIOCETHTOOL 0x8946
typedef unsigned long long __u64;
typedef __uint32_t __u32;
typedef __uint16_t __u16;
typedef __uint8_t __u8;
struct ethtool_cmd {
__u32 cmd;
__u32 supported; /* Features this interface supports */
__u32 advertising; /* Features this interface advertises */
__u16 speed; /* The forced speed, 10Mb, 100Mb, gigabit */
__u8 duplex; /* Duplex, half or full */
__u8 port; /* Which connector port */
__u8 phy_address;
__u8 transceiver; /* Which transceiver to use */
__u8 autoneg; /* Enable or disable autonegotiation */
__u32 maxtxpkt; /* Tx pkts before generating tx int */
__u32 maxrxpkt; /* Rx pkts before generating rx int */
__u32 reserved[4];
};
/* for passing single values */
struct ethtool_value {
__u32 cmd;
__u32 data;
};
static int _os_mac2int(const char *macaddr, int *p);
int os_get_if_index(const char *if_name, int *ifindex)
{
int fd;
/*char buffer[COMM_ADDRSIZE];*/
struct ifreq ifr;
if((fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &amp;gt;= 0) {
ifr.ifr_addr.sa_family = AF_INET;
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
if (ioctl(fd, SIOCGIFINDEX, &amp;amp;ifr) == 0) {
*ifindex = ifr.ifr_ifindex;
}
else
{
close(fd);
return -2;
}
}
else
{
close(fd);
return -1;
}
close(fd);
return 0;
}
int os_get_mac_addr(const char *if_name, char *macaddr, size_t len)
{
int fd;
char buffer[COMM_ADDRSIZE];
struct ifreq ifr;
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;gt;= 0)
{
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
if (ioctl(fd, SIOCGIFHWADDR, &amp;amp;ifr) == 0)
{
snprintf(buffer, COMM_ADDRSIZE, &amp;quot;%02x:%02x:%02x:%02x:%02x:%02x&amp;quot;,
(unsigned char)ifr.ifr_hwaddr.sa_data[0],
(unsigned char)ifr.ifr_hwaddr.sa_data[1],
(unsigned char)ifr.ifr_hwaddr.sa_data[2],
(unsigned char)ifr.ifr_hwaddr.sa_data[3],
(unsigned char)ifr.ifr_hwaddr.sa_data[4],
(unsigned char)ifr.ifr_hwaddr.sa_data[5]);
}
else
{
close(fd);
return(-1);
}
}
else
{
return(-1);
}
if (strlen(buffer) &amp;gt; len-1)
{
return(-1);
}
strncpy(macaddr, buffer, len);
close(fd);
return(0);
}
int os_get_ip_addr(const char *if_name, char *ipaddr, size_t len)
{
int fd;
char buffer[COMM_ADDRSIZE];
struct ifreq ifr;
struct sockaddr_in *addr;
if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) &amp;gt;= 0)
{
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
if (ioctl(fd, SIOCGIFADDR, &amp;amp;ifr) == 0)
{
addr = (struct sockaddr_in *)&amp;amp;(ifr.ifr_addr);
inet_ntop(AF_INET, &amp;amp;addr-&amp;gt;sin_addr, buffer, 20);
}
else
{
close(fd);
return(-1);
}
}
else
{
perror(&amp;quot;os_getIpAddr error :&amp;quot;);
return(-1);
}
if (strlen(buffer) &amp;gt; len-1)
{
return(-1);
}
strncpy(ipaddr, buffer, len);
close(fd);
return(0);
}
int os_get_net_mask(const char *if_name, char *netmask, size_t len)
{
int fd;
char buffer[COMM_ADDRSIZE];
struct ifreq ifr;
struct sockaddr_in *addr;
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;gt;= 0)
{
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
if (ioctl(fd, SIOCGIFNETMASK, &amp;amp;ifr) == 0)
{
addr = (struct sockaddr_in *)&amp;amp;(ifr.ifr_addr);
inet_ntop(AF_INET, &amp;amp;addr-&amp;gt;sin_addr, buffer, 20);
}
else
{
close(fd);
return(-1);
}
}
else
{
return(-1);
}
if (strlen(buffer) &amp;gt; len-1)
{
return(-1);
}
strncpy(netmask, buffer, len);
close(fd);
return(0);
}
int os_get_net_addr(const char *if_name, char *netaddr, size_t len)
{
int m1, m2, m3, m4, i1, i2, i3, i4;
char ipbuf[COMM_ADDRSIZE], maskbuf[COMM_ADDRSIZE];
if (os_get_ip_addr(if_name, ipbuf, COMM_ADDRSIZE) &amp;lt; 0)
return(-1);
if (os_get_net_mask(if_name, maskbuf, COMM_ADDRSIZE) &amp;lt; 0)
return(-1);
sscanf(maskbuf, &amp;quot;%d.%d.%d.%d&amp;quot;, &amp;amp;m1, &amp;amp;m2, &amp;amp;m3, &amp;amp;m4);
sscanf(ipbuf, &amp;quot;%d.%d.%d.%d&amp;quot;, &amp;amp;i1, &amp;amp;i2, &amp;amp;i3, &amp;amp;i4);
snprintf(netaddr, len, &amp;quot;%d.%d.%d.%d&amp;quot;, m1&amp;amp;i1, m2&amp;amp;i2, m3&amp;amp;i3, m4&amp;amp;i4);
return(0);
}
int os_get_broad_cast(const char *if_name, char *broadcast, size_t len)
{
int fd;
char buffer[COMM_ADDRSIZE];
struct ifreq ifr;
struct sockaddr_in *addr;
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;gt;= 0)
{
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
if (ioctl(fd, SIOCGIFBRDADDR, &amp;amp;ifr) == 0)
{
addr = (struct sockaddr_in *)&amp;amp;(ifr.ifr_addr);
inet_ntop(AF_INET, &amp;amp;addr-&amp;gt;sin_addr, buffer, 20);
}
else
{
close(fd);
return(-1);
}
}
else
{
return(-1);
}
if (strlen(buffer) &amp;gt; len-1)
{
return(-1);
}
strncpy(broadcast, buffer, len);
close(fd);
return(0);
}
#define CH_TO_HEX(ch) ((ch)&amp;lt;=&#39;9&#39;?(ch)-48:(ch)-&#39;A&#39;+10)
int os_get_gateway(const char *if_name, char *gateway, size_t len)
{
#if NETWORK_FILE_EXIST
int flag = 0; /*isn&#39;t find the GATEWAY?*/
FILE *fp;
char buf[COMM_FILELINE], *ptr;
if((fp = fopen(COMM_GATEWAY, &amp;quot;r&amp;quot;)) == NULL)
{
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;GATEWAY&amp;quot;, 7) == 0)
{
sscanf(buf, &amp;quot;GATEWAY=%s&amp;quot;, gateway);
if (gateway[strlen(gateway)-1] == &#39;\n&#39;)
gateway[strlen(gateway)-1] = &#39;\0&#39;;
flag = 1;
break;
}
}
fclose(fp);
if (flag == 0)
{
return(-1);
}
#else
int i;
int n[4];
int fd;
char name[10], dest[10], dg[10], buf[1024];
memset(gateway, &#39;\0&#39;, len);
if ((fd = open(PROC_ROUTE, O_RDONLY)) &amp;lt; 0)
{
perror(&amp;quot;open route&amp;quot;);
return(-1);
}
while (os_readline(fd, buf, 1024) &amp;gt; 0)
{
if (memcmp(buf, if_name, 4) != 0)
continue;
sscanf(buf, &amp;quot;%4s\t%8s\t%8s\t&amp;quot;, name, dest, dg);
if (!strcmp(dest, &amp;quot;00000000&amp;quot;))
{
for (i = 0; i &amp;lt; 8; i = i+2)
{
n[i/2] = CH_TO_HEX(dg[i])*16+CH_TO_HEX(dg[i+1]);
}
#ifdef COMM_PPC
snprintf(gateway, len, &amp;quot;%d.%d.%d.%d&amp;quot;, n[0], n[1], n[2], n[3]);
#else
snprintf(gateway, len, &amp;quot;%d.%d.%d.%d&amp;quot;, n[3], n[2], n[1], n[0]);
#endif
break;
}
}
close(fd);
#endif
if (gateway[0] == &#39;\0&#39;)
return(-1);
return(0);
}
int os_get_dns(char *firstdns, char *seconddns, size_t len)
{
int flag = 0; /*isn&#39;t find the DNS?*/
int fd;
char buf[COMM_FILELINE], *ptr;
if(firstdns == NULL)
return -1;
if((fd = open(COMM_RESOLVCONF, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
while (os_readline(fd, buf, COMM_FILELINE) &amp;gt; 0)
{//printf(&amp;quot;buf=%s\n&amp;quot;,buf);
if (strncmp(buf, &amp;quot;nameserver&amp;quot;, 10) == 0)
{
ptr = buf;
os_strsep(&amp;amp;ptr, &amp;quot; &amp;quot;);
if (flag == 0)
{
strncpy(firstdns, os_strsep(&amp;amp;ptr, &amp;quot; &amp;quot;), len);
if (firstdns[strlen(firstdns)-1] == &#39;\n&#39;)
firstdns[strlen(firstdns)-1] = &#39;\0&#39;;
//printf(&amp;quot;firstdns=%s\n&amp;quot;,firstdns);
flag = 1;
if (seconddns == NULL)
break;
continue;
}
else
{
if(seconddns == NULL)
return -1;
strncpy(seconddns, os_strsep(&amp;amp;ptr, &amp;quot; &amp;quot;), len);
if (seconddns[strlen(seconddns)-1] == &#39;\n&#39;)
seconddns[strlen(seconddns)-1] = &#39;\0&#39;;
//printf(&amp;quot;seconddns=%s\n&amp;quot;,seconddns);
flag = 2;
break;
}
}
}
close(fd);
if (flag == 0)
{
return(-1);
}
return(flag);
}
int os_set_mac_addr(const char *if_name, const char *macaddr)
{
int i = 0;
int fd;
int imac[6];
struct ifreq ifr;
short temp;
#if NETWORK_FILE_EXIST
int flag = 0; /*COMM_ETHFILE hasn&#39;t a line of MACADDR?*/
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
if (os_check_mac_addr(macaddr) &amp;lt; 0)
{
printf(&amp;quot;check mac error!\n&amp;quot;);
return(-1);
}
if ((fd =socket(AF_INET,SOCK_DGRAM,0))&amp;lt; 0)
{
return(-1);
}
strncpy(ifr.ifr_name,if_name,IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
if (ioctl(fd, SIOCGIFFLAGS, &amp;amp;ifr) &amp;lt; 0)
{
printf(&amp;quot;ioctl get ifr failed!\n&amp;quot;);
return(-1);
}
temp = ifr.ifr_flags;
/*shutdown interface.*/
ifr.ifr_flags = temp &amp;amp; (~IFF_UP);
if (ioctl(fd, SIOCSIFFLAGS, &amp;amp;ifr) &amp;lt; 0)
{
printf(&amp;quot;ioctl ifr failed!\n&amp;quot;);
return(-1);
}
/*change mac address.*/
ifr.ifr_hwaddr.sa_family = 1;
_os_mac2int(macaddr,imac);
for (i = 0; i &amp;lt; 6; i++)
ifr.ifr_hwaddr.sa_data[i] = (unsigned char)imac[i];
if (ioctl(fd,SIOCSIFHWADDR,&amp;amp;ifr) &amp;lt; 0)
{
return(-1);
}
/*up interface.*/
ifr.ifr_flags = temp|IFF_UP;
if (ioctl(fd, SIOCSIFFLAGS, &amp;amp;ifr) &amp;lt; 0)
{
return(-1);
}
close(fd);
#if NETWORK_FILE_EXIST
/*change interface file, and it will take affect when reboot.*/
if((fp = fopen(COMM_ETHFILE, &amp;quot;r&amp;quot;)) == NULL)
{
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_ETHFILE, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;MACADDR&amp;quot;, 6) == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;MACADDR&amp;quot;, macaddr);
flag = 1;
}
fputs(buf, fp_tmp);
}
if (flag == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;MACADDR&amp;quot;, macaddr);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_ETHFILE) &amp;lt; 0)
{
return(-1);
}
#endif
return(0);
}
int os_set_mac_addr_2(const char *if_name, const char *pmac)
{
int ret = 0;
char shellbuf[128]= {0};
sprintf(shellbuf, &amp;quot;ifconfig %s hw ether %s&amp;quot;, if_name, pmac);
ret = system(shellbuf);
printf(&amp;quot; ret:%d, shellbuf:%s\n&amp;quot;, ret, shellbuf);
return 0;
}
int os_set_ip_addr(const char* if_name, const char *ipaddr)
{
int fd;
struct ifreq ifr;
struct sockaddr_in addr;
#if NETWORK_FILE_EXIST
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
if (os_check_ip_addr(ipaddr) &amp;lt; 0)
{
printf(&amp;quot;os_check_ip_addr error!\n&amp;quot;);
return(-1);
}
/*set ip address, and take affect instant.*/
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;lt; 0)
{
printf(&amp;quot;socket error!\n&amp;quot;);
return(-1);
}
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
bzero(&amp;amp;addr, sizeof(struct sockaddr_in));
if (inet_pton(AF_INET, ipaddr, &amp;amp;addr.sin_addr) &amp;lt; 0)
{
printf(&amp;quot;inet_pton error!\n&amp;quot;);
return(-1);
}
addr.sin_family = AF_INET;
addr.sin_port = 0;
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
if (ioctl(fd, SIOCSIFADDR, &amp;amp;ifr) &amp;lt; 0)
{
printf(&amp;quot;ioctl error!\n&amp;quot;);
return(-1);
}
close(fd);
#if NETWORK_FILE_EXIST
/*change interface file, and it will take affect when reboot.*/
if((fp = fopen(COMM_ETHFILE, &amp;quot;r&amp;quot;)) == NULL)
{
printf(&amp;quot;fopen error!\n&amp;quot;);
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_ETHFILE, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
printf(&amp;quot;fopen error!\n&amp;quot;);
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;IPADDR&amp;quot;, 6) == 0)
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;IPADDR&amp;quot;, ipaddr);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_ETHFILE) &amp;lt; 0)
{
printf(&amp;quot;rename error!\n&amp;quot;);
return(-1);
}
#endif
return(0);
}
int os_set_net_mask(const char *if_name, const char *netmask)
{
int fd;
struct ifreq ifr;
struct sockaddr_in addr;
#if NETWORK_FILE_EXIST
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
if (os_check_ip_addr(netmask) &amp;lt; 0)
{
printf(&amp;quot;os_check_ip_addr error!&amp;quot;);
return(-1);
}
/*set netmask, and take affect instant.*/
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;lt; 0)
{
printf(&amp;quot;socket error!&amp;quot;);
return(-1);
}
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
bzero(&amp;amp;addr, sizeof(struct sockaddr_in));
if (inet_pton(AF_INET, netmask, &amp;amp;addr.sin_addr) &amp;lt; 0)
{
printf(&amp;quot;inet_pton error!&amp;quot;);
return(-1);
}
addr.sin_family = AF_INET;
addr.sin_port = 0;
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
if (ioctl(fd, SIOCSIFNETMASK, &amp;amp;ifr) &amp;lt; 0)
{
printf(&amp;quot;ioctl error!&amp;quot;);
return(-1);
}
close(fd);
#if NETWORK_FILE_EXIST
/*change interface file, and it will take affect when reboot.*/
if((fp = fopen(COMM_ETHFILE, &amp;quot;r&amp;quot;)) == NULL)
{
printf(&amp;quot;fopen error!&amp;quot;);
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_ETHFILE, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
printf(&amp;quot;fopen error!&amp;quot;);
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;NETMASK&amp;quot;, 6) == 0)
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;NETMASK&amp;quot;, netmask);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_ETHFILE) &amp;lt; 0)
{
printf(&amp;quot;rename error!&amp;quot;);
return(-1);
}
#endif
return(0);
}
int os_set_net_addr(const char *netaddr)
{
#if NETWORK_FILE_EXIST
int flag = 0; /*COMM_ETHFILE hasn&#39;t a line of NETADDR?*/
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
if((fp = fopen(COMM_ETHFILE, &amp;quot;r&amp;quot;)) == NULL)
{
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_ETHFILE, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;NETADDR&amp;quot;, 6) == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;NETADDR&amp;quot;, netaddr);
flag = 1;
}
fputs(buf, fp_tmp);
}
if (flag == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;NETADDR&amp;quot;, netaddr);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_ETHFILE) &amp;lt; 0)
{
return(-1);
}
#endif
return(0);
}
int os_set_broad_cast(const char *if_name, const char *broadcast)
{
int fd;
struct ifreq ifr;
struct sockaddr_in addr;
#if NETWORK_FILE_EXIST
int flag = 0; /*COMM_ETHFILE hasn&#39;t a line of BROADCAST?*/
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
if (os_check_ip_addr(broadcast) &amp;lt; 0)
{
return(-1);
}
/*set broadcast, and take affect instant.*/
if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) &amp;lt; 0)
{
return(-1);
}
strncpy(ifr.ifr_name, if_name, IFNAMSIZ);
ifr.ifr_name[IFNAMSIZ - 1] = &#39;\0&#39;;
bzero(&amp;amp;addr, sizeof(struct sockaddr_in));
if (inet_pton(AF_INET, broadcast, &amp;amp;addr.sin_addr) &amp;lt; 0)
{
return(-1);
}
addr.sin_family = AF_INET;
addr.sin_port = 0;
memcpy(&amp;amp;ifr.ifr_addr, &amp;amp;addr, sizeof(struct sockaddr));
if (ioctl(fd, SIOCSIFBRDADDR, &amp;amp;ifr) &amp;lt; 0)
{
return(-1);
}
close(fd);
#if NETWORK_FILE_EXIST
/*change interface file, and it will take affect when reboot.*/
if((fp = fopen(COMM_ETHFILE, &amp;quot;r&amp;quot;)) == NULL)
{
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_ETHFILE, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;BROADCAST&amp;quot;, 6) == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;BROADCAST&amp;quot;, broadcast);
flag = 1;
}
fputs(buf, fp_tmp);
}
if (flag == 0)
{
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;BROADCAST&amp;quot;, broadcast);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_ETHFILE) &amp;lt; 0)
{
return(-1);
}
#endif
return(0);
}
int os_del_gateway(const char *gateway)
{
char cmdbuf[COMM_FILELINE]=&amp;quot;&amp;quot;;
int ret;
snprintf(cmdbuf, COMM_FILELINE, &amp;quot;route del default gw %s&amp;quot;, gateway);
ret = system(cmdbuf);
return(0);
}
int os_set_gateway(const char *if_name, const char *gateway)
{
int ret;
#if NETWORK_FILE_EXIST
FILE *fp, *fp_tmp;
char tmpfile[COMM_FILELINE], buf[COMM_FILELINE];
#endif
char cmdbuf[COMM_FILELINE]=&amp;quot;&amp;quot;;
if(gateway == NULL)
return -1;
#if NETWORK_FILE_EXIST
if((fp = fopen(COMM_GATEWAY, &amp;quot;r&amp;quot;)) == NULL)
{
return(-1);
}
snprintf(tmpfile, COMM_FILELINE, &amp;quot;%s_%d&amp;quot;, COMM_GATEWAY, getpid());
if((fp_tmp = fopen(tmpfile, &amp;quot;w&amp;quot;)) == NULL)
{
return(-1);
}
while (fgets(buf, COMM_FILELINE, fp) != NULL)
{
if (strncmp(buf, &amp;quot;GATEWAY&amp;quot;, 7) == 0)
snprintf(buf, COMM_FILELINE, &amp;quot;%s=%s\n&amp;quot;, &amp;quot;GATEWAY&amp;quot;, gateway);
fputs(buf, fp_tmp);
}
fclose(fp);
fclose(fp_tmp);
if (rename(tmpfile, COMM_GATEWAY) &amp;lt; 0)
{
return(-1);
}
#endif
snprintf(cmdbuf, COMM_FILELINE, &amp;quot;route add default gw %s dev %s&amp;quot;, gateway, if_name);
ret = system(cmdbuf);
return(0);
}
int os_set_dns(const char *firstdns, const char *seconddns)
{
#if 1 /*NETWORK_FILE_EXIST*/
FILE *fp;
if(firstdns == NULL)
return -1;
unlink(COMM_RESOLVCONF);
if((fp = fopen(COMM_RESOLVCONF, &amp;quot;w&amp;quot;)) == NULL)
{
return(-1);
}
fprintf(fp, &amp;quot;nameserver %s\n&amp;quot;, firstdns);
if (seconddns != NULL)
fprintf(fp, &amp;quot;nameserver %s\n&amp;quot;, seconddns);
fclose(fp);
#endif
return(0);
}
int os_set_auto_dns(void)
{
unlink(COMM_RESOLVCONF);
return 0;
}
int os_get_link_status(const char *if_name)
{
struct ethtool_value edata;
struct ifreq ifr;
int fd;
int err;
memset(&amp;amp;ifr, 0, sizeof(ifr));
strcpy(ifr.ifr_name, if_name);
/* Open control socket. */
fd = socket(AF_INET, SOCK_DGRAM, 0);
if (fd &amp;lt; 0) {
perror(&amp;quot;Cannot get control socket&amp;quot;);
return 70;
}
edata.cmd = ETHTOOL_GLINK;
ifr.ifr_data = (caddr_t)&amp;amp;edata;
err = ioctl(fd, SIOCETHTOOL, &amp;amp;ifr);
if (err == 0) {
close(fd);
return (edata.data);
}
else if (errno != EOPNOTSUPP) {
perror(&amp;quot;Cannot get link status&amp;quot;);
}
close(fd);
return 0;
}
/*some tools function, not in the commlib.*/
int os_check_ip_addr(const char *ipaddr)
{
int i = 0, flag = 0;
//char buf[16];
char buf[16] = {0};
char *tmp, *ptr;
if (strlen(ipaddr) &amp;gt; 15)
{
printf(&amp;quot;ipaddr &amp;gt; 15\n&amp;quot;);
return(-1);
}
//strncpy(buf, ipaddr, 16);
strncpy(buf, ipaddr, strlen(ipaddr));
while (buf[i] != &#39;\0&#39;)
{
switch (buf[i])
{
case &#39;0&#39;:
case &#39;1&#39;:
case &#39;2&#39;:
case &#39;3&#39;:
case &#39;4&#39;:
case &#39;5&#39;:
case &#39;6&#39;:
case &#39;7&#39;:
case &#39;8&#39;:
case &#39;9&#39;:
break;
case &#39;.&#39;:
flag++;
break;
default:
return(-1);
}
i++;
}
if (flag != 3)
{
printf(&amp;quot;flag error!\n&amp;quot;);
return(-1);
}
ptr = buf;
for (i=0; i&amp;lt;4; i++)
{
tmp = os_strsep(&amp;amp;ptr, &amp;quot;.&amp;quot;);
if (tmp == NULL)
{
printf(&amp;quot; tmp == NULL\n&amp;quot;);
return(-1);
}
if (atoi(tmp)&amp;gt;255 || strlen(tmp)&amp;gt;3 || (tmp[0]==&#39;0&#39; &amp;amp;&amp;amp; strlen(tmp)!=1))
{
printf(&amp;quot;tmp error!\n&amp;quot;);
return(-1);
}
}
return(0);
}
int os_check_mac_addr(const char *macaddr)
{
int i = 0;
int flag = 0;
if(macaddr == NULL)
return -1;
if (strlen(macaddr) != 17)
return(-1);
while (macaddr[i] != &#39;\0&#39;)
{
switch (macaddr[i])
{
case &#39;0&#39;:
case &#39;1&#39;:
case &#39;2&#39;:
case &#39;3&#39;:
case &#39;4&#39;:
case &#39;5&#39;:
case &#39;6&#39;:
case &#39;7&#39;:
case &#39;8&#39;:
case &#39;9&#39;:
case &#39;a&#39;:
case &#39;b&#39;:
case &#39;c&#39;:
case &#39;d&#39;:
case &#39;e&#39;:
case &#39;f&#39;:
case &#39;A&#39;:
case &#39;B&#39;:
case &#39;C&#39;:
case &#39;D&#39;:
case &#39;E&#39;:
case &#39;F&#39;:
break;
case &#39;:&#39;:
flag++;
break;
default:
return(-1);
}
i++;
}
if (flag != 5)
return(-1);
if (macaddr[2] != &#39;:&#39; || macaddr[5] != &#39;:&#39; || macaddr[8] != &#39;:&#39;
|| macaddr[11] != &#39;:&#39; || macaddr[14] != &#39;:&#39;)
return(-1);
return(0);
}
static int _os_mac2int(const char *macaddr, int *p)
{
int i = 0, j = 0;
int n1 = 0, n2 = 0;
for (i = 0, j = 0; i &amp;lt; strlen(macaddr); i = i+3, j++)
{
if (macaddr[i] &amp;gt;= 48 &amp;amp;&amp;amp; macaddr[i] &amp;lt;= 57) /*&#39;0&#39; &amp;lt;--&amp;gt; &#39;9&#39;*/
n1 = macaddr[i] - 48; /*&#39;0&#39; == 48*/
else if (macaddr[i] &amp;gt;= 65 &amp;amp;&amp;amp; macaddr[i] &amp;lt;= 70) /*&#39;A&#39; &amp;lt;--&amp;gt; &#39;F&#39;*/
n1 = macaddr[i] - 55; /*&#39;A&#39; == 65, and in hex &#39;A&#39; = 10.*/
else if (macaddr[i] &amp;gt;= 97) /*&#39;a&#39; &amp;lt;--&amp;gt; &#39;f&#39;*/
n1 = macaddr[i] - 87; /*&#39;a&#39; == 97, and in hex &#39;a&#39; = 10.*/
if (macaddr[i+1] &amp;gt;= 48 &amp;amp;&amp;amp; macaddr[i+1] &amp;lt;= 57)
n2 = macaddr[i+1] - 48;
else if (macaddr[i+1] &amp;gt;= 65 &amp;amp;&amp;amp; macaddr[i+1] &amp;lt;= 70)
n2 = macaddr[i+1] - 55;
else if (macaddr[i+1] &amp;gt;= 97)
n2 = macaddr[i+1] - 87;
p[j] = n1*16 + n2;
}
return(0);
}
/* ------------ com port ----------------- */
static pthread_mutex_t com_serial_mutex = PTHREAD_MUTEX_INITIALIZER;
static int speed_arr[] = {B115200, B57600, B38400, B19200, B9600, B4800, B2400, B1800, B1200, B600};
static int name_arr[] = {115200, 57600, 38400, 19200, 9600, 4800, 2400, 1800, 1200, 600};
static int setSpeed(int fd, int speed);
static int setParity(int fd, int databits, int parity, int stopbits);
int os_set_com_param(int fd, int baut, int parity, int stop, int databit)
{
int ret = 0;
static int _baut;
static int _parity;
static int _stop;
static int _databit;
pthread_mutex_lock(&amp;amp;com_serial_mutex);
if((_baut != baut)
|| (_parity != parity)
|| (_stop != stop)
|| (_databit!= databit))
{
ret = setSpeed(fd, baut);
ret = setParity(fd, databit, parity, stop);
_baut = baut;
_parity = parity;
_stop = stop;
_databit= databit;
};
pthread_mutex_unlock(&amp;amp;com_serial_mutex);
return ret;
}
static int setSpeed(int fd, int speed)
{
int i;
int status;
struct termios Opt;
if(tcgetattr(fd, &amp;amp;Opt)!=0)
{
perror(&amp;quot;SetupSerial error&amp;quot;);
return -1;
}
for(i=0; i&amp;lt;sizeof(speed_arr)/sizeof(int); i++)
{
if (speed==name_arr[i])
{
tcflush(fd, TCIOFLUSH);
cfsetispeed(&amp;amp;Opt, speed_arr[i]);
cfsetospeed(&amp;amp;Opt, speed_arr[i]);
status=tcsetattr(fd, TCSANOW,&amp;amp;Opt);
if(0!=status)
{
perror(&amp;quot;tcsetattr fd error!&amp;quot;);
}
tcflush(fd, TCIOFLUSH);
}
}
return 0;
}
static int setParity(int fd, int databits, int parity, int stopbits)
{
struct termios options;
if (tcgetattr(fd, &amp;amp;options) != 0)
{
perror(&amp;quot;Setup Serial error!&amp;quot;);
return -1;
}
options.c_cflag &amp;amp;= ~CSIZE;
switch (databits)
{
case 5:
options.c_cflag |= CS5;
break;
case 6:
options.c_cflag |= CS6;
break;
case 7:
options.c_cflag |= CS7;
break;
case 8:
options.c_cflag |= CS8;
break;
default:
fprintf(stderr, &amp;quot;Unsupported data size!\n&amp;quot;);
return -1;
}
switch (parity)
{
case 0: //无校验
options.c_cflag &amp;amp;= ~PARENB;
options.c_iflag &amp;amp;= ~INPCK;
break;
case 1: //奇校验
options.c_cflag |= PARENB;
options.c_cflag |= PARODD;
options.c_iflag |= INPCK;
break;
case 2: //偶校验
options.c_cflag |= PARENB;
options.c_cflag &amp;amp;= ~PARODD;
options.c_iflag |= INPCK;
break;
default:
fprintf(stderr, &amp;quot;Unsupported parity!\n&amp;quot;);
return -1;
}
switch (stopbits)
{
case 1:
options.c_cflag &amp;amp;= ~CSTOPB;
break;
case 2:
options.c_cflag |= CSTOPB;
break;
default:
fprintf(stderr, &amp;quot;Unsupported stop bits!\n&amp;quot;);
return -1;
}
options.c_lflag &amp;amp;= ~(ECHO | ICANON | ECHOE | ISIG | IEXTEN);
options.c_iflag &amp;amp;= ~(IXON | IXOFF | ICRNL);
options.c_oflag &amp;amp;= ~OPOST;
tcflush(fd, TCIOFLUSH);
/* options.c_cc[VTIME]=100;*/ /*SETUP 10s timeout for read if time passed,quit read;*/
/* options.c_cc[VMIN]=0;*/ /*SETUP min len for read if len passed,quit read;;*/
if (tcsetattr(fd, TCSANOW, &amp;amp;options) != 0)
{
perror(&amp;quot;Setup Serial in set_parity error!&amp;quot;);
return -1;
}
return 1;
}
/* ------------ file ----------------- */
#define BUCKET_SIZE 8192
static int _os_get_dir_size(const char *pathname, long long *dirsize);
static int _get_dir_file_count(const char *pathname, int *filecount);
static int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
static int _del_file_count = 0;
/*Filesystem*/
int os_is_file_exist(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
return(1);
return(0); /*not a file, maybe dir/link/fifo etc.*/
}
int os_get_file_length(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
return(buf.st_size);
return(-1);
}
int os_get_file_Name(const char *pathname, char *file, size_t len)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
{
int i, newpos = -1;
for (i = 0; *(pathname+i) != &#39;\0&#39;; i++)
{
if (*(pathname+i) == &#39;/&#39;)
newpos = i;
}
if (newpos == -1)
{
if (strlen(pathname) &amp;gt; len-1)
{
return(-1);
}
strncpy(file, pathname, len);
}
else
{
if (strlen(pathname+newpos+1) &amp;gt; len-1)
{
return(-1);
}
strncpy(file, pathname+newpos+1, len);
}
return(0);
}
return(-1);
}
int os_get_file_path(const char *pathname, char *path, size_t len)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
{
int i;
int pathlen;
char tmppath[PATH_MAX];
const char *ptr = pathname;
pathlen = strlen(pathname);
i = pathlen;
while (pathname[i-1] != &#39;/&#39;)
i--;
if (pathname[0] == &#39;/&#39;)
{
strncpy(tmppath, pathname, i-1);
}
else if (pathname[0] == &#39;.&#39; &amp;amp;&amp;amp; pathname[1] != &#39;.&#39;)
{
getcwd(tmppath, PATH_MAX);
strncat(tmppath, ptr+1, i-2);
}
else if (pathname[0] == &#39;.&#39; &amp;amp;&amp;amp; pathname[1] == &#39;.&#39;)
{
char oldpath[PATH_MAX];
getcwd(oldpath, PATH_MAX);
chdir(&amp;quot;..&amp;quot;);
getcwd(tmppath, PATH_MAX);
chdir(oldpath);
strncat(tmppath, ptr+2, i-2);
}
else
{
getcwd(tmppath, PATH_MAX);
strcat(tmppath, &amp;quot;/&amp;quot;);
strncat(tmppath, pathname, i-1);
}
if (strlen(tmppath) &amp;gt; len-1)
{
return(-1);
}
strncpy(path, tmppath, len);
return(0);
}
return(-1);
}
time_t os_get_file_Atime(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
return(buf.st_atime);
return(-1);
}
time_t os_get_file_Mtime(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
return(buf.st_mtime);
return(-1);
}
int os_is_file_read(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
{
if ((S_IRUSR &amp;amp; buf.st_mode) == S_IRUSR)
return(1);
else
return(0);
}
return(-1);
}
int os_is_file_write(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
{
if ((S_IWUSR &amp;amp; buf.st_mode) == S_IWUSR)
return(1);
else
return(0);
}
return(-1);
}
int os_is_file_exec(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISREG(buf.st_mode))
{
if ((S_IXUSR &amp;amp; buf.st_mode) == S_IXUSR)
return(1);
else
return(0);
}
return(-1);
}
int os_is_link_file(const char *pathname)
{
struct stat buf;
if (lstat(pathname, &amp;amp;buf) &amp;lt; 0)
{
return(-1);
}
if (S_ISLNK(buf.st_mode))
return(1);
else
return(0);
}
int os_is_device_file(const char *pathname)
{
struct stat buf;
if (lstat(pathname, &amp;amp;buf) &amp;lt; 0)
{
return(-1);
}
if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode))
return(1);
else
return(0);
}
int os_is_regular_file(const char *pathname)
{
struct stat buf;
if (lstat(pathname, &amp;amp;buf) &amp;lt; 0)
{
return(-1);
}
if (S_ISREG(buf.st_mode))
return(1);
else
return(0);
}
/*flag:0, cover; 1, not cover.*/
int os_copy_file(const char *oldpath, const char *newpath, int flag)
{
int fdin, fdout;
int copylen = 0, leftlen = 0;
char buf[BUCKET_SIZE];
struct stat oldbuf, newbuf;
if (flag == 1)
{
int oldlen, newlen;
if (os_is_file_exist(newpath) == 1) /*file is exist.*/
{
oldlen = os_get_file_length(oldpath);
newlen = os_get_file_length(newpath);
if (oldlen &amp;lt; 0 || newlen &amp;lt; 0)
return(-1);
if (oldlen == newlen) /*length is same*/
return(0); /*return.*/
}
} /*if size not same or file not exist, copy will go on.*/
if ((fdin = open(oldpath, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fdin, &amp;amp;oldbuf) &amp;lt; 0)
{
close(fdin);
return(-1);
}
if ((fdout = open(newpath, O_RDONLY)) &amp;gt; 0)
{
if (fstat(fdout, &amp;amp;newbuf) == 0)
{
if (oldbuf.st_ino == newbuf.st_ino) /*oldbuf and newbuf is the same file.*/
{
close(fdin);
close(fdout);
return(0);
}
}
close(fdout);
}
if ((fdout = open(newpath, O_RDWR | O_CREAT | O_TRUNC, oldbuf.st_mode)) &amp;lt; 0)
{
close(fdin);
return(-1);
}
leftlen = oldbuf.st_size;
while (1)
{
if (leftlen &amp;gt; BUCKET_SIZE)
copylen = BUCKET_SIZE;
else
copylen = leftlen;
if (os_readn(fdin, buf, copylen) &amp;lt; 0)
{
close(fdout);
close(fdin);
return(-1);
}
if (os_writen(fdout, buf, copylen) &amp;lt; 0)
{
close(fdout);
close(fdin);
return(-1);
}
leftlen = leftlen - copylen;
if (leftlen &amp;lt;= 0)
break;
}
close(fdin);
close(fdout);
return(0);
}
int os_rm_file(const char *pathname)
{
if (unlink(pathname) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_rename_file(const char *oldpath, const char *newpath)
{
if (rename(oldpath, newpath) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_set_file_length(const char *pathname, int newlen)
{
if (truncate(pathname, newlen) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_set_file_mode(const char *pathname, mode_t mode)
{
if (chmod(pathname, mode) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_read_lock(int fd, off_t offset, int whence, off_t len)
{
if (lock_reg(fd, F_SETLK, F_RDLCK, offset, whence, len) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_readW_lock(int fd, off_t offset, int whence, off_t len)
{
if (lock_reg(fd, F_SETLKW, F_RDLCK, offset, whence, len) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_write_lock(int fd, off_t offset, int whence, off_t len)
{
if (lock_reg(fd, F_SETLK, F_WRLCK, offset, whence, len) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_writeW_lock(int fd, off_t offset, int whence, off_t len)
{
if (lock_reg(fd, F_SETLKW, F_WRLCK, offset, whence, len) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_unLock(int fd, off_t offset, int whence, off_t len)
{
if (lock_reg(fd, F_SETLKW, F_UNLCK, offset, whence, len) &amp;lt; 0)
{
return(-1);
}
return(0);
}
off_t os_seek(int fd, off_t offset, int whence)
{
if (lseek(fd, offset, whence) &amp;lt; 0)
{
return(-1);
}
return(0);
}
off_t os_seek2begin(int fd)
{
if (lseek(fd, 0, SEEK_SET) &amp;lt; 0)
{
return(-1);
}
return(0);
}
off_t os_seek2end(int fd)
{
if (lseek(fd, 0, SEEK_END) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_set_Utime(const char *pathname, const struct utimbuf *times)
{
if (utime(pathname, times) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_fsync(int fd)
{
if (fsync(fd) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_fflush(FILE *stream)
{
if (fflush(stream) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_is_dir_exist(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISDIR(buf.st_mode))
return(1);
return(0); /*not a dir, maybe file/fifo etc.*/
}
int os_is_dir(const char *pathname)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISDIR(buf.st_mode))
return(1);
else
return(0);
}
#if 1
int os_get_dir_name(const char *pathname, char *dirname, size_t len)
{
return(0);
}
#endif
int os_get_absolute_dir(const char *pathname, char *dirname, size_t len)
{
int fd;
struct stat buf;
if ((fd = open(pathname, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fd, &amp;amp;buf) &amp;lt; 0)
{
close(fd);
return(-1);
}
close(fd);
if (S_ISDIR(buf.st_mode))
{
int pathlen;
char tmppath[PATH_MAX];
const char *ptr = pathname;
pathlen = strlen(pathname);
if (pathname[0] == &#39;/&#39;)
{
strncpy(tmppath, pathname, PATH_MAX);
}
else if (pathname[0] == &#39;.&#39; &amp;amp;&amp;amp; pathname[1] != &#39;.&#39;)
{
getcwd(tmppath, PATH_MAX);
strncat(tmppath, ptr+1, PATH_MAX);
}
else if (pathname[0] == &#39;.&#39; &amp;amp;&amp;amp; pathname[1] == &#39;.&#39;)
{
char oldpath[PATH_MAX];
getcwd(oldpath, PATH_MAX);
chdir(&amp;quot;..&amp;quot;);
getcwd(tmppath, PATH_MAX);
chdir(oldpath);
strncat(tmppath, ptr+2, PATH_MAX);
}
else
{
getcwd(tmppath, PATH_MAX);
strcat(tmppath, &amp;quot;/&amp;quot;);
strncat(tmppath, pathname, PATH_MAX);
}
if (strlen(tmppath) &amp;gt; len-1)
{
return(-1);
}
strncpy(dirname, tmppath, len);
return(0);
}
return(-1);
}
int os_is_dir_empty(const char *pathname)
{
DIR *dp;
struct dirent *dirp;
int flag = 1;
if ((dp = opendir(pathname)) == NULL)
{
return(-1);
}
while ((dirp = readdir(dp)) != NULL)
{
if (strcmp(dirp-&amp;gt;d_name, &amp;quot;.&amp;quot;) == 0 || strcmp(dirp-&amp;gt;d_name, &amp;quot;..&amp;quot;) == 0)
continue;
else
{
flag = 0; /*dir is not empty.*/
break;
}
}
if (closedir(dp) &amp;lt; 0)
{
return(-1);
}
return(flag);
}
long long os_get_dir_size(const char *pathname)
{
long long dirsize = 0;
if (_os_get_dir_size(pathname, &amp;amp;dirsize) &amp;lt; 0)
return(-1); /*comm_errno has set in _os_get_dir_size().*/
return(dirsize);
}
int os_get_dir_fileCount(const char *pathname)
{
int filecount = 0;
if (_get_dir_file_count(pathname, &amp;amp;filecount) &amp;lt; 0)
return(-1);
return(filecount);
}
int os_mk_dir(const char *pathname, mode_t mode)
{
if (mkdir(pathname, mode) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_set_dir_mode(const char *pathname, mode_t mode)
{
if (chmod(pathname, mode) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_copy_dir(const char *oldpath, const char *newpath, int flag, long sleeptime)
{
int fdold, fdnew;
char srcbuf[PATH_MAX], dstbuf[PATH_MAX];
DIR *dp;
struct dirent *ep;
struct stat oldbuf, newbuf;
/*judge the oldpath and newpath is the same dir.*/
if ((fdold = open(oldpath, O_RDONLY)) &amp;lt; 0)
{
return(-1);
}
if (fstat(fdold, &amp;amp;oldbuf) != 0)
{
close(fdold);
return(-1);
}
if ((fdnew = open(newpath, O_RDONLY)) &amp;gt;= 0)
{
if (stat(newpath, &amp;amp;newbuf) == 0)
{
if (oldbuf.st_ino == newbuf.st_ino)
{
close(fdold);
close(fdnew);
return(0);
}
}
close(fdnew);
}
close(fdold);
mkdir(newpath, oldbuf.st_mode); /*if newpath exist, ignore; else create.*/
if ((dp = opendir(oldpath)) == NULL)
{
return(-1);
}
while ((ep = readdir(dp)) != NULL)
{
snprintf(srcbuf, PATH_MAX, &amp;quot;%s/%s&amp;quot;, oldpath, ep-&amp;gt;d_name);
snprintf(dstbuf, PATH_MAX, &amp;quot;%s/%s&amp;quot;, newpath, ep-&amp;gt;d_name);
if (strcmp(ep-&amp;gt;d_name, &amp;quot;.&amp;quot;) == 0 || strcmp(ep-&amp;gt;d_name, &amp;quot;..&amp;quot;) == 0)
continue;
if (lstat(srcbuf, &amp;amp;oldbuf) != 0)
{
closedir(dp);
return(-1);
}
if (S_ISDIR(oldbuf.st_mode))
{
if (os_copy_dir(srcbuf, dstbuf, flag, sleeptime) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
}
else if (S_ISREG(oldbuf.st_mode))
{
if (os_copy_file(srcbuf, dstbuf, flag) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
if (sleeptime != 0)
usleep(sleeptime);
}
else if (S_ISLNK(oldbuf.st_mode))
{
char tmpbuf[PATH_MAX];
int len;
if ((len = readlink(srcbuf, tmpbuf, PATH_MAX)) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
tmpbuf[len] = &#39;\0&#39;;
unlink(dstbuf); /*ignore old link is exist, unlink and relink it.*/
if (symlink(tmpbuf, dstbuf) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
}
else
; /*others is ignored.*/
}
if (closedir(dp) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_rename_dir(const char *oldpath, const char *newpath)
{
if (rename(oldpath, newpath))
{
return(-1);
}
return(0);
}
int os_rm_dir(const char *pathname)
{
char dirbuf[PATH_MAX];
DIR *dp;
struct dirent *ep;
struct stat buf;
if ((dp = opendir(pathname)) == NULL)
{
return(-1);
}
while ((ep = readdir(dp)) != NULL)
{
snprintf(dirbuf, PATH_MAX, &amp;quot;%s/%s&amp;quot;, pathname, ep-&amp;gt;d_name);
if (strcmp(ep-&amp;gt;d_name, &amp;quot;.&amp;quot;) == 0 || strcmp(ep-&amp;gt;d_name, &amp;quot;..&amp;quot;) == 0)
continue;
if (lstat(dirbuf, &amp;amp;buf) != 0)
{
closedir(dp);
return(-1);
}
if (S_ISDIR(buf.st_mode))
{
if (os_rm_dir(dirbuf) &amp;lt; -1)
{
closedir(dp);
return(-1);
}
}
else
{
if (unlink(dirbuf) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
_del_file_count++;
usleep(200*1000);
}
}
if (closedir(dp) &amp;lt; 0)
{
return(-1);
}
if (rmdir(pathname) &amp;lt; 0)
{
return(-1);
}
return(0);
}
int os_get_delFileCount(void)
{
return(_del_file_count);
}
int os_clear_delFileCount(void)
{
_del_file_count = 0;
return(0);
}
/*some tools function, not in the commlib.*/
static int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)
{
struct flock lock;
lock.l_type = type; /* F_RDLCK, F_WRLCK, F_UNLCK */
lock.l_start = offset; /* byte offset, relative to l_whence */
lock.l_whence = whence; /* SEET_SET, SEEK_CUR, SEEK_END */
lock.l_len = len; /* #bytes (0 means to EOF) */
return(fcntl(fd, cmd, &amp;amp;lock));
}
static int _os_get_dir_size(const char *pathname, long long *dirsize)
{
char dirbuf[PATH_MAX];
DIR *dp;
struct dirent *ep;
struct stat buf;
if ((dp = opendir(pathname)) == NULL)
{
return(-1);
}
while ((ep = readdir(dp)) != NULL)
{
snprintf(dirbuf, PATH_MAX, &amp;quot;%s/%s&amp;quot;, pathname, ep-&amp;gt;d_name);
if (strcmp(ep-&amp;gt;d_name, &amp;quot;.&amp;quot;) == 0 || strcmp(ep-&amp;gt;d_name, &amp;quot;..&amp;quot;) == 0)
continue;
if (lstat(dirbuf, &amp;amp;buf) != 0)
{
closedir(dp);
return(-1);
}
if (S_ISDIR(buf.st_mode))
{
if (_os_get_dir_size(dirbuf, dirsize) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
}
else if (S_ISREG(buf.st_mode))
*dirsize = *dirsize + buf.st_size;
}
if (closedir(dp) &amp;lt; 0)
{
return(-1);
}
*dirsize = *dirsize + 3*4096; /*dir&#39;s size is 4KB, each dir has &amp;quot;.&amp;quot;, &amp;quot;..&amp;quot; and self, so 12KB.*/
return(0);
}
static int _get_dir_file_count(const char *pathname, int *filecount)
{
char dirbuf[PATH_MAX];
DIR *dp;
struct dirent *ep;
struct stat buf;
if ((dp = opendir(pathname)) == NULL)
{
return(-1);
}
while ((ep = readdir(dp)) != NULL)
{
snprintf(dirbuf, PATH_MAX, &amp;quot;%s/%s&amp;quot;, pathname, ep-&amp;gt;d_name);
if (strcmp(ep-&amp;gt;d_name, &amp;quot;.&amp;quot;) == 0 || strcmp(ep-&amp;gt;d_name, &amp;quot;..&amp;quot;) == 0)
continue;
if (lstat(dirbuf, &amp;amp;buf) != 0)
{
closedir(dp);
return(-1);
}
if (S_ISDIR(buf.st_mode))
{
if (_get_dir_file_count(dirbuf, filecount) &amp;lt; 0)
{
closedir(dp);
return(-1);
}
}
else if (S_ISREG(buf.st_mode))
(*filecount) = (*filecount) + 1;
}
if (closedir(dp) &amp;lt; 0)
{
return(-1);
}
return(0);
}
pid_t os_gettid(void)
{
return syscall(SYS_gettid);
}
/*****************************************************************************
Prototype : _atoul
Description : 10�����ַ���ת��Ϊ�޷������֡�
Input args : char *str 10�����ַ���
�����ܷ���
Output args : uint32_t* pulValue, ת���������
Return value : 0 ת���ɹ�
-1 ת��ʧ��
*****************************************************************************/
static int _atoul(char *str, uint32_t * pulValue)
{
uint32_t ulResult=0;
while (*str)
{
if (isdigit((int)*str))
{
/*���֧�ֵ�0xFFFFFFFF(4294967295), X * 10 + (*str)-48 &amp;lt;= 4294967295
���ԣ� X = 429496729 */
if ((ulResult&amp;lt;429496729) || ((ulResult==429496729) &amp;amp;&amp;amp; (*str&amp;lt;&#39;6&#39;)))
{
ulResult = ulResult*10 + (*str)-48;
}
else
{
*pulValue = ulResult;
return -1;
}
}
else
{
*pulValue=ulResult;
return -1;
}
str++;
}
*pulValue=ulResult;
return 0;
}
/*****************************************************************************
Prototype : _atoulx
Description : 16�����ַ���ת��Ϊ�޷������֡������16�����ַ���������ǰ׺0x
Input args : char *str 16�����ַ���, ������ǰ׺0x. ��ABCDE
Output args : uint32_t* pulValue, ת���������
Return value : 0 ת���ɹ�
-1 ת��ʧ��
*****************************************************************************/
#define ASC2NUM(ch) (ch - &#39;0&#39;)
#define HEXASC2NUM(ch) (ch - &#39;A&#39; + 10)
static int _atoulx(char *str, uint32_t* pulValue)
{
uint32_t ulResult=0;
uint8_t ch;
while (*str)
{
ch = toupper(*str);
if (isdigit(ch) || ((ch &amp;gt;= &#39;A&#39;) &amp;amp;&amp;amp; (ch &amp;lt;= &#39;F&#39; )))
{
if (ulResult &amp;lt; 0x10000000)
{
ulResult = (ulResult &amp;lt;&amp;lt; 4) + ((ch&amp;lt;=&#39;9&#39;)?(ASC2NUM(ch)):(HEXASC2NUM(ch)));
}
else
{
*pulValue=ulResult;
return -1;
}
}
else
{
*pulValue=ulResult;
return -1;
}
str++;
}
*pulValue=ulResult;
return 0;
}
/*****************************************************************************
Prototype : os_str2number
Description : 10/16 �����ַ���ת��Ϊ�޷������֡�
Input args : char *str
10�����ַ���, �����ܷ���
16�����ַ���, ����ǰ׺0x. ��0x12345678
Output args : uint32_t* pulValue, ת���������
Return value : ת���ɹ�:0
ת��ʧ��:-1
*****************************************************************************/
int os_str2number(char *str , uint32_t* pulValue)
{
/*�ж��Ƿ�16���Ƶ��ַ���*/
if (*str == &#39;0&#39; &amp;amp;&amp;amp; (*(str+1) == &#39;x&#39; || *(str+1) == &#39;X&#39;))
{
if (*(str+2) == &#39;\0&#39;)
{
return -1;
}
else
{
return _atoulx(str+2, pulValue);
}
}
else
{
return _atoul(str, pulValue);
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux lib nanomsg</title><link>/language/clang/linux-lib-nanomsg/</link><pubDate>Mon, 25 May 2020 08:30:56 CST</pubDate><author>rinetd</author><guid>/language/clang/linux-lib-nanomsg/</guid><description>
&lt;p&gt;&lt;a href=&#34;https://github.com/nanomsg/mangos&#34; target=&#34;_blank&#34;&gt;nanomsg/mangos: mangos is a pure Golang implementation of nanomsg&#39;s &amp;quot;Scalablilty Protocols&amp;quot;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NNG/nanomsg 是最近项目上使用到的一个通信库，用来实现进程间过程调用和线程间通信，很是方便。&lt;/p&gt;
&lt;p&gt;NNG 是 nanomsg 的继任版本，而 nanomsg 则是流行的 ZMQ 的 C 重写版。&lt;/p&gt;
&lt;p&gt;NNG 将通信使用的协议和传输分离，同一个协议可以工作在不同的传输层上，类似与 TCP/IP 的应用层和传输层的分层，同时接口上屏蔽了底层细节，统一用字符串 URL 来描述传输模式。这样当使用场景修改时，可以通过简单修改 URL 来实现适应，极具灵活性。&lt;/p&gt;
&lt;p&gt;同时如 NNG 描述所言 “light-weight brokerless messaging”，NNG 中的通信各方是不需要第三方程序介入的，这与 MQTT/Redis 通信需要服务器不同。这样很适合作为通信库来使用而没有其他依赖。&lt;/p&gt;
&lt;h4 id=&#34;nng-支持的通信协议主要有以下几种&#34;&gt;NNG 支持的通信协议主要有以下几种：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt; PAIR 一对一双向通信。
PIPELINE(PUSH/PULL) 单向通信，类似与生产者消费者模型的消息队列。 多对多
PUB/SUB 单向广播。 多对多
REQ/REP 请求-应答模式，类似与 RPC 模式。
BUS 网状连接通信，每个加入节点都可以发送/接受广播消息。
SURVEY 用于多节点表决或者服务发现。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nng-支持的传输模式主要有以下三种常用-其他还有tcp附加tls-1-2加密的tls传输和基于websocket的ws传输&#34;&gt;NNG 支持的传输模式主要有以下三种常用，其他还有tcp附加tls 1.2加密的tls传输和基于WebSocket的ws传输：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; inproc 进程内线程间传输
ipc 主机内进程间传输
tcp 网络内主机间传输
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通信协议里除了 PAIR 之外，基本都是一对多的通信模式，这点需要注意，以 PIPELINE 和 PUB/SUB 为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PIPELINE 的 PUSH 端是 client，一个 PUSH 可以连接多个 PULL 端，发送数据时会选择其中一个可用的发送；PULL 端是 server，一个 PULL 可以接收多个 PUSH 连接和数据。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PUB/SUB 的 SUB 端是 client，一个 SUB 可以连接多个不同的 PUB 端，接收多个 PUB 端广播的数据；PUB 端是 server，一个 PUB 可以接收多个 SUB 连接并广播数据。&lt;br /&gt;
基于以上，多个程序是没办法共用一个 PUB/SUB 通道来广播数据的，这与 ROS 里的 topic 和 LCM 中的 channel 模式不同。如果要实现类似功能，则可以使用 PIPELINE + PUB/SUB 来处理：&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;独立一个话题发布的程序，拥有一个 PULL 和 PUB。&lt;br /&gt;
PULL 约定一个 URL，所有需要发布该话题的程序都 PUSH 数据到该 URL 上。&lt;br /&gt;
PUB 约定一个 URL，所有需要获取该话题的程序都 SUB 到该 URL 上。&lt;br /&gt;
程序内部循环将 PULL 读取的数据发送到 PUB 上。&lt;br /&gt;
以上则可以模拟出 ROS topic 数据合并 或者 LCM 中 channel 的类似功能。&lt;/p&gt;
&lt;p&gt;整体上看，NNG 的 API 很简约，主要是 4 个，open/recv/send/close，open 根据协议不同使用的函数会不同。配置则是 setopt/getopt，与 UNIX API 类似。API 中没有上下文环境（context-less）依赖，只需要一个 nng_socket，这种设计和实现方法值得去学习一下（初步揣测应该是使用指针值作为handle，如果要强制编译器做类型检测，则会套上一层 struct，如 typedef struct { _nng_xxx_socket * p } nng_socket;）。&lt;/p&gt;
&lt;p&gt;NNG 协议基本上囊括了常见的通信需求，一些特殊的需求，也可以通过组合协议来实现，比如上面的模拟 ROS topic 或者 LCM channel 的方法。这样一来，如果在程序中使用 NNG，不管是多进程，还是多线程，通过设计，可以进一步增强模块化，同时不乏灵活性。如果环境变化，程序不管是由多进程改成多线程，还是由多线程改成多主机，都很容易实现。&lt;/p&gt;
&lt;p&gt;常见模块/进程/线程间通信，可以依据具体需求来使用 PIPELINE（消息队列） 还是 REQ/REP（过程调用），而不是锁+全局变量，每个模块单元只需要做单一相关的具体事务，无需知晓全局状态。&lt;/p&gt;
&lt;p&gt;nanomsg的前身是zeromsg，zeromq估计很多人都见过，是一个消息队列，而nanomq的模式很多和zeromq是类似的，我们这里就简单的解析一下（如果和官方不相同，请以官方为准）。&lt;/p&gt;
&lt;h4 id=&#34;1-one-to-one-protocol&#34;&gt;1.One-to-one protocol&lt;/h4&gt;
&lt;p&gt;一对一协议，这个就是字面意思，只能一对一通信，为通讯双向。关键字：NN_PAIR。&lt;/p&gt;
&lt;h4 id=&#34;2-request-reply-protocol&#34;&gt;2.Request/reply protocol&lt;/h4&gt;
&lt;p&gt;请求/回复协议，由请求端发起请求，然后等待回应端应答，一般是一个REP多个REQ；关键字：NN_REP,NN_REQ。&lt;/p&gt;
&lt;h4 id=&#34;3-publish-subscribe-protocol&#34;&gt;3.Publish/subscribe protocol&lt;/h4&gt;
&lt;p&gt;发布订阅协议，将消息广播到多个目的地，消息从NN_PUB发送，并且只会由订阅了匹配主题的NN_SUB接收；这种模式只会发布给在线的订阅端，如果发布端开始发布消息时，订阅端尚未连接，则这些消息会被直接丢弃；同时订阅端只负责接收不能反馈；关键字：NN_PUB，NN_SUB。&lt;/p&gt;
&lt;h4 id=&#34;4-survey-protocol&#34;&gt;4.Survey protocol&lt;/h4&gt;
&lt;p&gt;调查协议，允许向多个地点广播调查并收集响应，关键字：NN_SURVEYOR，NN_RESPONDENT。&lt;/p&gt;
&lt;h4 id=&#34;5-pipeline-protocol&#34;&gt;5.Pipeline protocol&lt;/h4&gt;
&lt;p&gt;通过一系列步骤传递任务的的协议，这个协议是可扩展的（官方原文：scalability protocol for passing tasks through a series of processing steps.）；它可以公平的对来自先前的处理步骤的消息进行排队，并在下一个处理步骤的实例中对它进行负载均衡；关键字，NN_PUSH，NN_PULL。&lt;/p&gt;
&lt;h4 id=&#34;6-message-bus-protocol&#34;&gt;6.Message bus protocol&lt;/h4&gt;
&lt;p&gt;消息总线（message bus），将消息从任何节点广播到拓扑中的所有其他节点，自身不会收到自己发出去的消息；这种模式只能缩放到本地级别（单个机器或者单个局域网），如果尝试进一步扩展可能会导致单个节点消息过载；关键字：NN_BUS。&lt;/p&gt;
&lt;p&gt;  这次主要是使用nanomsg库实现多线程之间的通信，在我们复杂的多线程编程中可能各个线程需要共用一些信息，平常加互斥锁等等，有时候也是相当麻烦，这里是使用nanomsg库实现多线程的通信，主要这次是一对一线程双向通信和单向通信的demo。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h4 id=&#34;多线程一对一双向通信demo&#34;&gt;多线程一对一双向通信demo&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;nanomsg/pair.h&amp;gt;
#include &amp;lt;nanomsg/bus.h&amp;gt;
#include &amp;lt;nanomsg/nn.h&amp;gt;
/*
此程序为nanomsg多线程一对一双向通信demo。
*/
//inproc 标识用于多线程通信
char *url = &amp;quot;inproc://sky_test&amp;quot;;
int server_sock_init(int *sock)
{
*sock = nn_socket (AF_SP, NN_PAIR);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create server sock failed\r\n&amp;quot;);
return 1;
}
if (nn_bind(*sock, url) &amp;lt; 0) {
printf(&amp;quot;bind server sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;server socket init success...\r\n&amp;quot;);
return 0;
}
int client_sock_init(int *sock)
{
*sock = nn_socket (AF_SP, NN_PAIR);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create client sock failed\r\n&amp;quot;);
return 1;
}
if (nn_connect(*sock, url) &amp;lt; 0) {
printf(&amp;quot;connect server sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;client socket init success...\r\n&amp;quot;);
return 0;
}
void *thread_test(void *arg)
{
int c_sock;
char *tx_msg = &amp;quot;Hello Main Thread&amp;quot;;
if (0 != client_sock_init(&amp;amp;c_sock)) {
return;
}
while (1) {
//发送信息到主线程客户端
while (1) {
size_t len = strlen (tx_msg) + 1;
if (nn_send(c_sock, tx_msg, len, 0) &amp;lt; 0) {
printf(&amp;quot;Thread Send Msg Failed\r\n&amp;quot;);
usleep(500000);
continue;
}
break;
}
while (1) {
//接收主线程客户端信息
char *rx_msg = NULL;
int result = nn_recv(c_sock, &amp;amp;rx_msg, NN_MSG,NN_DONTWAIT);
if (result &amp;gt; 0) {
printf(&amp;quot;Thread Recieve: %s\r\n&amp;quot;, rx_msg);
nn_freemsg (rx_msg);
break;
}
usleep(200000);
}
}
}
int main()
{
int s_sock;
pthread_t ps;
char *tx_msg = &amp;quot;Hi Thread Test&amp;quot;;
if (0 != server_sock_init(&amp;amp;s_sock)) {
return 1;
}
pthread_create(&amp;amp;ps, NULL, thread_test, NULL);
sleep(1);
while (1) {
while (1) {
//接收子线程客户端信息
char *rx_msg = NULL;
int result = nn_recv(s_sock, &amp;amp;rx_msg, NN_MSG,NN_DONTWAIT);
if (result &amp;gt; 0) {
printf(&amp;quot;Main Recieve: %s\r\n&amp;quot;, rx_msg);
nn_freemsg (rx_msg);
break;
}
usleep(200000);
}
//发送信息到子线程客户端
while (1) {
size_t len = strlen (tx_msg) + 1;
if (nn_send(s_sock, tx_msg, len, 0) &amp;lt; 0) {
printf(&amp;quot;Main Send Msg Failed\r\n&amp;quot;);
usleep(500000);
continue;
}
break;
}
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译：&lt;br /&gt;
&lt;code&gt;gcc -o nanomsg_pair nanomsg_pair.c -lnanomsg -lpthread&lt;/code&gt;&lt;br /&gt;
运行结果：&lt;br /&gt;
sky@ubuntu:~/Study/nanomsg/code_test/inproc/pair$ ./nanomsg_pair&lt;br /&gt;
server socket init success...&lt;br /&gt;
client socket init success...&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
Thread Recieve: Hi Thread Test&lt;br /&gt;
Main Recieve: Hello Main Thread&lt;br /&gt;
.....&lt;/p&gt;
&lt;h4 id=&#34;多线程一对一单向通信-类似管道-demo&#34;&gt;多线程一对一单向通信（类似管道）demo&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;nanomsg/pipeline.h&amp;gt;
#include &amp;lt;nanomsg/nn.h&amp;gt;
/*
此程序为nanomsg多线程一对一单向通信demo。
*/
//inproc 标识用于多线程通信
char *url = &amp;quot;inproc://sky_test&amp;quot;;
//发送数据的socket初始化
int send_sock_init(int *sock)
{
*sock = nn_socket (AF_SP, NN_PUSH);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create send data sock failed\r\n&amp;quot;);
return 1;
}
if (nn_bind(*sock, url) &amp;lt; 0) {
printf(&amp;quot;bind send data sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;send data socket init success...\r\n&amp;quot;);
return 0;
}
//接收数据的socket初始化
int recieve_sock_init(int *sock)
{
*sock = nn_socket (AF_SP, NN_PULL);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create recieve data sock failed\r\n&amp;quot;);
return 1;
}
if (nn_connect(*sock, url) &amp;lt; 0) {
printf(&amp;quot;connect recieve data sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;recieve data socket init success...\r\n&amp;quot;);
return 0;
}
//线程测试
void *thread_test(void *arg)
{
int c_sock;
if (0 != recieve_sock_init(&amp;amp;c_sock)) {
return;
}
while (1) {
//轮询接收信息
char *rx_msg = NULL;
int result = nn_recv(c_sock, &amp;amp;rx_msg, NN_MSG, NN_DONTWAIT);
if (result &amp;gt; 0) {
printf(&amp;quot;Thread Recieve: %s\r\n&amp;quot;, rx_msg);
nn_freemsg (rx_msg);
}
sleep(1);
}
}
int main()
{
int s_sock;
pthread_t ps;
char *tx_msg = &amp;quot;Hello thread test&amp;quot;;
if (0 != send_sock_init(&amp;amp;s_sock)) {
return 1;
}
pthread_create(&amp;amp;ps, NULL, thread_test, NULL);
sleep(1);
//间隔两秒，发送信息到子线程接收数据端
while (1) {
size_t len = strlen (tx_msg) + 1;
if (nn_send(s_sock, tx_msg, len, 0) &amp;lt; 0) {
printf(&amp;quot;Main Send Msg Failed\r\n&amp;quot;);
usleep(500000);
continue;
}
sleep(2);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译：&lt;br /&gt;
&lt;code&gt;gcc -o nanomsg_pipe nanomsg_pipe.c -lnanomsg -lpthread&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br /&gt;
sky@ubuntu:~/Study/nanomsg/code_test/inproc/pipeline$ ./nanomsg_pipe&lt;br /&gt;
send data socket init success...&lt;br /&gt;
recieve data socket init success...&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
Thread Recieve: Hello thread test&lt;br /&gt;
...&lt;br /&gt;
 总结：&lt;br /&gt;
      使用nanomsg实现线程间通信，对于多线程编程来说是相当方便了，nanomsg库又很轻量级，对于嵌入式程序编程真的非常好用。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「Dancer&lt;strong&gt;Sky」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/Dancer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/Dancer&lt;/a&gt;&lt;/strong&gt;Sky/article/details/83538565&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[文件] pair.c ~ 2KB 下载(28)&lt;br /&gt;
```cpp&lt;br /&gt;
#include &amp;quot;common.h&amp;quot;&lt;br /&gt;
#include &lt;nanomsg/pair.h&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#define NODE0 &amp;quot;node0&amp;quot;&lt;br /&gt;
#define NODE1 &amp;quot;node1&amp;quot;&lt;br /&gt;
#define SOCKET_ADDR &amp;quot;ipc:///tmp/pair.ipc&amp;quot;&lt;/p&gt;
&lt;p&gt;int send_name(int sock, const char *name)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; printf(&amp;quot;%s: SENDING \&amp;quot;%s\&amp;quot;\n&amp;quot;, name, name);
int sz_n = strlen(name) + 1;
return nn_send(sock, name, sz_n, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int recv_name(int sock, const char *name)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; char *buf = NULL;
int result = nn_recv(sock, &amp;amp;buf, NN_MSG, 0);
if (result &amp;gt; 0)
{
printf(&amp;quot;%s: RECEIVED \&amp;quot;%s\&amp;quot;\n&amp;quot;, name, buf);
nn_freemsg(buf);
}
return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int send_recv(int sock, const char *name)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int to = 100;
assert(nn_setsockopt (sock, NN_SOL_SOCKET, NN_RCVTIMEO, &amp;amp;to, sizeof (to)) &amp;gt;= 0);
while(1)
{
recv_name(sock, name);
sleep(1);
send_name(sock, name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int node0(const char *url)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int sock = nn_socket(AF_SP, NN_PAIR);
assert(sock &amp;gt;= 0);
assert(nn_bind (sock, url) &amp;gt;= 0);
send_recv(sock, NODE0);
return nn_shutdown (sock, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int node1(const char *url)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int sock = nn_socket(AF_SP, NN_PAIR);
assert(sock &amp;gt;= 0);
assert(nn_connect(sock, url) &amp;gt;= 0);
send_recv(sock, NODE1);
return nn_shutdown (sock, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int argc, char **argv)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; if (argc == 2 &amp;amp;&amp;amp; strncmp(NODE0, argv[1], strlen(NODE0)) == 0) {
return node0(SOCKET_ADDR);
} else if (argc == 2 &amp;amp;&amp;amp; strncmp (NODE1, argv[1], strlen (NODE1)) == 0) {
return node1(SOCKET_ADDR);
} else {
fprintf (stderr, &amp;quot;Usage: pair %s|%s &amp;lt;ARG&amp;gt; ...\n&amp;quot;, NODE0, NODE1);
return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### PubSub一对多主题订阅通信Demo
2. [文件] pubsub.c ~ 2KB 下载(21)
```cpp
#   这次是nanomsg库实现的一个类似于MQTT通信的一种方式，广播订阅的一个一对多的通信方式。一个主的广播消息，其他可以订阅自己想要的主题信息，然后就会只接收订阅的主题的信息。
PubSub一对多主题订阅通信Demo
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;nanomsg/pubsub.h&amp;gt;
#include &amp;lt;nanomsg/nn.h&amp;gt;
/*
此程序为nanomsg多线程一对多单向通信demo,类似MQTT通信，一个广播，其他为订阅相应主题
客户端只接收到自己订阅的对应主题的内容。
*/
//inproc 标识用于多线程通信
char *url = &amp;quot;inproc://sky_test&amp;quot;;
//发送数据的socket初始化
int send_sock_init(int *sock)
{
*sock = nn_socket (AF_SP, NN_PUB);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create send data sock failed\r\n&amp;quot;);
return 1;
}
if (nn_bind(*sock, url) &amp;lt; 0) {
printf(&amp;quot;bind send data sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;send data socket init success...\r\n&amp;quot;);
return 0;
}
//接收数据的socket初始化
int recieve_sock_init(int *sock, char *topic)
{
*sock = nn_socket (AF_SP, NN_SUB);
if (*sock &amp;lt; 0) {
printf(&amp;quot;create recieve data sock failed\r\n&amp;quot;);
return 1;
}
if (NULL == topic) {
//设置订阅主题为全部
nn_setsockopt(*sock, NN_SUB, NN_SUB_SUBSCRIBE, &amp;quot;&amp;quot;, 0);
} else {
//设置订阅的主题及主题长度，主要是对比发送内容的开始字节
//如设置主题为&amp;quot;sky:&amp;quot;,那么就会对比信息前面字节是否相同，相同则可以收到该信息
nn_setsockopt(*sock, NN_SUB, NN_SUB_SUBSCRIBE, topic, strlen(topic));
}
if (nn_connect(*sock, url) &amp;lt; 0) {
printf(&amp;quot;connect recieve data sock failed\r\n&amp;quot;);
return 1;
}
printf(&amp;quot;recieve data socket init success...\r\n&amp;quot;);
return 0;
}
//线程1测试
void *thread_test(void *arg)
{
int c_sock;
if (0 != recieve_sock_init(&amp;amp;c_sock, &amp;quot;sky:&amp;quot;)) {
return;
}
while (1) {
//轮询接收订阅主题&amp;quot;sky:&amp;quot;信息
char *rx_msg = NULL;
int result = nn_recv(c_sock, &amp;amp;rx_msg, NN_MSG, NN_DONTWAIT);
if (result &amp;gt; 0) {
printf(&amp;quot;Thread 1 Recieve: %s\r\n\r\n&amp;quot;, rx_msg);
nn_freemsg (rx_msg);
}
sleep(1);
}
}
//线程2测试
void *thread_test2(void *arg)
{
int c_sock;
if (0 != recieve_sock_init(&amp;amp;c_sock, &amp;quot;born:&amp;quot;)) {
return;
}
while (1) {
//轮询接收订阅主题&amp;quot;born:&amp;quot;信息
char *rx_msg = NULL;
int result = nn_recv(c_sock, &amp;amp;rx_msg, NN_MSG, NN_DONTWAIT);
if (result &amp;gt; 0) {
printf(&amp;quot;Thread 2 Recieve: %s\r\n\r\n&amp;quot;, rx_msg);
nn_freemsg (rx_msg);
}
sleep(1);
}
}
//发送数据
int send_data(int sock, char *data)
{
if (data == NULL) {
return 1;
}
if (nn_send(sock, data, strlen(data)+1, 0) &amp;lt; 0) {
return 1;
}
printf(&amp;quot;Main Server Send:%s\r\n\r\n&amp;quot;, data);
return 0;
}
int main()
{
int s_sock, ret, i = 0;
pthread_t ps, ps2;
char *tx_msg = &amp;quot;sky:Hello Thread Sky&amp;quot;;
char *tx_msg1 = &amp;quot;born:Hello Thread Born&amp;quot;;
char *tx_msg2 = &amp;quot;Storm:Hello Thread Storm&amp;quot;;
if (0 != send_sock_init(&amp;amp;s_sock)) {
return 1;
}
//创建子线程，接收信息
pthread_create(&amp;amp;ps, NULL, thread_test, NULL);
pthread_create(&amp;amp;ps2, NULL, thread_test2, NULL);
sleep(1);
//间隔两秒，发送信息到子线程接收数据端
while (1) {
//测试发送广播
if (0 == i) {
ret = send_data(s_sock, tx_msg);
if (0 == ret) {
i ++;
}
} else if (1 == i) {
ret = send_data(s_sock, tx_msg1);
if (0 == ret) {
i ++;
}
} else if (2 == i) {
ret = send_data(s_sock, tx_msg2);
if (0 == ret) {
i = 0;
}
}
sleep(2);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译&lt;br /&gt;
&lt;code&gt;gcc -o nanomsg_pubsub nanomsg_pubsub.c -lnanomsg -lpthread&lt;/code&gt;&lt;br /&gt;
运行结果：&lt;br /&gt;
sky@ubuntu:~/Study/nanomsg/code_test/inproc/pubsub$ ./nanomsg_pubsub&lt;br /&gt;
send data socket init success...&lt;br /&gt;
recieve data socket init success...&lt;br /&gt;
recieve data socket init success...&lt;br /&gt;
Main Server Send:sky:Hello Thread Sky&lt;/p&gt;
&lt;p&gt;Thread 1 Recieve: sky:Hello Thread Sky&lt;/p&gt;
&lt;p&gt;Main Server Send:born:Hello Thread Born&lt;/p&gt;
&lt;p&gt;Thread 2 Recieve: born:Hello Thread Born&lt;/p&gt;
&lt;p&gt;Main Server Send:Storm:Hello Thread Storm&lt;/p&gt;
&lt;p&gt;Main Server Send:sky:Hello Thread Sky&lt;/p&gt;
&lt;p&gt;Thread 1 Recieve: sky:Hello Thread Sky&lt;br /&gt;
...&lt;/p&gt;
&lt;p&gt;根据结果可以看到，线程1，2分别订阅了sky born主题，所以可以收到，而storm主题没订阅所以都没有收到。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「Dancer&lt;strong&gt;Sky」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/Dancer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/Dancer&lt;/a&gt;&lt;/strong&gt;Sky/article/details/83539077&lt;/p&gt;
&lt;h3 id=&#34;3-文件-reqrep-c&#34;&gt;3. [文件] reqrep.c&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;common.h&amp;quot;
#include &amp;lt;nanomsg/reqrep.h&amp;gt;
#define NODE0 &amp;quot;node0&amp;quot;
#define NODE1 &amp;quot;node1&amp;quot;
#define DATE &amp;quot;DATE&amp;quot;
#define SOCKET_ADDR &amp;quot;ipc:///tmp/reqrep.ipc&amp;quot;
char *date(void)
{
time_t raw = time(&amp;amp;raw);
struct tm *info = localtime(&amp;amp;raw);
char *text = asctime(info);
text[strlen(text) - 1] = &#39;\0&#39;;
return text;
}
int node0(const char *url)
{
int sz_date = strlen(DATE) + 1;
int sock = nn_socket(AF_SP, NN_REP);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, url) &amp;gt;= 0);
while (1) {
char *buf = NULL;
int bytes = nn_recv(sock, &amp;amp;buf, NN_MSG, 0);
assert(bytes &amp;gt;= 0);
if (strncmp(DATE, buf, sz_date) == 0) {
printf(&amp;quot;NODE0: RECEIVED DATE REQUEST\n&amp;quot;);
char *d = date();
int sz_d = strlen(d) + 1;
printf(&amp;quot;NODE0: SENDING DATE %s\n&amp;quot;, d);
bytes = nn_send(sock, d, sz_d, 0);
assert(bytes == sz_d);
}
nn_freemsg (buf);
}
return nn_shutdown (sock, 0);
}
int node1(const char *url)
{
int sz_date = strlen(DATE) + 1;
char *buf = NULL;
int bytes = -1;
int sock = nn_socket(AF_SP, NN_REQ);
assert(sock &amp;gt;= 0);
assert(nn_connect(sock, url) &amp;gt;= 0);
/* Send */
printf(&amp;quot;NODE1: SENDING DATE REQUEST %s\n&amp;quot;, DATE);
bytes = nn_send (sock, DATE, sz_date, 0);
assert(bytes == sz_date);
/* Receive */
bytes = nn_recv (sock, &amp;amp;buf, NN_MSG, 0);
assert(bytes &amp;gt;= 0);
printf(&amp;quot;NODE1: RECEIVED DATE %s\n&amp;quot;, buf);
nn_freemsg(buf);
return nn_shutdown (sock, 0);
}
int main (int argc, char **argv)
{
if (argc == 2 &amp;amp;&amp;amp; strncmp(NODE0, argv[1], strlen(NODE0)) == 0) {
return node0(SOCKET_ADDR);
} else if (argc == 2 &amp;amp;&amp;amp; strncmp(NODE1, argv[1], strlen(NODE1)) == 0) {
return node1(SOCKET_ADDR);
} else {
fprintf (stderr, &amp;quot;Usage: reqrep %s|%s &amp;lt;ARG&amp;gt; ...\n&amp;quot;, NODE0, NODE1);
return 1;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;[文件] survey.c&lt;br /&gt;
```cpp&lt;br /&gt;
#include &amp;quot;common.h&amp;quot;&lt;br /&gt;
#include &lt;nanomsg/survey.h&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#define SERVER &amp;quot;server&amp;quot;&lt;br /&gt;
#define CLIENT &amp;quot;client&amp;quot;&lt;br /&gt;
#define DATE &amp;quot;DATE&amp;quot;&lt;br /&gt;
#define SOCKET_ADDR &amp;quot;ipc:///tmp/survey.ipc&amp;quot;&lt;/p&gt;
&lt;p&gt;char *date(void)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; time_t raw = time (&amp;amp;raw);
struct tm *info = localtime (&amp;amp;raw);
char *text = asctime (info);
text[strlen(text)-1] = &#39;\0&#39;;
return text;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int server(const char *url)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int sock = nn_socket(AF_SP, NN_SURVEYOR);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, url) &amp;gt;= 0);
sleep(1); /* wait for connections */
/* Send */
printf(&amp;quot;SERVER: SENDING DATE SURVEY REQUEST\n&amp;quot;);
int sz_d = strlen(DATE) + 1;
int bytes = nn_send(sock, DATE, sz_d, 0);
assert (bytes == sz_d);
while (1) {
/* Receive */
char *buf = NULL;
bytes = nn_recv(sock, &amp;amp;buf, NN_MSG, 0);
if (bytes == ETIMEDOUT) {
break;
}
if (bytes &amp;gt;= 0) {
printf(&amp;quot;SERVER: RECEIVED \&amp;quot;%s\&amp;quot; SURVEY RESPONSE\n&amp;quot;, buf);
nn_freemsg (buf);
}
}
return nn_shutdown(sock, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int client(const char *url, const char *name)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int sock = nn_socket(AF_SP, NN_RESPONDENT);
assert(sock &amp;gt;= 0);
assert(nn_connect(sock, url) &amp;gt;= 0);
while (1) {
char *buf = NULL;
int bytes = nn_recv(sock, &amp;amp;buf, NN_MSG, 0);
if (bytes &amp;gt;= 0) {
printf(&amp;quot;CLIENT (%s): RECEIVED \&amp;quot;%s\&amp;quot; SURVEY REQUEST\n&amp;quot;, name, buf);
nn_freemsg(buf);
char *d = date();
int sz_d = strlen(d) + 1; // &#39;\0&#39; too
printf(&amp;quot;CLIENT (%s): SENDING DATE SURVEY RESPONSE\n&amp;quot;, name);
int bytes = nn_send (sock, d, sz_d, 0);
assert(bytes == sz_d);
}
}
return nn_shutdown(sock, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int argc, char **argv)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; if (argc == 2 &amp;amp;&amp;amp; strncmp(SERVER, argv[1], strlen(SERVER)) == 0) {
return server (SOCKET_ADDR);
} else if (argc == 3 &amp;amp;&amp;amp; strncmp(CLIENT, argv[1], strlen(CLIENT)) == 0) {
return client (SOCKET_ADDR, argv[2]);
} else {
fprintf(stderr, &amp;quot;Usage: survey %s|%s &amp;lt;ARG&amp;gt; ...\n&amp;quot;, SERVER, CLIENT);
return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5. [文件] bus.c ~ 3KB 下载(21)
```cpp
#include &amp;quot;common.h&amp;quot;
#include &amp;lt;nanomsg/bus.h&amp;gt;
#define NODE0_SOCKET_ADDR &amp;quot;ipc:///tmp/node0.ipc&amp;quot;
#define NODE1_SOCKET_ADDR &amp;quot;ipc:///tmp/node1.ipc&amp;quot;
#define NODE2_SOCKET_ADDR &amp;quot;ipc:///tmp/node2.ipc&amp;quot;
#define NODE3_SOCKET_ADDR &amp;quot;ipc:///tmp/node3.ipc&amp;quot;
int node0(void)
{
int sock = nn_socket(AF_SP, NN_BUS);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, NODE0_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
assert(nn_connect(sock, NODE1_SOCKET_ADDR) &amp;gt;= 0);
assert(nn_connect(sock, NODE2_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
return sock;
}
int node1(void)
{
int sock = nn_socket(AF_SP, NN_BUS);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, NODE1_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
assert(nn_connect(sock, NODE2_SOCKET_ADDR) &amp;gt;= 0);
assert(nn_connect(sock, NODE3_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
return sock;
}
int node2(void)
{
int sock = nn_socket(AF_SP, NN_BUS);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, NODE2_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
assert(nn_connect(sock, NODE3_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
return sock;
}
int node3(void)
{
int sock = nn_socket(AF_SP, NN_BUS);
assert(sock &amp;gt;= 0);
assert(nn_bind(sock, NODE3_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
assert(nn_connect(sock, NODE0_SOCKET_ADDR) &amp;gt;= 0);
sleep(1); /* wait for connections */
return sock;
}
int bus_on(int sock, const char *name)
{
int to = 100;
assert(nn_setsockopt(sock, NN_SOL_SOCKET, NN_RCVTIMEO, &amp;amp;to, sizeof(to)) &amp;gt;= 0);
/* SEND */
int sz_n = strlen(name) + 1;
printf(&amp;quot;%s: SENDING &#39;%s&#39; ONTO BUS\n&amp;quot;, name, name);
int send = nn_send(sock, name, sz_n, 0);
assert (send == sz_n);
while (1) {
/* RECV */
char *buf = NULL;
int recv = nn_recv(sock, &amp;amp;buf, NN_MSG, 0);
if (recv &amp;gt;= 0) {
printf(&amp;quot;%s: RECEIVED &#39;%s&#39; FROM BUS\n&amp;quot;, name, buf);
nn_freemsg(buf);
}
}
return nn_shutdown(sock, 0);
}
int node(const char *name)
{
int sock;
if (!strcmp(name, &amp;quot;node0&amp;quot;)) {
sock = node0();
} else if (!strcmp(name, &amp;quot;node1&amp;quot;)) {
sock = node1();
} else if (!strcmp(name, &amp;quot;node2&amp;quot;)) {
sock = node2();
} else if (!strcmp(name, &amp;quot;node3&amp;quot;)) {
sock = node3();
} else {
return -1;
}
return bus_on(sock, name);
}
int main(int argc, char **argv)
{
if (argc == 2) {
return node(argv[1]);
} else {
fprintf (stderr, &amp;quot;Usage: bus &amp;lt;NODE_NAME&amp;gt; ...\n&amp;quot;);
return 1;
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>hi3519a uboot emmc</title><link>/hardware/hisilicon/hi3519a-uboot-emmc/</link><pubDate>Fri, 22 May 2020 15:09:37 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3519a-uboot-emmc/</guid><description>
&lt;p&gt;1、重启按下ctrl+c进入boot界面下&lt;/p&gt;
&lt;p&gt;2、setenv ipaddr 192.168.0.10 (设备ip)&lt;br /&gt;
setenv serverip 192.168.0.92 (服务器ip，pc)&lt;/p&gt;
&lt;p&gt;3、启动tftpd32.exe， 在串口界面ping服务器IP是否联通 ping 192.168.0.92&lt;/p&gt;
&lt;p&gt;4、按照约定分区烧写&lt;br /&gt;
emmc烧录： (8G) 1M(u-boot.bin),9M(kernel),30M(rootfs.cramfs),100M(app),5M(param),5M(backup.param),6860M(data)&lt;br /&gt;
uboot 0x0 ~ 0xFFFFF size = 0x100000&lt;br /&gt;
kernel 0x100000 ~ 0x9FFFFF size = 0x400000&lt;br /&gt;
rootfs 0xA00000 ~ 0x27FFFFF size = 0x1E00000&lt;br /&gt;
app 0x2800000 ~ 0x8BFFFFF size = 0x6400000&lt;br /&gt;
param 0x8C00000 ~ 0x90FFFFF size = 0x500000&lt;br /&gt;
backparam 0x9100000 ~ 0x95FFFFF size = 0x500000&lt;br /&gt;
data 0x9600000 ~ 0x1B61FFFFF size = 0x1ACC00000&lt;/p&gt;
&lt;p&gt;mmc read dev addr blk# cnt&lt;br /&gt;
mmc write dev addr blk# cnt&lt;br /&gt;
mmc erase blk# cnt&lt;/p&gt;
&lt;p&gt;offset/0x200 = blk, size/0x200=cnt&lt;/p&gt;
&lt;p&gt;512 字节 = 0x200&lt;/p&gt;
&lt;p&gt;190M 0xBE00000 0x5F000&lt;/p&gt;
&lt;h4 id=&#34;boot烧录&#34;&gt;boot烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x100000; tftp 0x82000000 u-boot-hi3559av100.bin&lt;br /&gt;
mmc erase 0 800; mmc write 0 0x82000000 0 800&lt;/p&gt;
&lt;h4 id=&#34;uimage-内核烧录&#34;&gt;uImage 内核烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x900000;tftp 0x82000000 uImage_hi3559av100_multi-core&lt;br /&gt;
mmc erase 800 4800; mmc write 0 0x82000000 800 4800&lt;/p&gt;
&lt;p&gt;0x22000000&lt;br /&gt;
mmc erase 800 2000; mmc write 0 0x21000000 800 2000&lt;/p&gt;
&lt;h4 id=&#34;rootfs-烧录&#34;&gt;rootfs 烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x1E00000;tftp 0x82000000 rootfs_hi3559av100_T19021302.cramfs&lt;br /&gt;
mmc erase 5000 F000; mmc write 0 0x82000000 5000 F000&lt;/p&gt;
&lt;p&gt;mw.b 0x21000000 ff 0x5F000;tftp 0x21000000 hi3519a/rootfs.ext4&lt;br /&gt;
mmc erase 2800 0x5F000; mmc write 0 0x21000000 2800 0x5F000&lt;/p&gt;
&lt;h4 id=&#34;app-烧录&#34;&gt;app 烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x6400000;tftp 0x82000000 app-T17051502.img&lt;br /&gt;
mmc erase 14000 32000; mmc write 0 0x82000000 14000 32000&lt;/p&gt;
&lt;h4 id=&#34;param-烧录&#34;&gt;param 烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x500000;tftp 0x82000000 app-T17051502.img&lt;br /&gt;
mmc erase 46000 2800; mmc write 0 0x82000000 4600 2800&lt;/p&gt;
&lt;h4 id=&#34;backup-param-烧录&#34;&gt;backup param 烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x500000;tftp 0x82000000 app-T17051502.img&lt;br /&gt;
mmc erase 48800 2800; mmc write 0 0x82000000 48800 2800&lt;/p&gt;
&lt;h4 id=&#34;data-烧录&#34;&gt;data 烧录&lt;/h4&gt;
&lt;p&gt;mw.b 0x82000000 ff 0x1ACC00000;tftp 0x82000000 u-data-hi3521a.jffs2&lt;br /&gt;
mmc erase 4B000 D6600; mmc write 0 0x82000000 4B000 D6600&lt;/p&gt;
&lt;p&gt;5、reset设备&lt;/p&gt;
&lt;p&gt;1、首先生成所需文件系统，见本博客&lt;Hi3559AV100文件系统制作cramfs&gt;。&lt;/p&gt;
&lt;p&gt;2、使用工具生成EXT4文件系统&lt;/p&gt;
&lt;p&gt;       ./make_ext4fs -s -l 96M rootfs_hi3559av100.ext4 ./rootfs&lt;/p&gt;
&lt;p&gt;3、烧录文件系统&lt;/p&gt;
&lt;p&gt;      mw.b 0x82000000 ff 0x12C00000;tftp 0x82000000 STM_ROOTFS_T19022801&lt;br /&gt;
      mmc erase A800 96000; mmc write.ext4sp 0 0x82000000 A800 96000&lt;/p&gt;
&lt;p&gt;       注意：烧写EXT4文件系统时候必须用mmc write.ext4sp 而不是mmc write，否则会报找不到文件系统错误。&lt;/p&gt;
&lt;p&gt;      &lt;/p&gt;
&lt;p&gt;No filesystem could mount root, tried: ext4&lt;/p&gt;
&lt;p&gt;Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(179,3)&lt;br /&gt;
CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.9.37 #2&lt;br /&gt;
Hardware name: Hisilicon HI3559AV100 DEMO Board (DT)&lt;br /&gt;
Call trace:&lt;br /&gt;
[&lt;ffffff8008088de8&gt;] dump_backtrace+0x0/0x198&lt;br /&gt;
[&lt;ffffff800808908c&gt;] show_stack+0x14/0x20&lt;br /&gt;
[&lt;ffffff8008338424&gt;] dump_stack+0x94/0xb8&lt;br /&gt;
[&lt;ffffff800812c324&gt;] panic+0x114/0x264&lt;br /&gt;
[&lt;ffffff80088110d8&gt;] mount_block_root+0x29c/0x2b8&lt;br /&gt;
[&lt;ffffff8008811288&gt;] mount_root+0x74/0x84&lt;br /&gt;
[&lt;ffffff80088113fc&gt;] prepare_namespace+0x164/0x1a0&lt;br /&gt;
[&lt;ffffff8008810c78&gt;] kernel_init_freeable+0x1c0/0x1e0&lt;br /&gt;
[&lt;ffffff8008642068&gt;] kernel_init+0x10/0x100&lt;br /&gt;
[&lt;ffffff8008082ee0&gt;] ret_from_fork+0x10/0x30&lt;br /&gt;
Kernel Offset: disabled&lt;br /&gt;
Memory Limit: 512 MB&lt;br /&gt;
---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(179,3)&lt;br /&gt;
4、CONFIG_BOOTARGS配置如下&lt;/p&gt;
&lt;p&gt;Kernel command line: mem=512M console=ttyAMA0,115200 clk_ignore_unused rw rootwait root=/dev/mmcblk0p3            rootfstype=ext4blkdevparts=mmcblk0:1M(uboot.bin),20M(kernel),300M(rootfs.ext4),300M(app),10M(param),10M(backup.param),6000M(data)&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「Ronbin.L」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/xclshwd/article/details/88013064&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/xclshwd/article/details/88013064&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;0xDAC000&lt;/p&gt;</description></item><item><title>hi3516 linux spic</title><link>/hardware/hisilicon/hi3516-linux-spic/</link><pubDate>Wed, 20 May 2020 16:54:55 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3516-linux-spic/</guid><description>&lt;p&gt;SPI 读写命令示例&lt;br /&gt;
此操作示例通过 SPI 读写命令实现对 SPI 外围设备的读写操作。&lt;br /&gt;
在控制台使用 spi_read 命令对 SPI 外围设备进行读操作：&lt;br /&gt;
~ $ ssp_read &lt;spi_num&gt; &lt;csn&gt; &lt;dev_addr&gt; &lt;reg_addr&gt; [num_reg] [dev_width] [reg_width] [data_width]&lt;br /&gt;
其中[num_reg] 可以省略，缺省值是 1（表示读 1 个寄存器）。[dev_width] [reg_width] [data_width]可以省略，缺省值都是1（表示1Byte）。&lt;br /&gt;
例如读挂载在 SPI 控制器 0 片选 0 上设备地址为 0x2 的设备的 0x0 寄存器：&lt;br /&gt;
~ $ ssp_read 0x0 0x0 0x2 0x0 0x10 0x1 0x1 0x1&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;spi_num： SPI 控制器号（对应《 Hi3516A 专业型 HD IP Camera Soc 用户指南》中的 SPI 控制器0、 1）&lt;br /&gt;
csn：片选号（ Hi3516A 的 SPI 控制器 0 有 1 个片选、控制器 1 有 3 个片选）&lt;br /&gt;
dev_addr：外围设备地址&lt;br /&gt;
reg_addr：外围设备寄存器开始地址&lt;br /&gt;
num_reg：读外围设备寄存器个数&lt;br /&gt;
dev_width：外围设备地址位宽（支持 8 位）&lt;br /&gt;
reg_width：外围设备寄存器地址位宽（支持 8 位）&lt;br /&gt;
data_width：外围设备的数据位宽（支持 8 位）&lt;/p&gt;
&lt;p&gt;在控制台使用 spi_write 命令对 SPI 外围设备进行写操作：&lt;br /&gt;
~ $ ssp_write &lt;spi_num&gt; &lt;csn&gt; &lt;dev_addr&gt; &lt;reg_addr&gt; &lt;data&gt; [dev_width] [reg_width] [data_width]&lt;br /&gt;
其中[dev_width] [reg_width] [data_width]可以省略，缺省值都是 1（表示 1Byte）。&lt;br /&gt;
例如向挂载在 SPI 控制器 0 片选 0 上设备地址为 0x2 的设备的 0x0 寄存器写入数据 0x65：&lt;br /&gt;
~ $ ssp_write 0x0 0x0 0x2 0x0 0x65 0x1 0x1 0x1&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;spi_num： SPI 控制器序号（对应《 Hi3516A 专业型 HD IP Camera Soc 用户指南》中的 SPI 控制器 0、 1）&lt;br /&gt;
csn：片选号（ Hi3516A 的 SPI 控制器 0 有 1 个片选、控制器 1 有 3 个片选）&lt;br /&gt;
dev_addr：外围设备地址&lt;br /&gt;
reg_addr：外围设备寄存器地址&lt;br /&gt;
data：写外围设备寄存器的数据&lt;br /&gt;
dev_width：外围设备地址位宽（支持 8 位）&lt;br /&gt;
reg_width：外围设备寄存器地址位宽（支持 8 位）&lt;br /&gt;
data_width：外围设备的数据位宽（支持 8 位）&lt;br /&gt;
此 SPI 读写命令仅支持 sensor 的读写操作。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「聚优致成」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/qq_29350001/article/details/52680643&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/qq_29350001/article/details/52680643&lt;/a&gt;&lt;/p&gt;</description></item><item><title>clang mini xml</title><link>/language/clang/clang-mini-xml/</link><pubDate>Tue, 12 May 2020 16:39:52 CST</pubDate><author>rinetd</author><guid>/language/clang/clang-mini-xml/</guid><description>&lt;p&gt;昨天简单写了在VxWorks平台应用mini-XML库解析xml文件，以及怎样用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/jianzhao6205/article/details/81638197&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/jianzhao6205/article/details/81638197&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天将根据函数手册写一个例程，主要功能为：使用库函数生成一个xml树保存到user.xml文件，注意fopen()函数文件路径的写法（&amp;quot;host:d:\Tornado2.2\XML\user.xml&amp;quot;），对生成的文件进行解析并打印。很简单的一个小程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;sys/stat.h&amp;gt;
#include&amp;lt;sys/types.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;mxml.h&amp;gt;
int main()
{
//文件头
mxml_node_t *root=mxmlNewXML(&amp;quot;1.0&amp;quot;);
//根标签 china
mxml_node_t*china =mxmlNewElement(root,&amp;quot;china&amp;quot;);
//字标签 城市
mxml_node_t*city=mxmlNewElement(china,&amp;quot;city&amp;quot;);
mxml_node_t*info=mxmlNewElement(city,&amp;quot;name&amp;quot;);
//给标签赋值
mxmlNewText(info,0,&amp;quot;北京&amp;quot;);
mxmlElementSetAttr(info,&amp;quot;isbig&amp;quot;,&amp;quot;Yes&amp;quot;);
//面积
info=mxmlNewElement(city,&amp;quot;area&amp;quot;);
mxmlNewText(info,0,&amp;quot;16410平方公里&amp;quot;);
//人口
info=mxmlNewElement(city,&amp;quot;population&amp;quot;);
mxmlNewText(info,0,&amp;quot;2171万人&amp;quot;);
info=mxmlNewElement(city,&amp;quot;GDP&amp;quot;);
mxmlNewText(info,0,&amp;quot;21410亿&amp;quot;);
//东京
//字标签 城市
city=mxmlNewElement(china,&amp;quot;city&amp;quot;);
info=mxmlNewElement(city,&amp;quot;name&amp;quot;);
//给标签赋值
mxmlNewText(info,0,&amp;quot;东京&amp;quot;);
mxmlElementSetAttr(info,&amp;quot;isbig&amp;quot;,&amp;quot;Yes&amp;quot;);
//面积
info=mxmlNewElement(city,&amp;quot;area&amp;quot;);
mxmlNewText(info,0,&amp;quot;2188平方公里&amp;quot;);
//人口
info=mxmlNewElement(city,&amp;quot;population&amp;quot;);
mxmlNewText(info,0,&amp;quot;3670万人&amp;quot;);
info=mxmlNewElement(city,&amp;quot;GDP&amp;quot;);
mxmlNewText(info,0,&amp;quot;31700亿元&amp;quot;);
//数据保存到磁盘文件
FILE *fp=fopen(&amp;quot;china.xml&amp;quot;,&amp;quot;w&amp;quot;);
mxmlSaveFile(root,fp,MXML_NO_CALLBACK);
fclose(fp);
mxmlDelete(root);
//删除释放
//printf(&amp;quot;Hello world\n&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终生成的xml文件&lt;/p&gt;
&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「zzzcyj」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/jianzhao6205/article/details/81676068&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/jianzhao6205/article/details/81676068&lt;/a&gt;&lt;/p&gt;</description></item><item><title>计算Yolov3的anchors</title><link>/ai/yolo/yolo-anchors/</link><pubDate>Tue, 12 May 2020 15:06:24 CST</pubDate><author>rinetd</author><guid>/ai/yolo/yolo-anchors/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# coding=utf-8
# k-means ++ for YOLOv3 anchors
# 通过k-means ++ 算法获取YOLOv3需要的anchors的尺寸
import numpy as np
# 定义Box类，描述bounding box的坐标
class Box():
def __init__(self, x, y, w, h):
self.x = x
self.y = y
self.w = w
self.h = h
# 计算两个box在某个轴上的重叠部分
# x1是box1的中心在该轴上的坐标
# len1是box1在该轴上的长度
# x2是box2的中心在该轴上的坐标
# len2是box2在该轴上的长度
# 返回值是该轴上重叠的长度
def overlap(x1, len1, x2, len2):
len1_half = len1 / 2
len2_half = len2 / 2
left = max(x1 - len1_half, x2 - len2_half)
right = min(x1 + len1_half, x2 + len2_half)
return right - left
# 计算box a 和box b 的交集面积
# a和b都是Box类型实例
# 返回值area是box a 和box b 的交集面积
def box_intersection(a, b):
w = overlap(a.x, a.w, b.x, b.w)
h = overlap(a.y, a.h, b.y, b.h)
if w &amp;lt; 0 or h &amp;lt; 0:
return 0
area = w * h
return area
# 计算 box a 和 box b 的并集面积
# a和b都是Box类型实例
# 返回值u是box a 和box b 的并集面积
def box_union(a, b):
i = box_intersection(a, b)
u = a.w * a.h + b.w * b.h - i
return u
# 计算 box a 和 box b 的 iou
# a和b都是Box类型实例
# 返回值是box a 和box b 的iou
def box_iou(a, b):
return box_intersection(a, b) / box_union(a, b)
# 使用k-means ++ 初始化 centroids，减少随机初始化的centroids对最终结果的影响
# boxes是所有bounding boxes的Box对象列表
# n_anchors是k-means的k值
# 返回值centroids 是初始化的n_anchors个centroid
def init_centroids(boxes,n_anchors):
centroids = []
boxes_num = len(boxes)
centroid_index = np.random.choice(boxes_num, 1)
centroids.append(boxes[centroid_index])
print(centroids[0].w,centroids[0].h)
for centroid_index in range(0,n_anchors-1):
sum_distance = 0
distance_thresh = 0
distance_list = []
cur_sum = 0
for box in boxes:
min_distance = 1
for centroid_i, centroid in enumerate(centroids):
distance = (1 - box_iou(box, centroid))
if distance &amp;lt; min_distance:
min_distance = distance
sum_distance += min_distance
distance_list.append(min_distance)
distance_thresh = sum_distance*np.random.random()
for i in range(0,boxes_num):
cur_sum += distance_list[i]
if cur_sum &amp;gt; distance_thresh:
centroids.append(boxes[i])
print(boxes[i].w, boxes[i].h)
break
return centroids
# 进行 k-means 计算新的centroids
# boxes是所有bounding boxes的Box对象列表
# n_anchors是k-means的k值
# centroids是所有簇的中心
# 返回值new_centroids 是计算出的新簇中心
# 返回值groups是n_anchors个簇包含的boxes的列表
# 返回值loss是所有box距离所属的最近的centroid的距离的和
def do_kmeans(n_anchors, boxes, centroids):
loss = 0
groups = []
new_centroids = []
for i in range(n_anchors):
groups.append([])
new_centroids.append(Box(0, 0, 0, 0))
for box in boxes:
min_distance = 1
group_index = 0
for centroid_index, centroid in enumerate(centroids):
distance = (1 - box_iou(box, centroid))
if distance &amp;lt; min_distance:
min_distance = distance
group_index = centroid_index
groups[group_index].append(box)
loss += min_distance
new_centroids[group_index].w += box.w
new_centroids[group_index].h += box.h
for i in range(n_anchors):
new_centroids[i].w /= len(groups[i])
new_centroids[i].h /= len(groups[i])
return new_centroids, groups, loss
# 计算给定bounding boxes的n_anchors数量的centroids
# label_path是训练集列表文件地址
# n_anchors 是anchors的数量
# loss_convergence是允许的loss的最小变化值
# grid_size * grid_size 是栅格数量
# iterations_num是最大迭代次数
# plus = 1时启用k means ++ 初始化centroids
def compute_centroids(label_path,n_anchors,loss_convergence,grid_size,iterations_num,plus):
boxes = []
label_files = []
f = open(label_path)
for line in f:
#label_path = line.rstrip().replace(&#39;images&#39;, &#39;labels&#39;)
#label_path = label_path.replace(&#39;JPEGImages&#39;, &#39;labels&#39;)
#label_path = label_path.replace(&#39;.jpg&#39;, &#39;.txt&#39;)
#label_path = label_path.replace(&#39;.JPEG&#39;, &#39;.txt&#39;)
#label_files.append(label_path)
label_files.append(line.rstrip())
f.close()
for label_file in label_files:
f = open(label_file)
for line in f:
temp = line.strip().split(&amp;quot; &amp;quot;)
if len(temp) &amp;gt; 1:
boxes.append(Box(0, 0, float(temp[3]), float(temp[4])))
if plus:
centroids = init_centroids(boxes, n_anchors)
else:
centroid_indices = np.random.choice(len(boxes), n_anchors)
centroids = []
for centroid_index in centroid_indices:
centroids.append(boxes[centroid_index])
# iterate k-means
centroids, groups, old_loss = do_kmeans(n_anchors, boxes, centroids)
iterations = 1
while (True):
centroids, groups, loss = do_kmeans(n_anchors, boxes, centroids)
iterations = iterations + 1
print(&amp;quot;loss = %f&amp;quot; % loss)
if abs(old_loss - loss) &amp;lt; loss_convergence or iterations &amp;gt; iterations_num:
break
old_loss = loss
for centroid in centroids:
print(centroid.w * grid_size * 32, centroid.h * grid_size * 32)
# print result
for centroid in centroids:
print(&amp;quot;k-means result：\n&amp;quot;)
print(centroid.w * grid_size * 32, centroid.h * grid_size * 32)
label_path = &amp;quot;train_txt.txt&amp;quot;
n_anchors = 9
loss_convergence = 1e-6
grid_size = 13
iterations_num = 1000
plus = 0
compute_centroids(label_path,n_anchors,loss_convergence,grid_size,iterations_num,plus)
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Hi3516DV300移植exfat-nofuse</title><link>/hardware/hisilicon/hi3516dv300-extfs/</link><pubDate>Sat, 09 May 2020 11:01:47 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3516dv300-extfs/</guid><description>&lt;p&gt;Hi3516DV300移植exfat-nofuse&lt;/p&gt;
&lt;p&gt;1.源码&lt;br /&gt;
&lt;a href=&#34;https://github.com/dorimanx/exfat-nofuse&#34; target=&#34;_blank&#34;&gt;https://github.com/dorimanx/exfat-nofuse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.编译&lt;br /&gt;
修改makefile&lt;/p&gt;
&lt;p&gt;KDIR := /home/xxx/Hi3516CV500_SDK_V2.0.1.1/osdrv/opensource/kernel/linux-4.9.y&lt;/p&gt;
&lt;p&gt;make ARCH=arm CROSS_COMPILE=arm-himix200-linux-&lt;br /&gt;
生成exfat.ko&lt;/p&gt;
&lt;p&gt;3.使用&lt;br /&gt;
insmod exfat.ko&lt;/p&gt;
&lt;p&gt;mount -t exfat $dev $dir&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「Ronbin.L」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/xclshwd/article/details/105927887&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/xclshwd/article/details/105927887&lt;/a&gt;&lt;/p&gt;</description></item><item><title>clang jpeg</title><link>/language/clang/clang-jpeg/</link><pubDate>Thu, 30 Apr 2020 16:53:39 CST</pubDate><author>rinetd</author><guid>/language/clang/clang-jpeg/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/*
这是read_picture.c 文件的代码 ，主要是对输入的图片的文件（BMP和JPEG类型）进行解码，转换成在LCD中显示的数据；
使用该程序时，要先把jpeglib库文件和头文件放到对应的标谁库和标准头文件中；否则编译出错的
*/
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;linux/fb.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;quot;jpeglib.h&amp;quot;
#include &amp;lt;setjmp.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
unsigned char *read_bmp(char *filename);
unsigned char *read_jpeg(char *path);
//14byte文件头
typedef struct
{
char cfType[2]; //文件类型，&amp;quot;BM&amp;quot;(0x4D42)
long cfSize; //文件大小（字节）
long cfReserved; //保留，值为0
long cfoffBits; //数据区相对于文件头的偏移量（字节）
} __attribute__((packed)) BITMAPFILEHEADER;
//__attribute__((packed))的作用是告诉编译器取消结构在编译过程中的优化对齐
//40byte信息头
typedef struct
{
char ciSize[4]; //BITMAPFILEHEADER所占的字节数
long ciWidth; //宽度
long ciHeight; //高度
char ciPlanes[2]; //目标设备的位平面数，值为1
int ciBitCount; //每个像素的位数
char ciCompress[4]; //压缩说明
char ciSizeImage[4]; //用字节表示的图像大小，该数据必须是4的倍数
char ciXPelsPerMeter[4]; //目标设备的水平像素数/米
char ciYPelsPerMeter[4]; //目标设备的垂直像素数/米
char ciClrUsed[4]; //位图使用调色板的颜色数
char ciClrImportant[4]; //指定重要的颜色数，当该域的值等于颜色数时（或者等于0时），表示所有颜色都一样重要
} __attribute__((packed)) BITMAPINFOHEADER;
typedef struct
{
unsigned char blue;
unsigned char green;
unsigned char red;
//unsigned char reserved;
} __attribute__((packed)) PIXEL; //颜色模式RGB
BITMAPFILEHEADER FileHead;
BITMAPINFOHEADER InfoHead;
int width_bmp;
int height_bmp;
/*
第1 个参数: 图片所在的路径名
第2 个参数: 没有任何作用,先将他设置为空
返回值: 返回一个指向堆的指针,是解码后的图片数据
*/
int read_picture_type(char *pic_name) //根据文析名得到图片的类型
{
char *pic_tail;
int name_len = strlen(pic_name);
pic_tail = pic_name + name_len - 1;
while (pic_name != pic_tail)
{
if (*pic_tail == &#39;.&#39;)
{
if (strcmp(pic_tail, &amp;quot;.bmp&amp;quot;) == 0 || strcmp(pic_tail, &amp;quot;.BMP&amp;quot;) == 0)
{
return 2;
}
if (strcmp(pic_tail, &amp;quot;.jpg&amp;quot;) == 0 || strcmp(pic_tail, &amp;quot;.JPG&amp;quot;) == 0)
{
return 1;
}
}
pic_tail--;
}
printf(&amp;quot;This is not bmp or jpg file\n&amp;quot;);
return 0;
}
/*
参数1 pic_name： 是要解码图片的路径
返回值：是返回一个指向解码后数据指针
*/
unsigned char *read_picture(char *pic_name) //根据图片的类型，调用对应的解码函数进行解码，返回一个指向解码后数据的指针
{
int pic_type = read_picture_type(pic_name);
switch (pic_type) //根据图片类型不同，调用不同函数来解码
{
case 0:
  printf(&amp;quot;picture file ERR\n\n&amp;quot;);
return NULL;
break;
case 1: //如果是JPEG图片
return read_jpeg(pic_name);
break;
case 2: //如果是BMP图片
return read_bmp(pic_name);
break;
}
return NULL;
}
/*
参数1：是BMP图片的路径
返回一个指向堆分配空间指针，存放图片解码后的数据
*/
unsigned char *read_bmp(char *filename) //BMP类型图片的解码，
{
FILE *fp;
int rc;
int line_x, line_y;
long int location = 0, BytesPerLine1 = 0, BytesPerLine2 = 0;
unsigned char *image;
fp = fopen(filename, &amp;quot;rb&amp;quot;);
if (fp == NULL)
{
printf(&amp;quot;openerr\n&amp;quot;);
return (NULL);
}
rc = fread(&amp;amp;FileHead, sizeof(BITMAPFILEHEADER), 1, fp); //读取文件头
if (rc != 1)
{
printf(&amp;quot;read header error!\n&amp;quot;);
fclose(fp);
return (NULL);
}
//检测是否是bmp图像
if (memcmp(FileHead.cfType, &amp;quot;BM&amp;quot;, 2) != 0)
{
printf(&amp;quot;it&#39;s not a BMP file\n&amp;quot;);
fclose(fp);
return (NULL);
}
rc = fread((char *)&amp;amp;InfoHead, sizeof(BITMAPINFOHEADER), 1, fp); //读取信息头
if (rc != 1)
{
printf(&amp;quot;read infoheader error!\n&amp;quot;);
fclose(fp);
return (NULL);
}
//跳转的数据区  FileHead.cfoffBits是始止位距数据区的偏移量
fseek(fp, FileHead.cfoffBits, SEEK_SET);
//每行字节数   InfoHead，是BMP文件的信息头  ciBitCount对应图片的位深度
BytesPerLine1 = ((InfoHead.ciWidth * 16) / 32) * 4; //生成后的，16的偏移量，
BytesPerLine2 = (InfoHead.ciWidth * InfoHead.ciBitCount + 31) / 32 * 4; //图片本身一行数据的偏移量 
//printf(&amp;quot;BytesPerLine==%d\n&amp;quot;,BytesPerLine);
//printf(&amp;quot;ciWidth==%d\n&amp;quot;,InfoHead.ciWidth);
//printf(&amp;quot;ciHeight==%d\n&amp;quot;,InfoHead.ciHeight);
width_bmp = InfoHead.ciWidth;
height_bmp = InfoHead.ciHeight;
image = (unsigned char *)malloc(width_bmp * height_bmp * 2);
if (InfoHead.ciWidth % 2 != 0)
width_bmp = InfoHead.ciWidth - 1;
line_x = line_y = 0;
unsigned short short_buf;
PIXEL pix;
while (!feof(fp))
{
rc = fread((char *)&amp;amp;pix, 1, sizeof(PIXEL), fp); //读一个像素点，放到pix这个结构体中
if (rc != sizeof(PIXEL))
break;
location = line_x * 16 / 8 + (InfoHead.ciHeight - line_y - 1) * BytesPerLine1;
//显示每一个像素
short_buf = (((pix.red &amp;amp; 0xf8) &amp;gt;&amp;gt; 3) &amp;lt;&amp;lt; 11) | (((pix.green &amp;amp; 0xfc) &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 5) | ((pix.blue &amp;amp; 0xf8) &amp;gt;&amp;gt; 3);
//上面一个像素点已经变成16位的了，所以分成两个8位的，写入到数组中
*(image + location + 0) = (char)(short_buf &amp;amp; 0xff);
*(image + location + 1) = (char)((short_buf &amp;amp; 0xff00) &amp;gt;&amp;gt; 8);
line_x++; //当前是那个像素点，bits_per_pixel/8是每个像素占多少位字节
if (line_x == InfoHead.ciWidth)
{
line_x = 0; //对应一行中的那个像素
line_y++; //对应那一行
fseek(fp, BytesPerLine2 * line_y + FileHead.cfoffBits, SEEK_SET); //重定位，偏移量指针
if (line_y == InfoHead.ciHeight)
break;
}
}
fclose(fp);
return (image);
}
unsigned char *jpeg_info(char *path,)
{
struct jpeg_decompress_struct cinfo;
struct jpeg_error_mgr jerr;
FILE *infile;
int row_stride;
unsigned char *buffer;
// 分配和初始化一个decompression结构体
cinfo.err = jpeg_std_error(&amp;amp;jerr);
jpeg_create_decompress(&amp;amp;cinfo);
// 指定源文件
if ((infile = fopen(path, &amp;quot;rb&amp;quot;)) == NULL)
{
fprintf(stderr, &amp;quot;can&#39;t open %s\n&amp;quot;, path);
return NULL;
}
jpeg_stdio_src(&amp;amp;cinfo, infile);
// 用jpeg_read_header获得jpg信息
jpeg_read_header(&amp;amp;cinfo, TRUE);
/* 源信息 */
#if 0
printf(&amp;quot;image_width = %d\n&amp;quot;, cinfo.image_width);
printf(&amp;quot;image_height = %d\n&amp;quot;, cinfo.image_height);
printf(&amp;quot;num_components = %d\n&amp;quot;, cinfo.num_components);
// 设置解压参数,比如放大、缩小
printf(&amp;quot;enter scale M/N:\n&amp;quot;);
//anf(&amp;quot;%d/%d&amp;quot;, &amp;amp;cinfo.scale_num, &amp;amp;cinfo.scale_denom);
printf(&amp;quot;scale to : %d/%d\n&amp;quot;, cinfo.scale_num, cinfo.scale_denom);
#endif
width_bmp = cinfo.output_width;
height_bmp = cinfo.output_height;
}
/*
这是jpeg图片的解码
参数1：是jpeg图片的路径
返回 ：返回一个解码后的数据
*/
unsigned char *read_jpeg(char *path)
{
struct jpeg_decompress_struct cinfo;
struct jpeg_error_mgr jerr;
FILE *infile;
int row_stride;
unsigned char *buffer;
// 分配和初始化一个decompression结构体
cinfo.err = jpeg_std_error(&amp;amp;jerr);
jpeg_create_decompress(&amp;amp;cinfo);
// 指定源文件
if ((infile = fopen(path, &amp;quot;rb&amp;quot;)) == NULL)
{
fprintf(stderr, &amp;quot;can&#39;t open %s\n&amp;quot;, path);
return NULL;
}
jpeg_stdio_src(&amp;amp;cinfo, infile);
// 用jpeg_read_header获得jpg信息
jpeg_read_header(&amp;amp;cinfo, TRUE);
/* 源信息 */
#if 0
printf(&amp;quot;image_width = %d\n&amp;quot;, cinfo.image_width);
printf(&amp;quot;image_height = %d\n&amp;quot;, cinfo.image_height);
printf(&amp;quot;num_components = %d\n&amp;quot;, cinfo.num_components);
// 设置解压参数,比如放大、缩小
printf(&amp;quot;enter scale M/N:\n&amp;quot;);
//anf(&amp;quot;%d/%d&amp;quot;, &amp;amp;cinfo.scale_num, &amp;amp;cinfo.scale_denom);
printf(&amp;quot;scale to : %d/%d\n&amp;quot;, cinfo.scale_num, cinfo.scale_denom);
#endif
// 启动解压：jpeg_start_decompress
jpeg_start_decompress(&amp;amp;cinfo);
#if 0
/* 输出的图象的信息 */
printf(&amp;quot;output_width = %d\n&amp;quot;, cinfo.output_width);
printf(&amp;quot;output_height = %d\n&amp;quot;, cinfo.output_height);
printf(&amp;quot;output_components = %d\n&amp;quot;, cinfo.output_components);
#endif
width_bmp = cinfo.output_width;
height_bmp = cinfo.output_height;
// 一行的数据长度
row_stride = cinfo.output_width * cinfo.output_components;
buffer = malloc(row_stride);
unsigned char *image = (unsigned char *)malloc(cinfo.output_width * cinfo.output_height * 2); //一个颜色点16位两个字节
unsigned short short_buf;
int curr_y = 0;
int curr_x = 0;
int jpeg_x = 0;
int location;
// 循环调用jpeg_read_scanlines来一行一行地获得解压的数据
while (cinfo.output_scanline &amp;lt; cinfo.output_height)
 
{
location = curr_x * 2 + cinfo.output_width * 2 * curr_y;
(void)jpeg_read_scanlines(&amp;amp;cinfo, &amp;amp;buffer, 1);
while (curr_x &amp;lt; cinfo.output_width)
{
short_buf = (((*(buffer + jpeg_x) &amp;amp; 0xf8) &amp;gt;&amp;gt; 3) &amp;lt;&amp;lt; 11) | (((*(buffer + jpeg_x + 1) &amp;amp; 0xfc) &amp;gt;&amp;gt; 2) &amp;lt;&amp;lt; 5) | ((*(buffer + jpeg_x + 2) &amp;amp; 0xf8) &amp;gt;&amp;gt; 3);
*(image + location + 0) = (char)(short_buf &amp;amp; 0xff);
*(image + location + 1) = (char)((short_buf &amp;amp; 0xff00) &amp;gt;&amp;gt; 8);
jpeg_x = jpeg_x + 3;
curr_x++; //当前是那个像素点，bits_per_pixel/8是每个像素占多少位字节
location = curr_x * 2 + cinfo.output_width * 2 * curr_y;
}
curr_y++;
curr_x = 0;
jpeg_x = 0;
}
free(buffer);
jpeg_finish_decompress(&amp;amp;cinfo);
jpeg_destroy_decompress(&amp;amp;cinfo);
return image;
}
//这是主函数，图片的输入路径由main函数的第一个参数决定
int main(char argv, char **argc)
{
if (argv != 2)
{
printf(&amp;quot;input fine err!\nplease input pic file\n&amp;quot;);
return 0;
}
/* 初始化framebuffer */
initFramebuffer();
printf(&amp;quot;file:%s\n&amp;quot;, argc[1]);
unsigned char *image = read_picture(argc[1]);
write_buf_image(image, 0, 0, width_bmp, height_bmp); /*往framebuffer里面写数据，显示到LCD上面去*/
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「YANGSENG1987」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/YANGSENG1987/article/details/9770663&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/YANGSENG1987/article/details/9770663&lt;/a&gt;&lt;/p&gt;</description></item><item><title>shell readdir</title><link>/linux/shell/shell-readdir/</link><pubDate>Thu, 30 Apr 2020 10:39:02 CST</pubDate><author>rinetd</author><guid>/linux/shell/shell-readdir/</guid><description>
&lt;h3 id=&#34;截取文件扩展名&#34;&gt;截取文件扩展名&lt;/h3&gt;
&lt;p&gt;$ fullfile=/the/path/mylib.1.0.1a.zip&lt;br /&gt;
$ fullname=&amp;quot;${fullfile##&lt;em&gt;/}&amp;quot;&lt;br /&gt;
$ dir=&amp;quot;${fullfile%/&lt;/em&gt;}&amp;quot;&lt;br /&gt;
$ extension=&amp;quot;${fullname##&lt;em&gt;.}&amp;quot;&lt;br /&gt;
$ filename=&amp;quot;${fullname%.&lt;/em&gt;}&amp;quot;&lt;br /&gt;
$ echo $dir , $fullname , $filename , $extension&lt;br /&gt;
/the/path , mylib.1.0.1a.zip , mylib.1.0.1a , zip&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
src=&amp;quot;./Private&amp;quot;
#源文件的父目录
dst=&amp;quot;./timeLine3&amp;quot;
#目标目录
function read_dir(){
for file in `ls $1`;do #step1 遍历文件
echo &amp;quot;判断 &amp;quot; $file &amp;quot;文件类型中...&amp;quot;
if [ -d $1&amp;quot;/&amp;quot;$file ];then
echo $file &amp;quot;是目录，处理目录中的文件&amp;quot;
read_dir $1&amp;quot;/&amp;quot;$file $2
elif [ -f $1&amp;quot;/&amp;quot;$file ];then #step2 复制文件到目标目录
echo &amp;quot;复制&amp;quot; $file &amp;quot;到&amp;quot; $2
[[ `cp -f -v -p $1&amp;quot;/&amp;quot;$file $2` ]]
else echo &amp;quot;..&amp;quot;
fi
done
}
read_dir $src $dst
#递归查找src中的文件，复制到dst中 (暂不能处理重名文件)
echo &amp;quot;复制完毕&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;oss-sh&#34;&gt;oss.sh&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
# 接收参数
bucket=videos-buket
dest=$(date +%Y%m%d)
src=$(date +%Y%m%d)
ext=mp4
type=video
while getopts &amp;quot;:b:d:e:s:t:&amp;quot; optname
do
case &amp;quot;$optname&amp;quot; in
b) bucket=$OPTARG ;;
d) dest=$OPTARG ;;
e) ext=$OPTARG ;;
s) src=$OPTARG ;;
t) type=$OPTARG ;;
*) echo &amp;quot;usage: $0 [-b] [-d] [-e] [-t]&amp;quot; ;;
esac
done
# 遍历文件
for file in $(ls &amp;quot;$src&amp;quot; | grep &amp;quot;\.$ext&amp;quot;) ; do
# 计算文件名
name=&amp;quot;$(echo -n &amp;quot;${file//.$ext/}&amp;quot; | md5sum | cut -d &amp;quot; &amp;quot; -f1)&amp;quot;
# 计算文件大小
size=&amp;quot;$(wc -c &amp;quot;$src/$file&amp;quot; | sed &amp;quot;s/^ *//&amp;quot; | sed &amp;quot;s/\([0-9]*\) .*/\1/&amp;quot;)&amp;quot;
# 上传文件
echo &amp;quot;src_name = $file, size = $size, &amp;quot;dest_name = &amp;quot;$dest&amp;quot;/v2_&amp;quot;$name&amp;quot;_&amp;quot;$type&amp;quot;_&amp;quot;$ext&amp;quot; &amp;gt;&amp;gt; &amp;quot;$src&amp;quot;/result.log
ossutil cp -u -f &amp;quot;$src/$file&amp;quot; oss://&amp;quot;$bucket&amp;quot;/&amp;quot;$dest&amp;quot;/v2_&amp;quot;$name&amp;quot;_&amp;quot;$type&amp;quot;_&amp;quot;$ext&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>