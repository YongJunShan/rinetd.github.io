<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时光小栈 on 时光小栈</title><link>/</link><language>zh-CN</language><author>rinetd</author><rights>Copyright (c) 2015, rinetd; all rights reserved.</rights><updated>Thu, 16 Jul 2020 15:55:04 CST</updated><item><title>hi3519a linux kernel mmc</title><link>/hardware/hisilicon/hi3519a/hi3519a-linux-kernel-mmc/</link><pubDate>Thu, 16 Jul 2020 15:55:04 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3519a/hi3519a-linux-kernel-mmc/</guid><description>
&lt;p&gt;linux-4.9.y-smp/drivers/mmc/host/sdhci-hisi.c&lt;/p&gt;
&lt;h3 id=&#34;sdcard-硬件参数&#34;&gt;SDcard 硬件参数&lt;/h3&gt;
&lt;p&gt;GPIO10_0 0x045FA400&lt;/p&gt;
&lt;p&gt;himm 0x047E0064 0x00001000 31:15 保留。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 14 保留。
13 保留。
12 输入使能，高有效。
11 施密特输入使能，高有效。
10 保留。
9 下拉电阻使能，高有效。
8 上拉电阻使能，高有效。
7:4 驱动能力，0~15对应SD IO档位1~档位16。
3:0 &amp;quot;功能选择：
0:GPIO10_0
1:SDIO0_CARD_POWER_EN
4:VOU1120_DATA12
7:LCD_DATA13&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;himm 0x047E0064 0x00000201&lt;/p&gt;
&lt;p&gt;0x047E0068 0x00001000 31:15 保留。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 14 保留。
13 保留。
12 输入使能，高有效。
11 施密特输入使能，高有效。
10 保留。
9 下拉电阻使能，高有效。
8 上拉电阻使能，高有效。
7:4 驱动能力，0~15对应SD IO档位1~档位16。
3:0 &amp;quot;功能选择：
0:GPIO10_1
1:SDIO0_CARD_DETECT
4:VOU1120_DATA9
7:LCD_DATA16&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;himm 0x047E0068 0x00001901&lt;/p&gt;</description></item><item><title>c语言位操作黑科技bithacker</title><link>/language/clang/c-bithacker/</link><pubDate>Thu, 16 Jul 2020 10:53:15 CST</pubDate><author>rinetd</author><guid>/language/clang/c-bithacker/</guid><description>&lt;p&gt;&lt;a href=&#34;http://graphics.stanford.edu/~seander/bithacks.html&#34; target=&#34;_blank&#34;&gt;http://graphics.stanford.edu/~seander/bithacks.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1 检测两个数是否异号:&lt;/p&gt;
&lt;p&gt;    int x,y;&lt;/p&gt;
&lt;p&gt;   bool f= ((x^ y) &amp;lt;0);&lt;/p&gt;
&lt;p&gt;2 取最大/小值&lt;/p&gt;
&lt;p&gt;int x;  // we want to find the minimum of x and y&lt;br /&gt;
int y;   &lt;br /&gt;
int r;  // the result goes here &lt;/p&gt;
&lt;p&gt;r = y ^ ((x ^ y) &amp;amp; -(x &amp;lt; y)); // min(x, y)&lt;br /&gt;
r = x ^ ((x ^ y) &amp;amp; -(x &amp;lt; y)); // max(x, y)&lt;/p&gt;
&lt;p&gt;文章中给出了解释：&lt;/p&gt;
&lt;p&gt;以min为例，如果x&amp;lt;y，那么-（x&amp;lt;y）为全1，r = y ^ (x ^ y) &amp;amp; ~0 = y ^ x ^ y = x&lt;/p&gt;
&lt;p&gt;如果x&amp;gt;=y 那么，-（x&amp;lt;y）为全0，r = y ^ ((x ^ y) &amp;amp; 0) = y&lt;/p&gt;
&lt;p&gt;3计算一个数的2进制右边连续0的个数。&lt;/p&gt;
&lt;p&gt;之前看android源码时总能看到一种奇怪的代码：a&amp;amp;-a，不明白是什么意思，这里刚好在这也有，索性仔细研究下：&lt;/p&gt;
&lt;p&gt;我打印出了100多个数字的结果（从1开始，0没有啥意义），结果发现一个奇怪的规律：每16个一组会呈现出如下的结果：&lt;/p&gt;
&lt;p&gt;1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 256&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 512&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 256&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 1024&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 256&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 128&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 64&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 32&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 16&lt;br /&gt;
1 2 1 4 1 2 1 8 1 2 1 4 1 2 1 512&lt;/p&gt;
&lt;p&gt;看到了吧，前15个都一模一样，最后那个数子不同，如果单看最后一个数字的话，会发现每8个一组，前7个都一样，最后不同，然后观察那最后一个数：规律是：&lt;/p&gt;
&lt;p&gt;128 256 128 512 128 256 128  1024&lt;/p&gt;
&lt;p&gt;128 256 128 512 128 256 128  2048&lt;/p&gt;
&lt;p&gt;128 256 128 512 128 256 128  1024&lt;/p&gt;
&lt;p&gt;128 256 128 512 128 256 128  4096&lt;/p&gt;
&lt;p&gt;然后再看最后一列数：&lt;/p&gt;
&lt;p&gt;1024 2048 1024 4096 1024 2048 1204 8192&lt;/p&gt;
&lt;p&gt;1024 2048 1024 4096 1024 2048 1024 16384&lt;/p&gt;
&lt;p&gt;看到了吧，依然是8个为一组，可以猜想，最后那列数还会是8个一组。别说这个还真有意思&lt;/p&gt;
&lt;p&gt;好了回归正题，v &amp;amp; -v 的作用就是取出右起连续的 0 以及首次出现的 1 。&lt;/p&gt;
&lt;p&gt;然后看代码：&lt;/p&gt;
&lt;p&gt;unsigned int v; // 32-bit word input to count zero bits on right&lt;br /&gt;
unsigned int c = 32; // c will be the number of zero bits on the right&lt;br /&gt;
v &amp;amp;= -signed(v);&lt;br /&gt;
if (v) c--;&lt;br /&gt;
if (v &amp;amp; 0x0000FFFF) c -= 16;&lt;br /&gt;
if (v &amp;amp; 0x00FF00FF) c -= 8;&lt;br /&gt;
if (v &amp;amp; 0x0F0F0F0F) c -= 4;&lt;br /&gt;
if (v &amp;amp; 0x33333333) c -= 2;&lt;br /&gt;
if (v &amp;amp; 0x55555555) c -= 1;&lt;br /&gt;
我们把v末尾首次出现1的数成为num，即v&amp;amp;-v；&lt;br /&gt;
第一个if，如果num不为0，那么至多有31个0，&lt;/p&gt;
&lt;p&gt;第2个if，判断后2个字节，如果不为0，那么前2个字节也就没意义了，所以减去16&lt;/p&gt;
&lt;p&gt;第3个if，判断最后一个字节，如果不为0，那么倒数第2个字节也没有意义，所以减去8，这里要注意，前后是对称的，因为每一个if都是减半的判断，很有可能第一个if就不执行，因此，在判断后边字节的时候一定要把前边的对称上。&lt;/p&gt;
&lt;p&gt;最后两个if就是一半一半的判断最后一个字节，就不用再解释了。&lt;/p&gt;</description></item><item><title>clang linux kfifo ringbuffer</title><link>/language/clang/clang-linux-kfifo-ringbuffer/</link><pubDate>Wed, 15 Jul 2020 19:06:10 CST</pubDate><author>rinetd</author><guid>/language/clang/clang-linux-kfifo-ringbuffer/</guid><description>
&lt;p&gt;git@github.com:dennis-musk/ringbuffer.git&lt;br /&gt;
Description: 环形缓冲区的实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Others: 1.min的妙用，(验证剩余有效空间和要求要读出或者写入空间 取最小值)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2.利用unsigned int 的回环,in 和 out一直在加，加到0xffffffff则归为0，任然满足计算偏移等。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3.分为2部进行copy，一为当前偏移到size-1 二为剩余部分0到(len减去一中的个数)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4.unsiged int下的(in - out)始终为in和out之间的距离，(in溢出后in:0x1 - out:0xffffffff = 2任然满足)(缓冲区中未脏的数据).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;5.计算偏移(in) &amp;amp; (size - 1) &amp;lt;==&amp;gt; in%size&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环形缓冲区经常被使用到,尤其在生产者和消费者的模型中,假设生产者专门用于产生数据,而消费者专门用于处理数据,由于各种原因,可能生产者和消费者产生数据和处理数据的速度不一,比如如果处理速度有慢又快,在慢的时候,消费者产生的数据来不及处理的可能被丢弃,或者强制让生产者降速等待,在快的时候,又有可能太快,而生产者供给不了,那么消费者也必须等待.正是由于快慢不一,缓冲区的存在则恰可以进行中和,协调生产者和消费者速度不一的问题.&lt;/p&gt;
&lt;h3 id=&#34;一-内核kfifo&#34;&gt;一.内核kfifo&lt;/h3&gt;
&lt;p&gt;首先学习一下linux内核是如何设计环形缓冲区的,毕竟内核代码精炼之至,令人叹为观止.&lt;br /&gt;
这里是linux2.6.27的代码&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;1.kfifo的结构类型&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kfifo {
unsigned char *buffer; /* the buffer holding the data */
unsigned int size; /* the size of the allocated buffer */
unsigned int in; /* data is added at offset (in % size) */
unsigned int out; /* data is extracted from off. (out % size) */
spinlock_t *lock; /* protects concurrent modifications */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里发现我们用in out描述put get操作fifo的位置,用的是unsigned int类型,后面如果我们想获得in实际在fifo的位置,用in&amp;amp;(size-1),这就是size下面要采用用2的乘方的原因.&lt;br /&gt;
而牵涉到in,out一起计算的时候,不需要进行&amp;amp;运算获取实际位置,即使有溢出问题也是满足的,可以使用补码进行验算,最后都是看成无符号的数.&lt;br /&gt;
在in out增加和减少,会自己溢出回归.&lt;br /&gt;
2.kfifo_init&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size,
gfp_t gfp_mask, spinlock_t *lock)
{
struct kfifo *fifo;
/* size must be a power of 2 */
BUG_ON(!is_power_of_2(size));
fifo = kmalloc(sizeof(struct kfifo), gfp_mask);
if (!fifo)
return ERR_PTR(-ENOMEM);
fifo-&amp;gt;buffer = buffer;
fifo-&amp;gt;size = size;
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
fifo-&amp;gt;lock = lock;
return fifo;
}
bool is_power_of_2(unsigned long n)
{
return (n != 0 &amp;amp;&amp;amp; ((n &amp;amp; (n - 1)) == 0));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申请分配一个kfifo的结构体指针,初始化buffer使用的是函数外部的空间,in,out为0,size其中必须为2的乘方,意义为下面size-1方便进行与运算.&lt;/p&gt;
&lt;p&gt;3.kfifo_alloc&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct kfifo *kfifo_alloc(unsigned int size, gfp_t gfp_mask, spinlock_t *lock)
{
unsigned char *buffer;
struct kfifo *ret;
/*
* round up to the next power of 2, since our &#39;let the indices
* wrap&#39; tachnique works only in this case.
*/
if (size &amp;amp; (size - 1)) {
BUG_ON(size &amp;gt; 0x80000000);
size = roundup_pow_of_two(size);
}
buffer = kmalloc(size, gfp_mask);
if (!buffer)
return ERR_PTR(-ENOMEM);
ret = kfifo_init(buffer, size, gfp_mask, lock);
if (IS_ERR(ret))
kfree(buffer);
return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数主要就是申请size的buffer空间,然后调用kfifo_init初始化.&lt;br /&gt;
4.kfifo_free&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void kfifo_free(struct kfifo *fifo)
{
kfree(fifo-&amp;gt;buffer);
kfree(fifo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个函数和kfifo_alloc配合使用,用于释放内存,先释放buffer,再释放结构体指针fifo.&lt;br /&gt;
5.kfifo_reset&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline void __kfifo_reset(struct kfifo *fifo)
{
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
}
static inline void kfifo_reset(struct kfifo *fifo)
{
unsigned long flags;
spin_lock_irqsave(fifo-&amp;gt;lock, flags);
__kfifo_reset(fifo);
spin_unlock_irqrestore(fifo-&amp;gt;lock, flags);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重置in out位置为0&lt;br /&gt;
6.kfifo_len&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline unsigned int __kfifo_len(struct kfifo *fifo)
{
return fifo-&amp;gt;in - fifo-&amp;gt;out;
}
static inline unsigned int kfifo_len(struct kfifo *fifo)
{
unsigned long flags;
unsigned int ret;
spin_lock_irqsave(fifo-&amp;gt;lock, flags);
ret = __kfifo_len(fifo);
spin_unlock_irqrestore(fifo-&amp;gt;lock, flags);
return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到fifo中数据的长度,用&lt;code&gt;fifo-&amp;gt;in - fifo-&amp;gt;out&lt;/code&gt;是没有问题的,即便在unsigned int型溢出时也是对的,具体可以使用补码进行运算.&lt;br /&gt;
7.kfifo_put&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int __kfifo_put(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
//put进去的字节数不能大于fifo剩余的字节数
len = min(len, fifo-&amp;gt;size - fifo-&amp;gt;in + fifo-&amp;gt;out);
smp_mb();
/*fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)通过这个与运算,相当于把
fifo-&amp;gt;in是size的倍数给去掉了,得到的是在size里的位
置,就是在这个buffer的位置.
而l所表示的是要put进去的字节数和从in开始到buffer
结尾字节数的小值,就是从in到buffer结尾能不能放下
目的字节数*/
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)));
/*如果放不下,copy分两部分,一部分从in在位置复制l字
节数.一部分从buffer开始复制len-l字节数,如果放得
下,那len-l为0,一样可以*/
memcpy(fifo-&amp;gt;buffer + (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)), buffer, l);
memcpy(fifo-&amp;gt;buffer, buffer + l, len - l);
smp_wmb();
//更新in所在位置
fifo-&amp;gt;in += len;
return len;
}
static inline unsigned int kfifo_put(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned long flags;
unsigned int ret;
spin_lock_irqsave(fifo-&amp;gt;lock, flags);
ret = __kfifo_put(fifo, buffer, len);
spin_unlock_irqrestore(fifo-&amp;gt;lock, flags);
return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.kfifo_get&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int __kfifo_get(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
//get的字节数和fifo buffer中字节数比较,len为最终要get的字节数
len = min(len, fifo-&amp;gt;in - fifo-&amp;gt;out);
smp_rmb();
//要get的字节数,和out所在位置到fifo buffer结尾字节数,比较
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)));
//和put同理,两部分,一部分copy l字节数,一部分copy len-l字节数,注意方向
memcpy(buffer, fifo-&amp;gt;buffer + (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)), l);
memcpy(buffer + l, fifo-&amp;gt;buffer, len - l);
smp_mb();
//更新out位置
fifo-&amp;gt;out += len;
return len;
}
static inline unsigned int kfifo_get(struct kfifo *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned long flags;
unsigned int ret;
spin_lock_irqsave(fifo-&amp;gt;lock, flags);
ret = __kfifo_get(fifo, buffer, len);
//如果没有数据,重置
if (fifo-&amp;gt;in == fifo-&amp;gt;out)
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
spin_unlock_irqrestore(fifo-&amp;gt;lock, flags)
//返回get的字节数
return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二-仿造kfifo-编写的环形缓冲区ring-c-ring-h&#34;&gt;二.仿造kfifo,编写的环形缓冲区ring.c ring.h&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*ring.h*/
#ifndef RING_H
#define RING_H
#include &amp;lt;pthread.h&amp;gt;
struct ring{
unsigned char *buffer; /* the buffer holding the data */
unsigned int size; /* the size of the allocated buffer */
unsigned int in; /* data is added at offset (in % size) */
unsigned int out; /* data is extracted from off. (out % size) */
pthread_mutex_t *lock; /* protects concurrent modifications */
};
extern struct ring *ring_init(unsigned char *buffer, unsigned int size,pthread_mutex_t *lock);
extern struct ring *ring_alloc(unsigned int size,pthread_mutex_t *lock);
extern void ring_free(struct ring *fifo);
extern unsigned int __ring_put(struct ring *fifo,
unsigned char *buffer, unsigned int len);
extern unsigned int __ring_get(struct ring *fifo,
unsigned char *buffer, unsigned int len);
static inline void __ring_reset(struct ring *fifo)
{
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
}
static inline void ring_reset(struct ring *fifo)
{
unsigned long flags;
pthread_mutex_lock(fifo-&amp;gt;lock);
__ring_reset(fifo);
pthread_mutex_unlock(fifo-&amp;gt;lock);
}
static inline unsigned int __ring_len(struct ring *fifo)
{
return fifo-&amp;gt;in - fifo-&amp;gt;out;
}
static inline unsigned int ring_len(struct ring *fifo)
{
unsigned int ret;
pthread_mutex_lock(fifo-&amp;gt;lock);
ret = __ring_len(fifo);
pthread_mutex_unlock(fifo-&amp;gt;lock);
return ret;
}
static inline unsigned int ring_put(struct ring *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int ret;
pthread_mutex_lock(fifo-&amp;gt;lock);
ret = __ring_put(fifo, buffer, len);
pthread_mutex_unlock(fifo-&amp;gt;lock);
return ret;
}
static inline unsigned int ring_get(struct ring *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int ret;
pthread_mutex_lock(fifo-&amp;gt;lock);
ret = __ring_get(fifo, buffer, len);
if (fifo-&amp;gt;in == fifo-&amp;gt;out)
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
pthread_mutex_unlock(fifo-&amp;gt;lock);
return ret;
}
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*ring.c*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;quot;ring.h&amp;quot;
#define is_power_of_2(x) ((x) != 0 &amp;amp;&amp;amp; (((x) &amp;amp; ((x) - 1)) == 0))
#define min(x,y) ({ \
typeof(x) _x = (x); \
typeof(y) _y = (y); \
(void) (&amp;amp;_x == &amp;amp;_y); \
_x &amp;lt; _y ? _x : _y; })
struct ring *ring_init(unsigned char *buffer, unsigned int size,
pthread_mutex_t *lock)
{
struct ring *fifo = NULL;
if(!is_power_of_2(size)){
printf(&amp;quot;size is not power of 2\n&amp;quot;);
return fifo;
}
fifo = (struct ring *)malloc(sizeof(struct ring));
if (!fifo){
printf(&amp;quot;fifo malloc error\n&amp;quot;);
return fifo;
}
fifo-&amp;gt;buffer = buffer;
fifo-&amp;gt;size = size;
fifo-&amp;gt;in = fifo-&amp;gt;out = 0;
fifo-&amp;gt;lock = lock;
return fifo;
}
struct ring *ring_alloc(unsigned int size,pthread_mutex_t *lock)
{
unsigned char *buffer = NULL;
struct ring *ret = NULL;
buffer = (unsigned char *)malloc(size);
if (!buffer){
printf(&amp;quot;buffer malloc error\n&amp;quot;);
return ret;
}
ret = ring_init(buffer, size, lock);
return ret;
}
void ring_free(struct ring *fifo)
{
free(fifo-&amp;gt;buffer);
free(fifo);
}
unsigned int __ring_put(struct ring *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
len = min(len, fifo-&amp;gt;size - fifo-&amp;gt;in + fifo-&amp;gt;out);
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)));
memcpy(fifo-&amp;gt;buffer + (fifo-&amp;gt;in &amp;amp; (fifo-&amp;gt;size - 1)), buffer, l);
memcpy(fifo-&amp;gt;buffer, buffer + l, len - l);
fifo-&amp;gt;in += len;
return len;
}
unsigned int __ring_get(struct ring *fifo,
unsigned char *buffer, unsigned int len)
{
unsigned int l;
len = min(len, fifo-&amp;gt;in - fifo-&amp;gt;out);
l = min(len, fifo-&amp;gt;size - (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)));
memcpy(buffer, fifo-&amp;gt;buffer + (fifo-&amp;gt;out &amp;amp; (fifo-&amp;gt;size - 1)), l);
memcpy(buffer + l, fifo-&amp;gt;buffer, len - l);
fifo-&amp;gt;out += len;
return len;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;三-测试&#34;&gt;三.测试&lt;/h3&gt;
&lt;p&gt;测试的main.c文件如下:&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*main.c*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;quot;ring.h&amp;quot;
struct data{
int a;
time_t t;
};
pthread_t tid1;
pthread_t tid2;
void sig_handler(int sig)
{
if(sig == SIGINT){
if(pthread_cancel(tid1) != 0){
perror(&amp;quot;thread cancel fail&amp;quot;);
exit(0);
}
if(pthread_cancel(tid2) != 0){
perror(&amp;quot;thread cancel fail&amp;quot;);
exit(0);
}
printf(&amp;quot;\n\n 两个线程取消\n&amp;quot;);
}
}
void * put_proc(void * arg)
{
signal(SIGINT, sig_handler);
if(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL) != 0){
perror(&amp;quot;pthread set cancel state fail&amp;quot;);
pthread_exit(NULL);
exit(0);
}
if(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL) != 0){
perror(&amp;quot;pthread set cancel type fail&amp;quot;);
pthread_exit(NULL);
exit(0);
}
int i = 0;
struct data data_put;
struct ring * ring_buf = (struct ring *)arg;
int len = sizeof(struct data);
int ret;
while(1){
data_put.a = i;
time(&amp;amp;data_put.t);
ret = ring_put(ring_buf,(unsigned char *)&amp;amp;data_put,len);
printf(&amp;quot;ret put:%d\nput data:%d\ntime:%s\n\n&amp;quot;,ret,data_put.a,ctime(&amp;amp;data_put.t));
i++;
sleep(2);
}
}
void * get_proc(void * arg)
{
signal(SIGINT, sig_handler);
if(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL) != 0){
perror(&amp;quot;pthread set cancel state fail&amp;quot;);
pthread_exit(NULL);
exit(0);
}
if(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL) != 0){
perror(&amp;quot;pthread set cancel type fail&amp;quot;);
pthread_exit(NULL);
exit(0);
}
struct ring * ring_buf = (struct ring *)arg;
int len = sizeof(struct data);
struct data data_get;
int ret;
while(1){
ret = ring_get(ring_buf,(unsigned char *)&amp;amp;data_get,len);
printf(&amp;quot;ret get:%d\nget data:%d\ntime:%s\n\n&amp;quot;,ret,data_get.a,ctime(&amp;amp;data_get.t));
sleep(2);
}
}
int main(int argc, char const *argv[])
{
signal(SIGINT, sig_handler);
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
struct ring * ring_buf = NULL;
ring_buf = ring_alloc(32,&amp;amp;lock);
int err;
err = pthread_create(&amp;amp;tid1, NULL, put_proc, ring_buf);
if(err){
printf(&amp;quot;fail create thread 1\n&amp;quot;);
goto end;
}
err = pthread_create(&amp;amp;tid2, NULL, get_proc, ring_buf);
if(err){
printf(&amp;quot;fail create thread 2\n&amp;quot;);
goto end;
}
pthread_join(tid1,NULL);
pthread_join(tid2,NULL);
printf(&amp;quot;program end\n&amp;quot;);
end:
ring_free(ring_buf);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中,建立了两个线程,一个用于向ring_buf写数据,一个用于向ring_buf读数据,数据定义时加上了时间信息便于查看.互斥量的使用主要用于线程同步,比如两个线程如果都向缓冲区写数据时,必须保证临界区的安全,当然也可以使用读写锁,其实更好一些,因为读的时候,也可以写.&lt;br /&gt;
信号处理函数,用于ctrl+c强制结束时,异步取消线程.&lt;/p&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;p&gt;&lt;button class=&#34;VJbwyy&#34; type=&#34;button&#34; aria-label=&#34;复制代码&#34;&gt;&lt;i aria-label=&#34;icon: copy&#34; class=&#34;anticon anticon-copy&#34;&gt;&lt;svg viewBox=&#34;64 64 896 896&#34; focusable=&#34;false&#34; class=&#34;&#34; data-icon=&#34;copy&#34; width=&#34;1em&#34; height=&#34;1em&#34; fill=&#34;currentColor&#34; aria-hidden=&#34;true&#34;&gt;&lt;path d=&#34;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/i&gt;&lt;/button&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ret get:0
get data:1032341248
time:Sun Apr 21 12:30:00 4461252
ret put:16
put data:0
time:Mon Jan 8 17:35:33 2018
ret get:16
get data:0
time:Mon Jan 8 17:35:33 2018
ret put:16
put data:1
time:Mon Jan 8 17:35:35 2018
ret get:16
get data:1
time:Mon Jan 8 17:35:35 2018
ret put:16
put data:2
time:Mon Jan 8 17:35:37 2018
ret get:16
get data:2
time:Mon Jan 8 17:35:37 2018
ret put:16
put data:3
time:Mon Jan 8 17:35:39 2018
ret get:16
get data:3
time:Mon Jan 8 17:35:39 2018
ret put:16
put data:4
time:Mon Jan 8 17:35:41 2018
^C
两个线程取消
program end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刚开始,get线程没有读出数据&lt;br /&gt;
后面就是put一个,get一个,没问题.&lt;/p&gt;</description></item><item><title>hezhou i2c</title><link>/hardware/hezhou-i2c-am2320/</link><pubDate>Mon, 13 Jul 2020 10:08:16 CST</pubDate><author>rinetd</author><guid>/hardware/hezhou-i2c-am2320/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require &amp;quot;utils&amp;quot;
require &amp;quot;log&amp;quot;
module(..., package.seeall)
local float = rtos.get_version():upper():find(&amp;quot;FLOAT&amp;quot;)
--初始化并打开I2C
local function i2c_open(id)
if i2c.setup(id, i2c.SLOW) ~= i2c.SLOW then
i2c.close(id)
return i2c.setup(id, i2c.SLOW)
end
return i2c.SLOW
end
function TH(id, addr)
id, addr = id or 2, addr or 0x5c
if not i2c_open(id) then return
end
i2c.send(id, addr, 0x03)
i2c.send(id, addr, {0x03, 0x00, 0x04})
local data = i2c.recv(id, addr, 8)
if data == nil or data == 0 then return
end
log.info(&amp;quot;TH HEX data: &amp;quot;, data:toHex())
i2c.close(id)
local _, crc = pack.unpack(data, &#39;&amp;lt;H&#39;, 7)
data = data:sub(1, 6)
if crc == crypto.crc16_modbus(data, 6) then
local _, hum, tmp = pack.unpack(string.sub(data, 3, -1), &#39;&amp;gt;H2&#39;)
if tem == nil or hum == nil then return 0, 0
end
if tem &amp;gt;= 0x8000 then tmp = 0x8000 - tmp
end
if float then
tmp, hum = tmp / 10, hum / 10
else
tmp = tmp / 10 .. &amp;quot;.&amp;quot; .. tmp % 10
hum = hum / 10 .. &amp;quot;.&amp;quot; .. hum % 10
end
log.info(&amp;quot;温度湿度为： &amp;quot;, tmp, hum)
return tmp, hum
end
end
function sht(id, addr)
local _, tmp, hum
id, addr = id or 2, addr or 0x40
if not i2c_open(id) then return
end
i2c.send(id, addr, 0xE3)
tmp = i2c.recv(id, addr, 2)
i2c.send(id, addr, 0xE5)
hum = i2c.recv(id, addr, 2)
i2c.close(id)
_, tmp = pack.unpack(tmp, &#39;&amp;gt;H&#39;)
_, hum = pack.unpack(hum, &#39;&amp;gt;H&#39;)
if tmp == nil or hum == nil then
return 0, 0
end
tmp = bit.band(tmp, 0xFFFC)
hum = bit.band(hum, 0xFFFC)
if float then
hum = (hum * 12500 / 65536 - 600) / 100
tmp = (tmp * 17572 / 65536 - 4685) / 100
else
tmp = tmp * 17572 / 65536 - 4685
hum = hum * 12500 / 65536 - 600
tmp = tmp / 100 .. &amp;quot;.&amp;quot; .. tmp % 100
hum = hum / 100 .. &amp;quot;.&amp;quot; .. hum % 100
end
log.info(&amp;quot;当前温度是：&amp;quot;, tmp, &amp;quot;当前湿度是：&amp;quot;, hum .. &amp;quot;%&amp;quot;)
return tmp, hum
end
sys.timerLoopStart(TH, 5000)
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>hi3519a iomux</title><link>/hardware/hisilicon/hi3519a-iomux/</link><pubDate>Fri, 10 Jul 2020 08:46:55 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3519a-iomux/</guid><description>
&lt;p&gt;0x000~0x3FC GPIO_DATA GPIO 数据寄存器&lt;br /&gt;
0x400 GPIO_DIR GPIO 方向控制寄存器&lt;br /&gt;
0x404 GPIO_IS GPIO 中断触发寄存器&lt;br /&gt;
0x408 GPIO_IBE&lt;br /&gt;
0x40C GPIO_IEV&lt;br /&gt;
0x410 GPIO_IE&lt;br /&gt;
0x414 GPIO_RIS&lt;br /&gt;
0x418 GPIO_MIS&lt;br /&gt;
0x41C GPIO_IC&lt;/p&gt;
&lt;p&gt;GPIO 双沿触发中断寄存器 GPIO 触发中断条件寄存器 GPIO 中断屏蔽寄存器 GPIO 原始中断状态寄存器 GPIO 屏蔽状态中断寄存器 GPIO 中断清除寄存器&lt;br /&gt;
13-148 13-148 13-149 13-149 13-149 13-149 13-150 13-150 13-150&lt;/p&gt;
&lt;h3 id=&#34;sdcard&#34;&gt;SDcard&lt;/h3&gt;
&lt;p&gt;GPIO10_0 0x045FA400&lt;/p&gt;
&lt;p&gt;himm 0x047E0064 0x00001000 31:15 保留。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 14 保留。
13 保留。
12 输入使能，高有效。
11 施密特输入使能，高有效。
10 保留。
9 下拉电阻使能，高有效。
8 上拉电阻使能，高有效。
7:4 驱动能力，0~15对应SD IO档位1~档位16。
3:0 &amp;quot;功能选择：
0:GPIO10_0
1:SDIO0_CARD_POWER_EN
4:VOU1120_DATA12
7:LCD_DATA13&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;himm 0x047E0064 0x00000201&lt;/p&gt;
&lt;p&gt;0x047E0068 0x00001000 31:15 保留。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 14 保留。
13 保留。
12 输入使能，高有效。
11 施密特输入使能，高有效。
10 保留。
9 下拉电阻使能，高有效。
8 上拉电阻使能，高有效。
7:4 驱动能力，0~15对应SD IO档位1~档位16。
3:0 &amp;quot;功能选择：
0:GPIO10_1
1:SDIO0_CARD_DETECT
4:VOU1120_DATA9
7:LCD_DATA16&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;himm 0x047E0068 0x00001901&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo 20 &amp;gt; /proc/sys/net/ipv4/igmp_max_memberships
route add default gw 192.168.1.1
cd /usr/ko
./load3519av100 -i -sensor0 imx334 -sensor1 imx334 -sensor2 imx334 -sensor3 imx334 -sensor4 imx334
sleep 1
#ir-cut GPIO1_0 GPIO1_2
#himm 0x04058000 0x00001000
#himm 0x04058008 0x00001000
#himm 0x045F1400 0x5
#himm 0x045F1014 0x4
#GPIO1_6.........5v............
himm 0x04058074 0x00001000
himm 0x045F1400 0x40
himm 0x045F1100 0x40
sleep 1
31:15 保留。
14 强上拉使能。高有效。
13 保留。
12 输入使能，高有效。 1
11 施密特输入使能，高有效。
10 电平转换速率控制，为0时电平转换速率快，为1时电平转换速率慢。 1
9 下拉电阻使能，高有效。 1
8 上拉电阻使能，高有效。
7:4 驱动能力，0~15对应RGMII IO档位1~档位16。
3:0 &amp;quot;功能选择：
0:GPIO0_2
1:UART3_RTSN
2:UART6_RXD
3:LCD_DATA2
4:VOU1120_DATA5
5:VOU656_DATA2&amp;quot;
#ec20 4g
#GPIO0_2(............) PD
himm 0x047E0008 0x00001600
himm 0x045F0400 0x4
himm 0x045F0010 0x4
sleep 1
#GPIO2_3(......)
himm 0x0405803C 0x00001400
himm 0x045F2400 0x8
himm 0x045F2020 0x8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gpio-dir-0x0400&#34;&gt;GPIO_DIR 0x0400&lt;/h2&gt;
&lt;h2 id=&#34;gpio-data-offset-address-0x000-0x3fc-total-reset-value-0x00&#34;&gt;GPIO_DATA Offset Address: 0x000~0x3FC Total Reset Value: 0x00&lt;/h2&gt;
&lt;p&gt;当 GPIO_DIR 相应的比特配置为输入时，有效读取的结果将返回管脚的值;当配置为 输出的时候，有效读取的结果将返回写入的值。&lt;br /&gt;
GPIO_DATA 寄存器利用 PADDR[9:2]实现了读写寄存器比特的屏蔽操作。该寄存器对 应 256 个地址空间。PADDR[9:2]分别对应 GPIO_DATA[7:0]，当相应的 bit 为高时，则 可以对相应的位进行读写操作;反之，若对应 bit 为低则不能进行操作。例如:&lt;br /&gt;
 若地址为 0x3FC(0b11_1111_1100)，则对 GPIO_DATA[7:0]这 8bit 操作全部有 效。&lt;br /&gt;
 若地址为 0x200(0b10_0000_0000)，则仅对 GPIO_DATA[7]的操作有效。&lt;/p&gt;</description></item><item><title>hi3519a 移植gbd</title><link>/hardware/hisilicon/hi3519a-transport-gdb/</link><pubDate>Wed, 08 Jul 2020 15:54:17 CST</pubDate><author>rinetd</author><guid>/hardware/hisilicon/hi3519a-transport-gdb/</guid><description>&lt;ol&gt;
&lt;li&gt;下载源码&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编译环境&lt;/p&gt;
&lt;p&gt;一、&lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/&#34; target=&#34;_blank&#34;&gt;下载GDB压缩包 gdb-8.3.tar.gz&lt;/a&gt;&lt;br /&gt;
aria2c -x 16 -c &lt;a href=&#34;http://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz&#34; target=&#34;_blank&#34;&gt;http://ftp.gnu.org/gnu/gdb/gdb-9.2.tar.xz&lt;/a&gt;&lt;br /&gt;
tar -xf gdb-9.2.tar.xz&lt;/p&gt;
&lt;p&gt;二、解压压缩包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;tar xvf gdb-8.3.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、配置编译器&lt;/p&gt;
&lt;p&gt;进入到GDB的文件目录，然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-language-bash&#34;&gt;./configure --host=arm-himix200-linux --program-prefix=arm-hisi- --prefix=`pwd`/output
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四、修改文件&lt;/p&gt;
&lt;p&gt;由于海思提供的交叉编译工具的版本比较旧，在编译的时候回出现一些错误&lt;/p&gt;
&lt;p&gt;     1、dwarf-index-write.c的错误&lt;/p&gt;
&lt;p&gt;CXX dwarf-index-write.o&lt;br /&gt;
dwarf-index-write.c: In member function &#39;void debug_names::build()&#39;:&lt;br /&gt;
dwarf-index-write.c:704:32: error: &#39;log2&#39; is not a member of &#39;std&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; (std::pow (2, std::ceil (std::log2 (name_count * 4 / 3))));
^~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dwarf-index-write.c:704:32: note: suggested alternative:&lt;br /&gt;
In file included from /opt/toolchain/arm-himix100-linux/target/usr/include/features.h:416:0,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; from /opt/toolchain/arm-himix100-linux/target/usr/include/stdio.h:28,
from build-gnulib/import/stdio.h:43,
from common/common-defs.h:76,
from defs.h:28,
from dwarf-index-write.c:20:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/opt/toolchain/arm-himix100-linux/target/usr/include/bits/mathcalls.h:158:1: note: &#39;log2&#39;&lt;br /&gt;
__MATHCALL (log2,, (&lt;em&gt;Mdouble&lt;/em&gt; __x))&lt;br /&gt;
^&lt;br /&gt;
make[2]: *** [dwarf-index-write.o] Error 1&lt;br /&gt;
make[2]: Leaving directory &lt;code&gt;/opt/hisi-linux/GDB/gdb-8.3/gdb&#39;
make[1]: *** [all-gdb] Error 2
make[1]: Leaving directory&lt;/code&gt;/opt/hisi-linux/GDB/gdb-8.3&#39;&lt;br /&gt;
make: *** [all] Error 2&lt;br /&gt;
   解决方法：使用log函数替换log2方法&lt;/p&gt;
&lt;p&gt;将dwarf-index-write.c&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m_bucket_table.resize
(std::pow (2, std::ceil (std::log2 (name_count * 4 / 3))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用log函数替换log2方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;m_bucket_table.resize
(std::pow (2, std::ceil (std::log(name_count * 4 / 3) / std::log((float)2.0))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;  &lt;/p&gt;
&lt;p&gt;   2、undefined reference to `_obstack_free&#39; 错误&lt;/p&gt;
&lt;p&gt;   解决方法：使用宏定义使用_obstack_free函数替换obstack_free&lt;/p&gt;
&lt;p&gt;在obstack.h中增加定义&lt;br /&gt;
#ifndef obstack_free&lt;br /&gt;
#define _obstack_free obstack_free&lt;br /&gt;
#endif&lt;/p&gt;
&lt;p&gt;五、编译、安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;六、生成编译文件&lt;/p&gt;
&lt;p&gt;在GDB的目录下会有一个Output目录，下面就是我们编译出来的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190902111125376.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>STM8L151G6U6 之实现低功耗</title><link>/hardware/stm8/stm-rtc/</link><pubDate>Tue, 30 Jun 2020 15:18:52 CST</pubDate><author>rinetd</author><guid>/hardware/stm8/stm-rtc/</guid><description>&lt;p&gt;STM8L051F3P6&lt;/p&gt;
&lt;p&gt;STM8L151G6U6 之实现低功耗&lt;br /&gt;
所谓低功耗产品，一般来讲就是在大多数时间让MCU进入睡眠模式，在有数据更新时唤醒，将数据显示或者发送上报。对于中断类型的，可以采用中断直接唤醒MCU的方式，而对于温湿度之类的传感器，只能采用定时唤醒，然后采样并比较判断当前的值是否发送变化，然后显示或者上报。&lt;/p&gt;
&lt;p&gt;如果使用了显示屏，WiFi、蓝牙等模块，则需要在睡眠时将其断电。硬件上需要升压电路，否则有些外设在低电压时驱不起来。&lt;/p&gt;
&lt;p&gt;STM8L本身在halt模式下消耗电流为350nA，在active-halt with RTC模式下为1.3uA。&lt;/p&gt;
&lt;p&gt;最先的版本测试电流达到了1mA以上，草，赶紧折腾了一下，发现在进低功耗之前需要将相关的ADC、TIMER等关闭，此时达到了70uA左右，折腾，发现部分使用到的IO口需要根据硬件进行相关的配置，这样可以达到20uA左右，再折腾，发现没有连到电路的IO设置为输出低电平，又可以降低，这次是2.4uA，，，再折腾，发现PWR_UltraLowPowerCmd(ENABLE);需要开启，这次到了0.4uA。好了&lt;/p&gt;
&lt;p&gt;M8L151G6U6，该MCU是STM8L超低功耗系列，与152系列相比只是少了LCD的功能，官方手册介绍的各个低功耗模式的功耗如下：&lt;/p&gt;
&lt;p&gt;其低功耗性能还是很不错的，在本文中是基于活跃停机低功耗模式来测试的。&lt;/p&gt;
&lt;p&gt;要实现STM8L151G6的低功耗，主要可以注意以下几点：&lt;/p&gt;
&lt;p&gt;不需要用到的外设一律不使能外设时钟，对于临时使用的外设，只需在使用时临时打开即可，使用完毕关闭时钟&lt;br /&gt;
2.合理配置GPIO口的状态，对于没有使用到的GPIO，可将其设为上拉输出低，GPIO_Init(GPIOF, GPIO_Pin_0, GPIO_Mode_Out_PP_Low_Slow)；对于使用到的GPIO口，则要看你外电路的接法，如用一个GPIO低电平来控制LED亮灯，则要实现低功耗时，需把GPIO口置高；另一种情况是对于使用到的中断管脚，将该管脚上拉时，当发生中断电路接地时，该电阻则形成回路，有一定的消耗电流，可选用较大的电阻做外部上拉电阻，则大大减低电流。&lt;/p&gt;
&lt;p&gt;最重要的一点，由于STM8L151G6有电源管理部分，故必须在进入睡眠之前使能低功耗模式，具体库函数为：&lt;br /&gt;
PWR_UltraLowPowerCmd(ENABLE);&lt;/p&gt;
&lt;p&gt;STM8L系列的MCU数据手册表明工作电压可低到1.65V，当要实现这个功能是有要求的，必须勾选选项字节中的BOR_ON Brownout reset OFF，不启用BOR，这个可以在烧录软件中选择，这个在参考手册中有下面的描述&lt;br /&gt;
In low density devices, medium density devices and in the medium+ and high density&lt;br /&gt;
devices operating from 1.8V to 3.6V (device part numbers without “D” suffix), the BOR starts&lt;br /&gt;
to work above the POR threshold (see Section 6.3: Brownout reset (BOR) on page 66). To&lt;br /&gt;
ensure the minimum operating voltage (1.65 V), the BOR should be configured to BOR&lt;br /&gt;
Level 0.&lt;/p&gt;
&lt;p&gt;我根据上述几点，对自己的项目进行测试，使用活跃停机模式，RTC 30s自动唤醒，最后测试的休眠电流能做到4.7uA。&lt;/p&gt;
&lt;p&gt;RTC唤醒休眠后 要清除唤醒标志。&lt;br /&gt;
————————————————&lt;br /&gt;
版权声明：本文为CSDN博主「star871016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br /&gt;
原文链接：&lt;a href=&#34;https://blog.csdn.net/star871016/article/details/106782521/&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/star871016/article/details/106782521/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Linux网络编程--epoll模型ET触发模式之epolloneshot事件</title><link>/language/clang/socket/linux-socket-epolloneshot/</link><pubDate>Wed, 24 Jun 2020 10:16:16 CST</pubDate><author>rinetd</author><guid>/language/clang/socket/linux-socket-epolloneshot/</guid><description>&lt;p&gt;Linux网络编程--epoll模型ET触发模式之epolloneshot事件&lt;br /&gt;
epoll模型的ET模式一般来说只触发一次，然而在并发程序中有特殊情况的存在，譬如当epoll_wait已经检测到socket描述符fd1，并通知应用程序处理fd1的数据，那么处理过程中该fd1又有新的数据可读，会唤醒其他线程对fd1进行操作，那么就出现了两个工作线程同时处理fd1的情况，这当然不是我们期望看到的。&lt;/p&gt;
&lt;p&gt;那么下面我们就介绍epolloneshot事件，此规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符。当然处理完之后线程要重置这个epolloneshot事件，进而当此描述符有事件可读时让其他进程可以处理此描述符。&lt;/p&gt;
&lt;p&gt;下面就此epolloneshot事件编写一段测试代码：&lt;/p&gt;
&lt;p&gt;客户端程序可以参见上篇博文的客户端程序（无序改动）：&lt;a href=&#34;http://blog.csdn.net/hnlyyk/article/details/50946194&#34; target=&#34;_blank&#34;&gt;http://blog.csdn.net/hnlyyk/article/details/50946194&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务端程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#define MAX_EVENT_NUMBER 1024
#define BUFFER_SIZE 1024
struct fds
{
int epollfd;
int sockfd;
};
int setnonblocking( int fd )
{
int old_option = fcntl( fd, F_GETFL );
int new_option = old_option | O_NONBLOCK;
fcntl( fd, F_SETFL, new_option );
return old_option;
}
void addfd( int epollfd, int fd, bool oneshot )
{
epoll_event event;
event.data.fd = fd;
event.events = EPOLLIN | EPOLLET;
if( oneshot )
{
event.events |= EPOLLONESHOT;
}
epoll_ctl( epollfd, EPOLL_CTL_ADD, fd, &amp;amp;event );
setnonblocking( fd );
}
void reset_oneshot( int epollfd, int fd )
{
epoll_event event;
event.data.fd = fd;
event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;
epoll_ctl( epollfd, EPOLL_CTL_MOD, fd, &amp;amp;event );
}
void* worker( void* arg )
{
int sockfd = ( (fds*)arg )-&amp;gt;sockfd;
int epollfd = ( (fds*)arg )-&amp;gt;epollfd;
printf( &amp;quot;start new thread to receive data on fd: %d\n&amp;quot;, sockfd );
char buf[ BUFFER_SIZE ];
memset( buf, &#39;\0&#39;, BUFFER_SIZE );
while( 1 )
{
int ret = recv( sockfd, buf, BUFFER_SIZE-1, 0 );
if( ret == 0 )
{
close( sockfd );
printf( &amp;quot;foreiner closed the connection\n&amp;quot; );
break;
}
else if( ret &amp;lt; 0 )
{
if( errno == EAGAIN )
{
reset_oneshot( epollfd, sockfd );
printf( &amp;quot;read later\n&amp;quot; );
break;
}
}
else
{
printf( &amp;quot;get content: %s\n&amp;quot;, buf );
sleep( 5 );
}
}
printf( &amp;quot;end thread receiving data on fd: %d\n&amp;quot;, sockfd );
}
int main( int argc, char* argv[] )
{
if( argc &amp;lt;= 2 )
{
printf( &amp;quot;usage: %s ip_address port_number\n&amp;quot;, basename( argv[0] ) );
return 1;
}
const char* ip = argv[1];
int port = atoi( argv[2] );
int ret = 0;
struct sockaddr_in address;
bzero( &amp;amp;address, sizeof( address ) );
address.sin_family = AF_INET;
inet_pton( AF_INET, ip, &amp;amp;address.sin_addr );
address.sin_port = htons( port );
int listenfd = socket( PF_INET, SOCK_STREAM, 0 );
assert( listenfd &amp;gt;= 0 );
ret = bind( listenfd, ( struct sockaddr* )&amp;amp;address, sizeof( address ) );
assert( ret != -1 );
ret = listen( listenfd, 5 );
assert( ret != -1 );
epoll_event events[ MAX_EVENT_NUMBER ];
int epollfd = epoll_create( 5 );
assert( epollfd != -1 );
addfd( epollfd, listenfd, false );
while( 1 )
{
int ret = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, -1 );
if ( ret &amp;lt; 0 )
{
printf( &amp;quot;epoll failure\n&amp;quot; );
break;
}
for ( int i = 0; i &amp;lt; ret; i++ )
{
int sockfd = events[i].data.fd;
if ( sockfd == listenfd )
{
struct sockaddr_in client_address;
socklen_t client_addrlength = sizeof( client_address );
int connfd = accept( listenfd, ( struct sockaddr* )&amp;amp;client_address, &amp;amp;client_addrlength );
addfd( epollfd, connfd, true );
}
else if ( events[i].events &amp;amp; EPOLLIN )
{
pthread_t thread;
fds fds_for_new_worker;
fds_for_new_worker.epollfd = epollfd;
fds_for_new_worker.sockfd = sockfd;
pthread_create( &amp;amp;thread, NULL, worker, ( void* )&amp;amp;fds_for_new_worker );
}
else
{
printf( &amp;quot;something else happened \n&amp;quot; );
}
}
}
close( listenfd );
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从工作线程函数work来看，如果一个线程处理完某个socket上的请求之后，又接收到该socket的请求，那么该线程继续为该socket服务，如果5S之后没有接收到该socket请求，则放弃为此socket服务，同时重置该socket事件，进而使其他线程有机会为该socket服务。&lt;/p&gt;
&lt;p&gt;注意：一个socket在不用时期可以由不同工作线程处理，但同一时刻只有一个线程为之服务，保证了连接的完整性，避免了很多可能的竟态条件。&lt;/p&gt;</description></item><item><title>linux system signal</title><link>/language/linux-system/linux-system-signal/</link><pubDate>Tue, 23 Jun 2020 19:19:22 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-signal/</guid><description>&lt;p&gt;一、信号的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号随时发生，接受信号的进程也可以没有控制权&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个信号名都以SIG开头，包含在&lt;signal.h&gt;中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当进程接收到一个信号，他可以对信号采取如下操作之一：&lt;br /&gt;
忽略这个信号&lt;br /&gt;
捕获这个信号，这需要执行一段称为信号处理器的特殊代码&lt;br /&gt;
允许执行信号的默认操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当进程对发送给它的信号采取措施，叫信号被传送&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;产生信号和递送信号之间的时间间隔叫做信号为决&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进程不能简单的通过判断一个变量，如errno来判断是否出现一个信号&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、捕获信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个进程调用fork的时候，其子进程继承父进程的信号处理方式&lt;br /&gt;
所以信号捕捉函数的地址在子进程中式有意义的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;利用函数指针回调函数捕获信号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进程捕捉到信号并对信号进行处理时，进程正在执行的指令序列临&lt;br /&gt;
时中断，它首先执行该信号处理程序中的指令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果信号处理程序返回(没有调用exit(0)或者abort),则继续执行在&lt;br /&gt;
捕捉到信号时正在执行的正常指令序列&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在信号处理程序中，不能判断捕捉到信号时进程正在何处执行&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;signal 函数(若为命令行，则使用kill向指定进程发送信号)&lt;br /&gt;
#include &lt;signal.h&gt;&lt;br /&gt;
void (*signal(int signo,void (*func)(int)))(int);&lt;br /&gt;
//参数signo是前面表格中的信号名&lt;br /&gt;
//参数func式接收到此信号后要调用的函数。该函数有个int&lt;br /&gt;
型参数，int代表捕获到的信号值&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;signal函数的例子&lt;/em&gt;/&lt;br /&gt;
void catch_Signal(int Sign)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (Sign)
{
case SIGINT:
printf (&amp;quot;SIGINT Signal\n&amp;quot;);
break;//改变了消息的用途，可以收到CTRL+C后退出进程
case SIGALRM：
printf (&amp;quot;HELLO\n&amp;quot;);
exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;signal(SIGINT,catch_Signal);
signal(SIGALRM,catch_Signal);
pause ();
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;三、发送信号&lt;br /&gt;
1)kill&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用kill命令&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用kill函数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#include &lt;signal.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
int kill(pid_t pid,int sig)&lt;br /&gt;
//参数pid指定一个要杀死的信号，而sig是要发送的信号&lt;/p&gt;
&lt;p&gt;2)raise函数&lt;br /&gt;
#include &lt;signal.h&gt;&lt;br /&gt;
int raise(int signo);&lt;br /&gt;
//kill 函数将信号发送给进程，raise函数允许发信号给自身&lt;br /&gt;
//raise(signo)等价于kill(getpid(),signo);&lt;/p&gt;
&lt;p&gt;3)alarm函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alarm函数设置一个定时器，当定时器到了就发送SIGALRM信号&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
unsigned int alarm(unsigned int seconds);&lt;br /&gt;
//seconds是计时器时间到后时钟的秒数&lt;br /&gt;
//如果没有设置其他超时，函数返回0,否则返回值为前面安排超时中保留的秒数&lt;br /&gt;
//一个进程只能设置一次超时&lt;br /&gt;
//把second设置为0可以取消前面的超时设置&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四、改进捕获信号机制&lt;br /&gt;
sigaction函数的功能是检查或修改与指定信号相关联的&lt;br /&gt;
处理动作，该函数替代了signal函数&lt;br /&gt;
#include &lt;studio.h&gt;&lt;br /&gt;
int sigaction (int signo,const struct sigaction *act,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; struct sigaction *oact);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//参数signo是要检测或者修改其具体动作的信号编号&lt;br /&gt;
(或同时执行这两种操作)&lt;br /&gt;
//如果act指针为空，则要修改其动作&lt;br /&gt;
//如果oact指针为空，则系统由oact指针返回该信号的上一个动作&lt;br /&gt;
//成功返回0,失败返回-1&lt;/p&gt;
&lt;p&gt;struct sigaction{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void (*sa_handle)(int);
void (*sasigaction)(int,siginfo_t *,void *);
sigset_t sa_mask;
int sa_flags;
void (*sa_restorer )(void);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;sigaction例子&lt;/em&gt;/&lt;br /&gt;
void catch_Signal(int Sign)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (Sign)
{
case SIGINT:
printf (&amp;quot;SIGINT Signal\n&amp;quot;);
exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int signal1(int signo,void (*func)(int))&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sigaction act,oact;
act.sa_handler = func;//回调函数初始化
sigemptyset(&amp;amp;act.sa_mask);//初始化状态字集合，可以设置未决信号
act.sa_flags = 0;
return sigaction(signo,&amp;amp;act,&amp;amp;oact);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;signal1(SIGINT,catch_Signal);
pause();
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;五、使用自定义信号&lt;br /&gt;
/&lt;em&gt;自定义signal函数的例子&lt;/em&gt;/&lt;br /&gt;
int static status = 0;&lt;/p&gt;
&lt;p&gt;void catch_Signal(int Sign)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (Sign)
{
case SIGINT:
printf (&amp;quot;SIGINT Signal\n&amp;quot;);
break;
case SIGUSR1：
status = 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int signal1(int signo,void (*func)(int))&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sigaction act,oact;
act.sa_handler = func;//回调函数初始化
sigemptyset(&amp;amp;act.sa_mask);//初始化
act.sa_flags = 0;
return sigaction(signo,&amp;amp;act,&amp;amp;oact);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
/&lt;em&gt;捕获SIGUSR1信号&lt;/em&gt;/&lt;br /&gt;
int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;signal1(SIGINT,catch_Signal);
signal1(SIGUSR1,catch_Signal);
printf(&amp;quot;pid = %d\n&amp;quot;,getpid());
while(1)
{
if(status = 1);
printf(&amp;quot;SIGUSR1 UP!\n&amp;quot;);
sleep(1);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;发送signal信号&lt;/em&gt;/&lt;br /&gt;
int main(int argc,char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(argc &amp;gt; 1)
{
kill(atoi(args[1],SIGUSR1);
printf(&amp;quot;sent to %d\n&amp;quot;,atoi(args[1]))
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;六、守护进程（daemon）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;守护进程是一个后台进程,无须用户输入就能运行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;守护进程不能够控制终端,所以任何输入或者输出都需做特殊处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;守护进程执行fork之后就让父进程退出&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;子进程中调用setsid,取消进程和任何终端的关联&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;下一步是让根目录成为进程的当前工作目录(因为如果它的当前目录是在一个被安装的&lt;br /&gt;
文件系统上,那么就会妨碍这个文件系统被卸载)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;接下来设置umask为0(为了避免守护进程继承的umask收到创建文件和目录操作的干扰,这&lt;br /&gt;
一步是必要的)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最后关闭子进程继承的任何不必要的文件描述符&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结:&lt;br /&gt;
1)父进程中执行fork,执行exit退出&lt;br /&gt;
2)在子进程中调用setid&lt;br /&gt;
3)让根目录&#39;/&#39;成为子进程的工作目录&lt;br /&gt;
4)把子进程的umask变为0&lt;br /&gt;
5)关闭不需要的文件描述符&lt;/p&gt;
&lt;p&gt;setsid函数:pid_t setsid()&lt;br /&gt;
//setsid函数创建一个新会话和一个新进程组,然后守护进程成为新会话的领导&lt;br /&gt;
//以及新进程组的领导&lt;br /&gt;
//setsid还保证新会话没有控制终端&lt;br /&gt;
//如果调用进程已经是一个进程组的领导进程,setsid会失败&lt;br /&gt;
//setsid调用成功返回新会话id,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;chdir函数:int chdir(const char*pathname)&lt;br /&gt;
//chdir函数根据参数pathname设置当前工作目录&lt;br /&gt;
//chdir函数调用成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;umask函数:mode_t umask(mode_t mask)&lt;br /&gt;
//umask调用把守护今晨的umask设置为0,这样取消了父进程的umask,避免了潜在的&lt;br /&gt;
//干扰创建文件和目录&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;创建守护进程代码&lt;/em&gt;/&lt;br /&gt;
int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pid_t pid = fork();
if (pid == -1)
{
return -1;
}
if (pid &amp;gt; 0)
{
exit(0);
}
if(pid == 0)
{
setsid();//脱离控制台
chdir(&amp;quot;/&amp;quot;);//非必须,防止mount出错
umask(0);
close(STDIN_FILENO);
close(STDOUT_FILENO);
close(STDERR_FILENO);
}
while(1)
{
printf(&amp;quot;hello\n&amp;quot;);
sleep(1);
}
return EXIT_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;守护进程写入系统日志:&lt;br /&gt;
1)openlog函数打开日志:void openlog(const char *ident,int option,int facility);&lt;br /&gt;
//参数ident是要向每个消息加入的字符串,典型的情况是程序名称&lt;br /&gt;
//参数option是下面一个或多个值的&amp;quot;或&amp;quot;&lt;br /&gt;
名称 含义&lt;br /&gt;
LOG_CONS 如果系统日志服务器不能用, 写入控制台&lt;br /&gt;
LOG_NDELAY 立即打开连接,正常情况下,直到发送第一条消息才打开连接&lt;br /&gt;
LOG_PERROR 打印输出到stderr&lt;br /&gt;
LOG_PID 每条消息中包含进程PID&lt;br /&gt;
//参数facitity指定程序发送消息的类型&lt;br /&gt;
名称 含义&lt;br /&gt;
LOG_AUTHPRIV 安全授权信息&lt;br /&gt;
LOG_CRON 时钟守护进程,cron和at&lt;br /&gt;
LOG_DAEMON 其他系统守护进程&lt;br /&gt;
LOG_KERN 内核消息&lt;br /&gt;
LOG_LPR 打印机子系统&lt;br /&gt;
LOG_MAIL 邮件子系统&lt;br /&gt;
LOG_USER 默认&lt;br /&gt;
2)syslog写入日志:void syslog (int priority,const char * format,...)&lt;br /&gt;
//参数priority指定消息重要性&lt;br /&gt;
名称 含义&lt;br /&gt;
LOG_EMERG 系统不能使用&lt;br /&gt;
LOG_ALERT 立即采取措施&lt;br /&gt;
LOG_CRIT 紧急事件&lt;br /&gt;
LOG_ERR 出错条件&lt;br /&gt;
LOG_WARNING 警告条件&lt;br /&gt;
LOG_NOTICE 正常但重大事件&lt;br /&gt;
LOG_INFO 信息消息&lt;br /&gt;
LOG_DEBUG 调试信息&lt;br /&gt;
3)closelog关闭日志:void closelog(void);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;syslog日志例子&lt;/em&gt;/&lt;br /&gt;
syslog(LOG_INFO,&amp;quot;my daemon is OK!&amp;quot;);&lt;br /&gt;
/&lt;em&gt;严格说,openlog和closelog是可选的,因为函数syslog在首次使用的时候自动打开&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;使用信号与守护进程通信&lt;br /&gt;
void catch_Signal(int Sign)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch(Sign)
{
case SIGTERM:
exit(EXIT_SUCCESS);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;通过脚本结束守护程序&lt;/em&gt;/&lt;br /&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;WHOAMI=&lt;code&gt;whoami&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PID=&lt;code&gt;ps -u $WHOAMI | grep mydaemon | awk &#39;{print} $1&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;if(test &amp;quot;$PID&amp;quot;!=&amp;quot;&amp;quot;) then&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kill $PID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;通过脚本开启守护程序&lt;/em&gt;/&lt;br /&gt;
#!/bin/sh&lt;/p&gt;
&lt;p&gt;WHOAMI=&lt;code&gt;whoami&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PID=&lt;code&gt;ps -u $WHOAMI | grep abc | awk &#39;{print} $1&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;if(test &amp;quot;$PID&amp;quot;=&amp;quot;&amp;quot;) then&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ./mydaemon
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;p&gt;使用FIFO与守护进程通信&lt;br /&gt;
/&lt;em&gt;读FIFO&lt;/em&gt;/&lt;br /&gt;
void readfifo()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int len = 0;
char buf[1024];
memset(buf,0,sizeof(buf));
int fd = open (&amp;quot;/home/test/1/fifo&amp;quot;,O_RDONLY);
while((len = read (fd,buf,sizeof(buf))&amp;gt;0))
{
printf(&amp;quot;%s&amp;quot;,buf);
}
close(fd);
return ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;写FIFO&lt;/em&gt;/&lt;br /&gt;
void readfifo()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int len = 0;
char buf[1024];
memset(buf,0,sizeof(buf));
int fd = open (&amp;quot;/home/test/1/fifo&amp;quot;,O_WRONLY);
scanf(&amp;quot;%s&amp;quot;,buf);
write(fd,buf,sizeof(buf));
close(fd);
return ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;如何让后台运行的daemon程序向屏幕打印信息&lt;br /&gt;
1 执行mkfifo创建一个管道文件&lt;br /&gt;
2 编译daemon,执行程序,关闭当前控制台终端窗口,让程序后台运行&lt;br /&gt;
3 打开一个新的终端窗口,通过ps aux找到进程pid&lt;br /&gt;
4 执行 #kill -s 2 PID;tty &amp;gt; fifo1&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;daemon基础架构&lt;/em&gt;/&lt;br /&gt;
int signal1(int signo,void (*func)(int))&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sigaction act,oact;
act.sa_handler = func;//回调函数初始化
sigemptyset(&amp;amp;act.sa_mask);//初始化
act.sa_flags = 0;
return sigaction(signo,&amp;amp;act,&amp;amp;oact);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void setdaemon()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pid_t pid,sid;
pid = fork();
if(pid &amp;lt; 0)
{
printf(&amp;quot;fork failed %s\n&amp;quot;,strerror(errno));
exit(EXIT_SUCCESS);
}
if(pid &amp;gt; 0)
{
exit(EXIT_SUCCESS);
}
if( (sid = setsid() ) &amp;lt; 0)
{
printf(&amp;quot;setsid failed %s\n&amp;quot;,strerror(errno));
exit(EXIT_SUCCESS);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void listenfifo()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const char * sfifoname = &amp;quot;fifo1&amp;quot;;
int len = 0;
char buf[128];
memset(buf,0,sizeof(buf));
int fd = open(sfifoname,O_RDONLY);
if(fd == -1)
{
printf(&amp;quot;open %s failed,%s\n&amp;quot;,sfifoname,strerror(errno));
}
len = read (fd,buf,sizeof(buf));
if(len &amp;gt; 0)
{
if (buf[strlen(buf) - 1] == &#39;\n&#39;)
{
buf[strlen(buf) - 1] = 0;
}
close(STDOUT_FILENO);
open(buf,O_WRONLY);
}
close(fd);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void catch_Signal(int Sign)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch(Sign)
{
case SIGINT:
listenfifo();
break;
case SIGPIPE:
;
break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
int main(void)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setdaemon();
signal1(SIGINT,catch_Signal);
signal1(SIGPIPE,catch_Signal);//不捕获会退出
while(1)
{
puts(&amp;quot;!!!Hello World!!!&amp;quot;);
sleep(1);
}
return EXIT_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;</description></item><item><title>linux system io</title><link>/language/linux-system/linux-system-io/</link><pubDate>Tue, 23 Jun 2020 19:18:53 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-io/</guid><description>&lt;p&gt;####1、文件描述符&lt;br /&gt;
-STDIN_FILENO 0 标准输入&lt;br /&gt;
-STDOUT_FILENO 1 标准输出&lt;br /&gt;
-STDERR_FILENO 2 标准错误&lt;/p&gt;
&lt;p&gt;####2、系统函数 open() close() 打开、关闭文件&lt;/p&gt;
&lt;p&gt;-//该包含的头文件&lt;br /&gt;
-#include &amp;lt;sys/types.h-&lt;br /&gt;
-#include &amp;lt;sys/stat.h-&lt;br /&gt;
-#include &amp;lt;fcntl.h-&lt;br /&gt;
-#include &amp;lt;unistd.h-&lt;/p&gt;
&lt;p&gt;-int open(const char* pathname, int flags);&lt;br /&gt;
-//flags :&lt;br /&gt;
-//O_RDONLY O_WRONLY O_RDWR O_CAREAT O_APPEND&lt;br /&gt;
-int close(int fd);&lt;/p&gt;
&lt;p&gt;####3、显示出错信息&lt;br /&gt;
-#include &amp;lt;string.h-&lt;br /&gt;
-#include &amp;lt;errno.h-&lt;/p&gt;
&lt;p&gt;-if(fd == -1)&lt;br /&gt;
-{&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;//将error int 转换为error string&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;printf(&amp;quot;%s\n&amp;quot;,strerror(errno));&lt;br /&gt;
-}&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####4、系统函数 read()、write()读写文件&lt;br /&gt;
-ssize_t read (int fd,void *buf,size_t count);&lt;br /&gt;
-//成功则返回读取的字节数，读到EOF返回0，失败返回-1&lt;br /&gt;
-ssize_t write (int fd,void *buf,size_t count);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//读文件的代码
int main(int arg, char *args[])
{
if (arg &amp;lt; 2)
return 0;
int fd = open(args[1], O_RDONLY); //只读方式打开文件abc.txt
if (fd == -1)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
} else
{
printf(&amp;quot;success fd = %d\n&amp;quot;, fd);
char buf[100];
memset(buf, 0, sizeof(buf));
while(read(fd, buf, sizeof(buf) - 1) &amp;gt; 0)//循环读取文件内容，直到文件结尾，退出循环
{
printf(&amp;quot;%s\n&amp;quot;, buf);
memset(buf, 0, sizeof(buf));
}
close(fd);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//写文件的代码
int main(int arg, char *args[])
{
char s[] = &amp;quot;abc.txt&amp;quot;;
int fd = open(s, O_RDWR | O_APPEND);//用读写追加方式打开文件
if (fd == -1)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
}else
{
printf(&amp;quot;success fd = %d\n&amp;quot;, fd);
char buf[100];
memset(buf, 0, sizeof(buf));
strcpy(buf, &amp;quot;hello world\n&amp;quot;);
int i = write(fd, buf, strlen(buf));//这里要用strlen函数
close(fd);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####5、fstat() stat() 的使用&lt;br /&gt;
-int fstat (int fd, struct stat * buf)&lt;br /&gt;
-//参数fd必须是用open调用返回的有效文件描述符&lt;/p&gt;
&lt;p&gt;-int stat (const char* path, struct stat * buf)&lt;br /&gt;
-//参数path必须是文件路径&lt;/p&gt;
&lt;p&gt;-struct stat {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; dev_t st_dev; /* ID of device containing file */
ino_t st_ino; /* inode number */
mode_t st_mode; /* protection */
nlink_t st_nlink; /* number of hard links */
uid_t st_uid; /* user ID of owner */
gid_t st_gid; /* group ID of owner */
dev_t st_rdev; /* device ID (if special file) */
off_t st_size; /* total size, in bytes */
blksize_t st_blksize; /* blocksize for file system I/O */
blkcnt_t st_blocks; /* number of 512B blocks allocated */
time_t st_atime; /* time of last access */
time_t st_mtime; /* time of last modification */
time_t st_ctime; /* time of last status change */
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;};&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-std_mod成员：&lt;/p&gt;
&lt;p&gt;-S_ISREG(m) is it a regular file?&lt;/p&gt;
&lt;p&gt;-S_ISDIR(m) directory?&lt;/p&gt;
&lt;p&gt;-S_ISCHR(m) character device?&lt;/p&gt;
&lt;p&gt;-S_ISBLK(m) block device?&lt;/p&gt;
&lt;p&gt;-S_ISFIFO(m) FIFO (named pipe)?&lt;/p&gt;
&lt;p&gt;-S_ISLNK(m) symbolic link? (Not in POSIX.1-1996.)&lt;/p&gt;
&lt;p&gt;-S_ISSOCK(m) socket? (Not in POSIX.1-1996.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//得到文件状态代码
int main(int arg, char *args[])
{
int fd = open(args[1], O_RDONLY);
if (fd == -1)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
}else
{
printf(&amp;quot;success fd = %d\n&amp;quot;, fd);
struct stat buf;
fstat(fd, &amp;amp;buf);
if (S_ISREG(buf.st_mode))//判断文件是否为标准文件
{
printf(&amp;quot;%s is charfile\n&amp;quot;, args[1]);
}
if (S_ISDIR(buf.st_mode))//判断文件是否为目录
{
printf(&amp;quot;%s is dir\n&amp;quot;, args[1]);
}
printf(&amp;quot;%s size =%d\n&amp;quot;, args[1], buf.st_size);//得到文件大小
close(fd);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-关闭回显：&lt;br /&gt;
-char* getpass (const char *prompt)&lt;br /&gt;
-//参数prompt为屏幕提示字符&lt;br /&gt;
-//函数返回值为用户键盘输入的字符串&lt;/p&gt;
&lt;p&gt;-int main ()&lt;br /&gt;
-{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char* phrase = getpass (&amp;quot;please input:&amp;quot;);
printf(&amp;quot;%s&amp;quot;,phrase);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-}&lt;/p&gt;
&lt;p&gt;####5、c语言库函数fopen()、fclose()打开、关闭文件&lt;/p&gt;
&lt;p&gt;-FILE *p fopen (const char *path,const char * mode);&lt;br /&gt;
//fopen 以mode模式打开名为path的文件&lt;br /&gt;
//fopen 返回一个文件指针&lt;br /&gt;
//出现错误，fopen返回NULL,并把errno设置为恰当的值&lt;br /&gt;
//mode 说明：r r+ w w+ a a+&lt;/p&gt;
&lt;p&gt;-int fclose(FILE* stream);&lt;/p&gt;
&lt;p&gt;####6、c语言库函fread()、fwrite()数读写文件&lt;/p&gt;
&lt;p&gt;-size_t fread(void *ptr,size_t size,size_t nmemb,FILE * stream);&lt;br /&gt;
-size_t fwrite(void *ptr,size_t size,size_t nmemb,FILE * stream);&lt;br /&gt;
//参数ptr指向缓冲区保存或读取的数据&lt;br /&gt;
//参数size 控制记录大小&lt;br /&gt;
//参数nmemb为记录数&lt;br /&gt;
//函数返回读取或回写的记录数&lt;br /&gt;
//原则上第二个参数*第三个参数不要大于第一个参数的buf【100】的大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//C库函数读取文件的代码
int main(int arg, char *args[])
{
FILE *p = fopen(args[1], &amp;quot;r+&amp;quot;);
if (p == NULL)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
}else
{
printf(&amp;quot;success\n&amp;quot;);
char buf[100];
size_t rc = 0;
while(1)
{
size_t tmp = fread(buf, 1, sizeof(buf), p);//原则是第二个参数乘以第三个参数的大小不能超过缓冲区
rc += tmp;//求文件的大小
if (tmp == 0)
break;
}
printf(&amp;quot;rc = %d\n&amp;quot;, rc);
fclose(p);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//c库函数读写二进制文件的代码
struct person
{
int id;
char name[20];
int age;
int sex;
char tel[20];
};
int Fwrite(int arg, char *args[])
{
FILE *p = fopen(args[1], &amp;quot;w&amp;quot;);
if (p == NULL)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
} else
{
printf(&amp;quot;success\n&amp;quot;);
struct person man[10];
memset(&amp;amp;man, 0, sizeof(man));
man[0].id = 0;
strcpy(man[0].name, &amp;quot;小明&amp;quot;);
man[0].age = 50;
man[0].sex = 1;
strcpy(man[0].tel, &amp;quot;123&amp;quot;);
man[1].id = 1;
strcpy(man[1].name, &amp;quot;小白&amp;quot;);
man[1].age = 20;
man[1].sex = 0;
strcpy(man[1].tel, &amp;quot;321&amp;quot;);
fwrite(&amp;amp;man, sizeof(struct person), 2, p);
fclose(p);
}
return 0;
}
int Fread(int arg, char *args[])
{
FILE *p = fopen(args[1], &amp;quot;w&amp;quot;);
if (p == NULL)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
} else
{
printf(&amp;quot;success\n&amp;quot;);
struct person man;
memset(&amp;amp;man, 0, sizeof(man));
while(fread(&amp;amp;man, sizeof(struct person), 1, p))
{
printf(&amp;quot;id=%d\n&amp;quot;, man.id);
printf(&amp;quot;name=%s\n&amp;quot;, man.name);
printf(&amp;quot;age=%d\n&amp;quot;, man.age);
printf(&amp;quot;tel=%s\n&amp;quot;, man.tel);
}
fclose(p);
}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####7、行输入和行输出&lt;/p&gt;
&lt;p&gt;-char fgets(char *s,int size,FILE *stream);&lt;br /&gt;
int fputs(const char *s,FILEe *stream);&lt;br /&gt;
//fgets 从文件中读取一行，返回EOF代表文件结束&lt;br /&gt;
//fputs 向文件中写入一行&lt;/p&gt;
&lt;p&gt;####8、文件删除改名函数&lt;br /&gt;
-int remove (const char* pathname);&lt;br /&gt;
-int rename(const char* oldpath,const char *newpath);&lt;/p&gt;
&lt;p&gt;####9、找到当前目录&lt;br /&gt;
-char * getcwd(char *buf,size_t size)&lt;br /&gt;
//getcwd函数把当前的工作目录返回&lt;/p&gt;
&lt;p&gt;####10、获得目录列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;#include &amp;lt;dirent.h-&lt;br /&gt;
DIR * opendir(const char * pathname)&lt;br /&gt;
//打开目录文件&lt;br /&gt;
struct dirent * readdir(DIR * dir)&lt;br /&gt;
//读出目录文件内容&lt;br /&gt;
int closedir(DIR * dir)&lt;br /&gt;
//关闭目录文件&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//读目录的代码
int main(int arg, char *args[])
{
if (arg &amp;lt;2)
return 0;
DIR *dp;
struct dirent *dirp;
dp = opendir(args[1]);//打开目录文件
if (dp == NULL)
{
printf(&amp;quot;error is %s\n&amp;quot;, strerror(errno));
return 0;
}
while((dirp = readdir(dp)) != NULL)//用readdir循环读取目录内容，读到目录尾，循环break
{
printf(&amp;quot;%s\n&amp;quot;, dirp--d_name);//将目录下的文件名打印到屏幕
}
closedir(dp);//关闭目录
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux system socket</title><link>/language/linux-system/linux-system-socket/</link><pubDate>Tue, 23 Jun 2020 19:18:29 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-socket/</guid><description>&lt;p&gt;一 TCP/IP与套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;套接字是通信端点的抽象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;套接字同样适用于本地的通信,代替管道&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;wirte和read同样适用于套接字&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二 TCP通讯&lt;br /&gt;
1)tcp使用的过程，&lt;br /&gt;
client端，主动连接方叫client。&lt;br /&gt;
server端，被动接收方叫server。&lt;br /&gt;
=&amp;gt;TCP先连接（三次握手）&lt;br /&gt;
client &amp;gt; server:发送SYN a&lt;br /&gt;
server &amp;gt; client:回复SYN b,ack a + 1&lt;br /&gt;
client &amp;gt; server ack b + 1&lt;/p&gt;
&lt;p&gt;==&amp;gt;连接通了，双方可以互相收发消息&lt;/p&gt;
&lt;p&gt;===&amp;gt;断开连接&lt;br /&gt;
client &amp;gt; server:FIN m&lt;br /&gt;
server &amp;gt; client :ack m +1&lt;br /&gt;
server &amp;gt; client:FIN n&lt;br /&gt;
client &amp;gt; server :ack n + 1&lt;/p&gt;
&lt;p&gt;2)一个程序套接字需要执行4个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分配套接口和初始化&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;发送或连接数据&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关闭套接字&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3)涉及到的调用:&lt;br /&gt;
socket(),bind(),listen(),connect(),accept(),recv(),send()&lt;/p&gt;
&lt;p&gt;#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;/p&gt;
&lt;p&gt;int socket(int domain,int type,int protocal);&lt;br /&gt;
//domain 说明:一般用AF_INET&lt;br /&gt;
值 说明&lt;br /&gt;
AF_UNIX UNIX内部使用&lt;br /&gt;
AF_INET TCP/IP协议&lt;br /&gt;
AF_ISO 国际标准组织协议&lt;br /&gt;
AF_NS Xerox网络协议&lt;br /&gt;
//type 说明&lt;br /&gt;
值 说明&lt;br /&gt;
SOCK_STREAM 使用TCP可靠连接&lt;br /&gt;
SOCK_DGRAM 使用UDP不可靠连接&lt;br /&gt;
//protocal 一般填写0&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;int bind(int sockfd,const struct sockaddr* my_addr,socklen_t addrlen);&lt;br /&gt;
//bind 将进程和一个套接口联系起来,bind通常用于服务器进程为接入客户连接建立一个套接口&lt;br /&gt;
//参数sockfd是函数socket调用返回的套接口值&lt;br /&gt;
//参数my_addr是结构sockaddr的地址&lt;br /&gt;
//参数addrlen设置了my_addr能容纳的最大字节数&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;int listen(int sockfd,int backlog)&lt;br /&gt;
//监听客户端连接&lt;br /&gt;
//参数socket是调用socket返回的套接口描述符&lt;br /&gt;
//参数backlog设置接入队列的大小,通常设置为最大&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;int accept(int sockfd,struct sockaddr* addr,socklen_t *addrlen);&lt;br /&gt;
//accept会返回一个新的套接口,同时原来的套接口继续监听&lt;br /&gt;
//参数sockfd是函数socket调用返回的套接口描述符&lt;br /&gt;
//参数addr是指向结构sockaddr的地址&lt;br /&gt;
//参数addrlen设置了addr能容纳的最大字节数&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;int connect(int sockfd,const struct sockaddr* serv_addr,socklen_t addrlen);&lt;br /&gt;
//客户端调用connect与服务端连接&lt;br /&gt;
//参数sockfd是函数socket调用返回的套接口描述符&lt;br /&gt;
//参数addr是指向结构sockaddr的地址&lt;br /&gt;
//参数addrlen设置了addr能容纳的最大字节数&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;ssize_t send(int s, const void * buf,size_t len,int flags)&lt;br /&gt;
//参数s是已经建立的套接字&lt;br /&gt;
//参数buf是接收数据内存buffer的地址指针&lt;br /&gt;
//参数len指明buffer的大小,单位是字节&lt;br /&gt;
//参数flags一般填0&lt;br /&gt;
//成功返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;ssize_t recv(int s, const void * buf,size_t len,int flags)&lt;br /&gt;
//参数s是已经建立的套接字&lt;br /&gt;
//参数buf是接收数据内存buffer的地址指针&lt;br /&gt;
//参数len指明buffer的大小,单位是字节&lt;br /&gt;
//参数flags一般填0&lt;br /&gt;
//成功返回收到字节数,如果套接字关闭返回0,失败返回-1,并设置errno&lt;/p&gt;
&lt;p&gt;int close(int sockfd)&lt;br /&gt;
//关闭套接字&lt;/p&gt;
&lt;p&gt;int int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);&lt;br /&gt;
//setsockopt函数设置套接口&lt;br /&gt;
//常见用法:&lt;br /&gt;
//int on = 1;&lt;br /&gt;
//setsockopt(st,SOL_SOCKET,SO_REUSEADDR,&amp;amp;on,sizeof(on))&lt;br /&gt;
//由于TCP套接字状态TIME_WAIT引起该套接字关闭后约保留2-4&lt;br /&gt;
//分钟,在此期间bind该端口会失败,SO_REUSEADDR设置系统地址可重用&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;tcp:server端&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;pthread.h&gt;&lt;/p&gt;
&lt;p&gt;struct ps{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int st;
pthread_t *thr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;&lt;/p&gt;
&lt;p&gt;int status = 0;&lt;/p&gt;
&lt;p&gt;void *recvsocket(void *arg)//接收client端socket数据的线程&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct ps *p = (struct ps *)arg;
int st = p-&amp;gt;st;
char s[1024];
while(1)
{
memset(s, 0, sizeof(s));
int rc = recv(st, s, sizeof(s), 0);
if (rc &amp;lt;= 0)//如果recv返回小于等于0，代表socket已经关闭或者出错了
break;
printf(&amp;quot;%s\n&amp;quot;, s);
}
pthread_mutex_lock(&amp;amp;mutex);
status-- ;
pthread_mutex_unlock(&amp;amp;mutex);
pthread_cancel(*(p-&amp;gt;thr));//被cancel掉的线程内部没有使用锁。
return NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void *sendsocket(void *arg)//向client端socket发送数据的线程&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int st = *(int *)arg;
char s[1024];
while(1)
{
memset(s, 0, sizeof(s));
read(STDIN_FILENO, s, sizeof(s));//从键盘读取用户输入信息
send(st, s, strlen(s), 0);
}
return NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int arg, char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (arg &amp;lt; 2)
{
return -1;
}
int port = atoi(args[1]);
int st = socket(AF_INET, SOCK_STREAM, 0);//初始化socket
//给TCP设置地址可重用
int on = 1;
if (setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;amp;on, sizeof(on)) == -1)
{
printf(&amp;quot;setsockopt failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
struct sockaddr_in addr;//定义一个IP地址结构
memset(&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;//将addr结构的属性定位为TCP/IP地址
addr.sin_port = htons(port);//将本地字节顺序转化为网络字节顺序。
addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY代表这个server上所有的地址
//将IP与server程序绑定
if (bind(st, (struct sockaddr *) &amp;amp;addr, sizeof(addr)) == -1)
{
printf(&amp;quot;bind failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
//server端开始listen，
if (listen(st, 20) == -1)
{
printf(&amp;quot;listen failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
int client_st = 0;//client端socket
//socklen_t len = 0;
struct sockaddr_in client_addr;//表示client端的IP地址
//void *p = &amp;amp;client_addr;
pthread_t thrd1, thrd2;
while (1)
{
memset(&amp;amp;client_addr, 0, sizeof(client_addr));
socklen_t len = sizeof(client_addr);
//accept会阻塞，直到有客户端连接过来，accept返回client的socket描述符
client_st = accept(st, (struct sockaddr *)&amp;amp;client_addr , &amp;amp;len);
pthread_mutex_lock(&amp;amp;mutex);//为全局变量加一个互斥锁，防止与线程函数同时读写变量的冲突
status++;
pthread_mutex_unlock(&amp;amp;mutex);//解锁
if (status &amp;gt; 5)//代表这是下一个socket连接
{
close(client_st);
continue;
}
if (client_st == -1)
{
printf(&amp;quot;accept failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
printf(&amp;quot;accept by addr：%s\n&amp;quot;, inet_ntoa(client_addr.sin_addr));
printf(&amp;quot;accept by port：%d\n&amp;quot;, ntohs(client_addr.sin_port));
struct ps ps1;
ps1.st = client_st;
ps1.thr = &amp;amp;thrd2;
pthread_create(&amp;amp;thrd1, NULL, recvsocket, &amp;amp;ps1);
pthread_detach(thrd1);//设置线程为可分离
pthread_create(&amp;amp;thrd2, NULL, sendsocket, &amp;amp;client_st);
pthread_detach(thrd2);//设置线程为可分离
}
close(st);//关闭server端listen的socket
return EXIT_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;tcp:client端&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;pthread.h&gt;&lt;/p&gt;
&lt;p&gt;void *recvsocket(void *arg)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int st = *(int *)arg;
char s[1024];
while(1)
{
memset(s, 0, sizeof(s));
int rc = recv(st, s, sizeof(s), 0);
if (rc &amp;lt;= 0)
break;
printf(&amp;quot;%s\n&amp;quot;, s);
}
return NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void *sendsocket(void *arg)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int st = *(int *)arg;
char s[1024];
while(1)
{
memset(s, 0, sizeof(s));
read(STDIN_FILENO, s, sizeof(s));
send(st, s, strlen(s), 0);
}
return NULL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int arg, char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (arg &amp;lt; 3)
return -1;
int port = atoi(args[2]);
int st = socket(AF_INET, SOCK_STREAM, 0); //初始化socket，
struct sockaddr_in addr; //定义一个IP地址的结构
memset(&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET; //设置结构地址类型为TCP/IP地址
addr.sin_port = htons(port); //指定一个端口号：8080，htons:将short类型从host字节类型到net字节类型转化
addr.sin_addr.s_addr = inet_addr(args[1]); //将字符串类型的IP地址转化为int，赋给addr结构成员.
//调用connect连接到结构addr指定的IP地址和端口号
if (connect(st, (struct sockaddr *) &amp;amp;addr, sizeof(addr)) == -1)
{
printf(&amp;quot;connect failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
pthread_t thrd1, thrd2;
pthread_create(&amp;amp;thrd1, NULL, recvsocket, &amp;amp;st);
pthread_create(&amp;amp;thrd2, NULL, sendsocket, &amp;amp;st);
pthread_join(thrd1, NULL);
//pthread_join(thrd2, NULL);
close(st); //关闭socket
return EXIT_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;三 UDP通讯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP处理细节比TCP少&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UDP不能保证消息被传送到目的地&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UDP不能保证数据包传递顺序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UDP面向无连接&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;udp/tcp都可用发送函数:&lt;br /&gt;
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; struct sockaddr *src_addr, socklen_t *addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;udp接收函数:&lt;br /&gt;
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; const struct sockaddr *dest_addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//udp不需要握手,也不需要server端监听listen&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;UDP发送&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;pthread.h&gt;&lt;/p&gt;
&lt;p&gt;int main(int arg, char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (arg &amp;lt; 3)
return -1;
int st = socket(AF_INET, SOCK_DGRAM, 0);//建立socket的时候第二个参数值为SOCK_DGRAM
if (st == -1)
{
printf(&amp;quot;socket failed %s\n&amp;quot;, strerror(errno));
return 0;
}
int port = atoi(args[2]);
//设置UDP socket可以发送广播消息
int on = 1;
if (setsockopt(st, SOL_SOCKET, SO_BROADCAST, &amp;amp;on, sizeof(on)) == -1)
{
printf(&amp;quot;setsockopt failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
struct sockaddr_in addr;
memset(&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(port);
addr.sin_addr.s_addr = inet_addr(args[1]);
char buf[1024];
while (1)
{
memset(buf, 0, sizeof(buf));
read(STDIN_FILENO, buf, sizeof(buf));//读取用户键盘输入
if (sendto(st, buf, strlen(buf), 0, (struct sockaddr *) &amp;amp;addr,
sizeof(addr)) == -1)//udp使用sendto发送消息
{
printf(&amp;quot;sendto failed %s\n&amp;quot;, strerror(errno));
break;
}
}
close(st);
return EXIT_SUCCESS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;udp接收端&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;pthread.h&gt;&lt;/p&gt;
&lt;p&gt;int main(int arg, char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (arg &amp;lt; 2)
return -1;
int st = socket(AF_INET, SOCK_DGRAM, 0);
if (st == -1)
{
printf(&amp;quot;socket failed %s\n&amp;quot;, strerror(errno));
return 0;
}
int port = atoi(args[1]);
struct sockaddr_in addr;
memset(&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(port);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
if (bind(st, (struct sockaddr *)&amp;amp;addr, sizeof(addr)) == -1)//UDP接收数据，也需要绑定IP
{
printf(&amp;quot;bind failed %s\n&amp;quot;, strerror(errno));
return -1;
}
char buf[1024];
struct sockaddr_in client_addr;
socklen_t len = sizeof(client_addr);
while(1)
{
memset(&amp;amp;client_addr, 0, sizeof(client_addr));
memset(buf, 0, sizeof(buf));
if(recvfrom(st, buf, sizeof(buf), 0,
(struct sockaddr *)&amp;amp;client_addr, &amp;amp;len) == -1)
{
printf(&amp;quot;recvfrom failed %s\n&amp;quot;, strerror(errno));
break;
}else
{
printf(&amp;quot;%s recv is %s\n&amp;quot;, inet_ntoa(client_addr.sin_addr), buf);
}
}
close(st);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;四 非阻塞socket和epoll&lt;br /&gt;
1)阻塞socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞调用是指调用结果返回之前，当前线程会被挂起。&lt;br /&gt;
函数只有在得到结果之后才会返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于文件操作read、fread函数将会把线程阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于socket、accept、与recv、recvfrom函数调用将会将线程阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;为了避免整个进程被阻塞后挂起，所以在阻塞模式下，往往需要采用多线程继续&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一个进程中可以并发的线程总数总是有限的，在处理大量客户端socket连接，&lt;br /&gt;
线程并发处理socket也不方便，效率也不高&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2)非阻塞socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞调用是指调用立即返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在非阻塞模式下，accept与recv、recvfrom函数调用就会立刻返回&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在nonblocking状态下调用accept函数，如果没有客户端请求，那么&lt;br /&gt;
accept函数返回 -1 ，同时errno值为EAGAIN或者EWOULDBLOCK，这两&lt;br /&gt;
个宏定义都为整数11&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在nonblocking状态下调用recv、recvfrom函数，如果没有数据，返回-1&lt;br /&gt;
，同时errno设置为11。如果socket已经关闭，函数返回0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在nonblocking状态下对一个已经关闭的socket调用send函数，将引发&lt;br /&gt;
一个SIGPIPE信号，进程必须捕捉这个信号，因为SIGPIPE系统默认处理&lt;br /&gt;
为关闭进程&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3)fcntl函数调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fcntl函数可以将文件或者socket描述符设置为阻塞或非阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;int fcntl(int fd,int cmd,.../&lt;em&gt;arg&lt;/em&gt;/)&lt;br /&gt;
//参数fd为要设置的文件描述符或者socket&lt;br /&gt;
//参数cmd,F_GETFL为得到目前状态,F_SETFL为设置状态&lt;br /&gt;
//宏定义O_NONBLOCK代表非阻塞,0代表阻塞&lt;br /&gt;
//返回值为描述符当前状态&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/&lt;em&gt;fcntl设置非阻塞的列子&lt;/em&gt;/&lt;br /&gt;
int opts = fcntl(st,F_GETFL);&lt;br /&gt;
if(opts &amp;lt; 0)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;fcntl failed %s\n&amp;quot;,strerror(errno));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br /&gt;
opts = opts | O_NONBLOCK;&lt;br /&gt;
if(fcntl(st,F_SETFL,opts ) &amp;lt; 0)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;fcntl failed %s\n&amp;quot;,strerror(errno));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;fcntl设置阻塞的列子&lt;/em&gt;/&lt;br /&gt;
if(fcntl(st,F_SETFL,0 &amp;lt; 0)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;fcntl failed %s\n&amp;quot;,strerror(errno));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;4)epoll技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll是linux内核为处理大批量文件描述符而做了改进的poll,是linux&lt;br /&gt;
下多路复用IO接口select/poll 的增强版本,它能显著提高程序在大量并&lt;br /&gt;
发连接中只有少量活跃情况下的系统CPU利用率&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;epoll文件描述符用完后,需要用close关闭&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每次添加/修改/删除文件描述符都要调用epoll_ctl,所以要尽量少地调用epoll_ctl&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;epoll的系统调用函数&lt;br /&gt;
int epoll_create(int size)&lt;br /&gt;
//epoll_create用来创建一个epoll文件描述符,即epoll的句柄&lt;br /&gt;
//参数size指定epoll所支持的最大句柄数&lt;br /&gt;
//函数会返回一个新的epoll句柄,之后的所有操作将通过这个新句柄操作&lt;br /&gt;
//操作完之后,用close关闭epoll句柄&lt;/p&gt;
&lt;p&gt;int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)&lt;br /&gt;
//epoll_ctl用来添加/修改/删除需要侦听的文件描述符及其事件&lt;br /&gt;
//参数epfd是epoll_create()的返回值&lt;br /&gt;
//参数op表示动作,用三个宏表示&lt;br /&gt;
EPOLL_CTL_ADD: 注册新的fd到epfd中&lt;br /&gt;
EPOLL_CTL_MOD: 修改已经注册到fd的监听事件&lt;br /&gt;
EPOLL_CTL_DEL: 从epfd中删除一个fd&lt;br /&gt;
//参数fd是要监听的socket描述符&lt;br /&gt;
//参数event通知内核需要监听什么事件,struct epoll_event结构如下&lt;br /&gt;
typedef union epoll_data&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void *ptr;
int fd;
__uint32_t u32;
__uint64_t u64;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}epoll_data_t;&lt;/p&gt;
&lt;p&gt;struct epoll_event&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__unit32_t events;//Epoll events
epoll_data_t data;//User data variable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;events定义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EPOLLIN:表示对应的文件描述符可以读(包括对端socket正常关闭)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLOUT:表示对应的文件描述符可以写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLPRI:表示对应的文件描述符有紧急数据可读&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLERR:表示对应的文件描述符发生错误&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLHUP:表示对应的文件描述符被挂断(是否被close)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLET:将EPOLL设为边缘触发(Edge Triggered)模式 ,这是相对于水平触发(Level Triggered)来说的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;EPOLLONESHOT:只监听一次事件,当监听完这次事件之后,如果还需要继续监听这个socket的话,需要再次把&lt;br /&gt;
这个socket加入到EPOLL队列里&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于ET,LT两种工作模式&lt;br /&gt;
LT(Level triggered)是缺省的工作方式,并且同时支持block和no-block socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在LT模式中,内核通知一个文件描述符是否就绪了,然后可以对这个就读的fd进行IO操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果你不做任何操作,内核还是会继续通知你的,所以,这种模式编程出错错误可能要小一点&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ET(Edge Triggered)是高速工作方式,只支持no-block socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ET模式下,当描述符从未就绪变为就绪时,内核通过epoll告诉你&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ET模式会假设你知道文件描述符已经就绪,并且不会再为那个文件&lt;br /&gt;
描述符发送更多的就绪通知,直到你做了某些操作导致那个文件为&lt;br /&gt;
就绪状态了&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果一直不对这个fd作IO操作(从而导致他再次变成未就绪),内核&lt;br /&gt;
不会发送更多通知&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ET和LT的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LT事件不会丢弃,而是只要读buffer里面有数据可以让用户读,则不断&lt;br /&gt;
的通知你&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ET则只在世纪爱发生之时通知.可以简单理解为LT是水平触发,而ET是&lt;br /&gt;
边缘触发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LT模式只要有事件为处理就会触发,而ET则只在高低电平变换(即由0到1&lt;br /&gt;
,或由1到0)时才触发&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout)&lt;br /&gt;
//epoll_wait接受发生在侦听的描述符上,用户感兴趣的IO事件&lt;br /&gt;
//参数epfd是epoll_create()的返回值&lt;br /&gt;
//参数events一个epoll_events*指针,当epoll_wait这个函数操作成功之后,epoll_events里面将存储所有的读写事件&lt;br /&gt;
//参数maxevents是当前需要监听的所有socket句柄数&lt;br /&gt;
//参数timeout是epoll_wait的超时,为0的时候表示马上返回,为-1的时候一直等下去,直到有事件范围,正整数表示等这么长时间&lt;br /&gt;
//一般如果网络主循环是单独的线程的话,可以用-1来等,这样可以保证一些效率&lt;br /&gt;
//如果是和主逻辑在同一个线程的话,可以用0来保证主循环的效率&lt;br /&gt;
//epoll_wait范围之后应该是一个循环,遍历所有的事件&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;epoll例子&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;fcntl.h&gt;&lt;br /&gt;
#include &lt;sys/epoll.h&gt;&lt;/p&gt;
&lt;p&gt;int socket_create(int port)//在port指定端口上建立server端的socket&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int st = socket(AF_INET,SOCK_STREAM,0);
if (st == 0)
return 0;
int on = 0;
if (setsockopt(st, SOL_SOCKET, SO_REUSEADDR, &amp;amp;on, sizeof(on)) == -1)
{
printf(&amp;quot;setsockopt failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
struct sockaddr_in addr;//定义一个IP地址结构
memset(&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;//将addr结构的属性定位为TCP/IP地址
addr.sin_port = htons(port);//将本地字节顺序转化为网络字节顺序。
addr.sin_addr.s_addr = htonl(INADDR_ANY);
//将IP与server程序绑定
if (bind(st, (struct sockaddr *) &amp;amp;addr, sizeof(addr)) == -1)
{
printf(&amp;quot;bind failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
//server端开始listen，
if (listen(st, 200) == -1)
{
printf(&amp;quot;listen failed %s\n&amp;quot;, strerror(errno));
return EXIT_FAILURE;
}
printf(&amp;quot;listen %d success\n&amp;quot;,port);
return st;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int socket_accept (int listen_st)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sockaddr_in client_addr;
socklen_t len = sizeof(client_addr);
memset(&amp;amp;client_addr, 0,sizeof(client_addr));
int client_st = accept(listen_st,(struct sockaddr *)&amp;amp;client_addr,&amp;amp;len);
if (client_st == -1)
{
printf(&amp;quot;accept failed %s\n&amp;quot;,strerror(errno));
return 0;
}
else
{
printf(&amp;quot;accept by %s\n&amp;quot;,inet_ntoa(client_addr.sin_addr));
return client_st;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;ssize_t socket_recv(int st)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char buf[1024];
memset(buf,0,sizeof(buf));
ssize_t rc = recv(st,buf,sizeof(buf),0);
if(rc &amp;lt;= 0)
{
printf(&amp;quot;recv failed %s\n&amp;quot;,strerror(errno));
}else
{
printf(&amp;quot;recv %s\n&amp;quot;,buf);
send(st,buf,rc,0);
}
return rc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void setnonblocking(int st)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int opts = fcntl(st,F_GETFL);
if(opts &amp;lt; 0)
{
printf(&amp;quot;fcntl failed %s\n&amp;quot;,strerror(errno));
}
opts = opts | O_NONBLOCK;
if(fcntl(st,F_SETFL,opts )&amp;lt; 0)
{
printf(&amp;quot;fcntl failed %s\n&amp;quot;,strerror(errno));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int main(int arg,char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(arg &amp;lt; 2)
return -1;
int iport = atoi(args[1]);
int listen_st = socket_create(iport);
if(listen_st == EXIT_FAILURE)
return -1;
struct epoll_event ev,events[100];//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件
int epfd = epoll_create(100);//生成用于处理accept的epoll专用文件描述符
setnonblocking(listen_st);//把socket设置为非阻塞方式
ev.data.fd = listen_st;//设置要与处理的事件相关的文件描述符
ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;//设置要处理的事件类型
epoll_ctl(epfd,EPOLL_CTL_ADD,listen_st,&amp;amp;ev);//注册epoll事件
int st = 0;
while(1)
{
int nfds = epoll_wait(epfd,events,100,-1);//等待epoll事件发生
if(nfds == -1)
{
printf(&amp;quot;epoll_wait failed %s\n&amp;quot;,strerror(errno));
break;
}
//正式流程
int i;
for(i = 0;i &amp;lt; nfds;i++)
{
if(events[i].data.fd &amp;lt; 0)
continue;
//检测到一个socket用户连接到了绑定的socket端口,建立新连接
if(events[i].data.fd == listen_st)
{
st = socket_accept(listen_st);
if(st &amp;gt;= 0)
{
setnonblocking(st);
ev.data.fd = st;
ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;//设置要处理的数据类型
epoll_ctl(epfd,EPOLL_CTL_ADD,st,&amp;amp;ev);
continue;
}
}
//client有socket事件到达
if(events[i].events &amp;amp; EPOLLIN)//socket收到数据
{
st = events[i].data.fd;
if(socket_recv(st) &amp;lt;= 0)
{
close(st);
events[i].data.fd = -1;
}
}
if(events[i].events &amp;amp; EPOLLERR)//socket错误
{
st = events[i].data.fd;
close(st);
events[i].data.fd = -1;
}
if(events[i].events &amp;amp; EPOLLHUP)//socket关闭
{
st = events[i].data.fd;
close(st);
events[i].data.fd = -1;
}
}
}
close(epfd);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;5)select技术&lt;br /&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; fd_set *exceptfds, struct timeval *timeout);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//参数timeout填NULL,永远等待&lt;br /&gt;
//select函数使用方法&lt;br /&gt;
fd_set fd1;&lt;br /&gt;
FD_ZERO(&amp;amp;fd1);//初始化fd1&lt;/p&gt;
&lt;p&gt;int socket;&lt;br /&gt;
FD_SET(socket, &amp;amp;fd1);//将socket添加到fd1&lt;br /&gt;
FD_CLR(socket, &amp;amp;fd1);//将socket从fd1移除.&lt;/p&gt;
&lt;p&gt;FD_ISSET(socket, &amp;amp;fd1);//判断socket是不是在fd1当中&lt;/p&gt;
&lt;p&gt;The time structures involved are defined in &lt;sys/time.h&gt; and look like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; struct timeval {
long tv_sec; /* seconds */
long tv_usec; /* microseconds */
};
and
struct timespec {
long tv_sec; /* seconds */
long tv_nsec; /* nanoseconds */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/&lt;em&gt;select例子&lt;/em&gt;/&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
#include &lt;errno.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;sys/socket.h&gt;&lt;br /&gt;
#include &lt;netinet/in.h&gt;&lt;br /&gt;
#include &lt;arpa/inet.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
#include &lt;fcntl.h&gt;&lt;br /&gt;
#include &lt;sys/select.h&gt;&lt;/p&gt;
&lt;p&gt;#define FD_MAX 1024&lt;br /&gt;
int main(int arg,char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(arg &amp;lt; 2)
return -1;
int iport = atoi(args[1]);
int listen_st = socket_create(iport);//建立一个listen socket
if(listen_st == 0)
return -1;
setnonblocking(listen_st); //把socket设置为非阻塞方式
int i = 0;
int maxfd = 0; //最大的socket,select函数的第一个参数使用
int sockfd = -1;
int client[FD_MAX]; //建立一个socket池,最大存放1024个socket
for(i = 0;i &amp;lt; FD_MAX; i++)
{
client[i] = -1;//将socket池中的每一个成员都初始化为-1
}
maxfd = listen_st;//设置最大编号socket
fd_set allset;
int client_st = -1;
while(1)
{
FD_ZERO(&amp;amp;allset); //初始化allset
FD_SET(listen_st,&amp;amp;allset); //将listen_st放入allset结构中
maxfd = listen_st;
for(i = 0;i &amp;lt; FD_MAX; i++)
{
if(client[i] != -1)
{
FD_SET(client[i],&amp;amp;allset);
if(client[i] &amp;gt; maxfd)
maxfd = client[i];//maxfd永远大于最大的sock
}
}
int rc = select(maxfd + 1,&amp;amp;allset,NULL,NULL,NULL);
if(FD_ISSET(listen_st,&amp;amp;allset))//判断集合中的listen_st描述符是否有的消息到达,代表有client连接
{
client_st = socket_accept(listen_st);
if(client_st &amp;gt;= 0)
{
setnonblocking(client_st);
for(i = 0;i &amp;lt; FD_MAX;i++)
{
if(client[i] == -1)
{
client[i] == client_st;//找到client[]数组中空闲的位置,插入当前client_st
break;
}
}
if(i == FD_MAX)
{
close(client_st); //限制超过FD_MAX,断掉
}
rc--; //处理完一个socket,就将select返回的总数减1
if(rc &amp;lt;= 0)
{
continue;//没有更多的socket可以处理
}
}else
{
break;//如果accept失败,跳出
}
}
for(i = 0,i &amp;lt; FD_MAX; i++)
{
sockfd = client[i];
if(sockfd == -1)
{
continue;
}
if(FD_ISSET(sockfd,&amp;amp;allset))
{
if(socket_recv(sockfd) &amp;lt;= 0)//调用socket_recv接收数据
{
close(sockfd);
//FD_CLR(sockfd,&amp;amp;allset);//将该socket移除
client[i] = -1;
}
rc--;//处理完一个socket,就将select返回的总数减1
}
if(rc &amp;lt; 0)
{
break;//已经没有更多的socket可以创建了,循环break
}
}
}
close(listen_st);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;五 特殊问题&lt;br /&gt;
1)如何将struct sockaddr_in转化为IP地址?&lt;br /&gt;
const char* getIPAddrbyaddr_in(struct sockaddr_in *client_addr)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return inet_ntoa(client_addr-&amp;gt;sin_addr);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void sockaddr_toa(const struct sockaddr_in *addr,char * IPAddr)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned char *p = (unsigned char *)&amp;amp;(addr-&amp;gt;sin_addr.s_addr);
sprintf(IPAddr,&amp;quot;%u,%u,%u,%u&amp;quot;,p[0],p[1],p[2],p[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;2)如何将域名转化为IP&lt;br /&gt;
const char *getIPAddrbyHostname(const char * hostname)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static char s[128];
memset(s,0,sizeof(s));
struct hostent *h;
h = gethostbyname(hostname);
strcpy(s, inet_ntoa(*((struct in_addr*)h-&amp;gt;h_addr)));
return s;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3)如何得到一个socket自身addr,和远程的addr&lt;br /&gt;
int getpeername(int sockfd, struct sockaddr * addr, socklen_t *addrlen);&lt;br /&gt;
//得到远端sockaddr&lt;/p&gt;
&lt;p&gt;int getsockname(int sockfd, struct sockaddr * addr, socklen_t *addrlen);&lt;br /&gt;
//得到自身sockaddr&lt;/p&gt;
&lt;p&gt;六 抓包&lt;br /&gt;
/&lt;em&gt;pub.h&lt;/em&gt;/&lt;br /&gt;
#pragma once&lt;br /&gt;
#include &lt;stdio.h&gt;&lt;br /&gt;
#include &lt;stdlib.h&gt;&lt;br /&gt;
#include &lt;string.h&gt;&lt;br /&gt;
#include &lt;wtypes.h&gt;&lt;/p&gt;
&lt;p&gt;// 定义协议的名称结构&lt;br /&gt;
typedef struct _PROTN2T&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int proto;
char *pprototext;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} PROTN2T;&lt;/p&gt;
&lt;p&gt;// 协议数&lt;br /&gt;
#define PROTO_NUM 11&lt;/p&gt;
&lt;p&gt;// IP头结构&lt;br /&gt;
typedef struct _IPHEADER&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned char header_len:4;// 头长度，4个位长
unsigned char version:4;// 版本号，4个位长
unsigned char tos;// 服务类型（主要定义包的优先级）
unsigned short total_len;// 包整个长度的字节数
unsigned short ident;// 标识，由于IP包发送时候在网络传送时可能还要分割为更小的包，标识唯一确定每个发送的数据包
unsigned short flags;// 综合标志位（前3位：标志，后13位：分块偏移，用来重组分割的IP数据包）
unsigned char ttl;// 生存时间，代表网络上的存活寿命
unsigned char proto;// 协议
unsigned short checksum;// 头校验和，该位确保目的主机接收数据和发送数据的相同
unsigned int sourceIP;// 源IP
unsigned int destIP;// 目的IP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} IPHEADER;&lt;/p&gt;
&lt;p&gt;// UDP头长度&lt;br /&gt;
#define UDP_HEAD_LEN 8&lt;br /&gt;
#define PSEUDO_HEAD_LEN 12&lt;/p&gt;
&lt;p&gt;// ICMP头长度&lt;br /&gt;
#define ICMP_HEAD_LEN 8&lt;/p&gt;
&lt;p&gt;struct TCPPacketHead&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WORD SourPort;// 16位源端口
WORD DesPort;// 16目的端口
DWORD SeqMo;// 32位序列号，指出了TCP段数据区其实数据位置
DWORD AckNo;// 32位确认号，指出连接期望从数据流中接收的下一字节数据，例如：如果收到最后一个字节序号为630，那么TCP将发一个为631的确认号
BYTE HLen;// 头长度
BYTE FLag;// 标识位，紧急（URG），确认（ACK），推送（PSH），重置（RST），同步（SYN），完成（FIN）
WORD WndSize;// 16位窗口大小
WORD ChkSum;// 16位TCP校验和
WORD UrgPtr;// 16位紧急指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;// ICMP包头部结构&lt;br /&gt;
struct ICMPPacketHead&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BYTE Type;// 类型
BYTE Code;// 编码
WORD ChkSum;// 16位TCP校验和
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;// UDP包头结构&lt;br /&gt;
struct UDPPacketHead&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WORD SourcePort;// 源端口
WORD DestPort;// 目的端口
WORD Len;// 消息包长度
WORD ChkSum;// 16位TCP校验和
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;int SnifferReceive(SOCKET &amp;amp;sock, bool ShowByte = false);&lt;/p&gt;
&lt;p&gt;int SocketCreate(SOCKET &amp;amp;sock, const char *IPAddr, unsigned short Port);&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;pub.cpp&lt;/em&gt;/&lt;br /&gt;
#pragma once&lt;br /&gt;
#include &amp;quot;stdafx.h&amp;quot;&lt;br /&gt;
#include &lt;winsock2.h&gt;&lt;br /&gt;
#include &lt;MSTcpIP.h&gt;&lt;br /&gt;
#include &amp;quot;pub.h&amp;quot;&lt;/p&gt;
&lt;p&gt;#pragma comment(lib,&amp;quot;ws2_32.lib&amp;quot;)&lt;/p&gt;
&lt;p&gt;char *Get_proto_name(unsigned char proto)// 通过struct _PROTN2T结构的proto成员，得到协议名&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch (proto)
{
case IPPROTO_IP:
return &amp;quot;IP&amp;quot;;
case IPPROTO_ICMP:
return &amp;quot;ICMP&amp;quot;;
case IPPROTO_IGMP:
return &amp;quot;IGMP&amp;quot;;
case IPPROTO_GGP:
return &amp;quot;GGP&amp;quot;;
case IPPROTO_TCP:
return &amp;quot;TCP&amp;quot;;
case IPPROTO_PUP:
return &amp;quot;PUP&amp;quot;;
case IPPROTO_UDP:
return &amp;quot;UDP&amp;quot;;
case IPPROTO_IDP:
return &amp;quot;IDP&amp;quot;;
case IPPROTO_ND:
return &amp;quot;ND&amp;quot;;
case IPPROTO_RAW:
return &amp;quot;RAW&amp;quot;;
case IPPROTO_MAX:
return &amp;quot;MAX&amp;quot;;
default:
return &amp;quot;UNKNOW&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;void PrintByte(const char *Buf, size_t BufSize)// 将二进制数转化为16进制字符串，打印到屏幕上&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (size_t i = 0; i &amp;lt; BufSize; i++)
{
printf(&amp;quot;%.2x&amp;quot;, (unsigned char)Buf[i]);
/*
if ((i % 8) == 7)
{
printf(&amp;quot; &amp;quot;);
}
if ((i % 16) == 15)
{
printf(&amp;quot;\n&amp;quot;)
}*/
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;int SnifferReceive(SOCKET &amp;amp;sock, bool ShowByte)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IPHEADER *ipHeader = NULL;
TCPPacketHead *tcpHeader = NULL;
ICMPPacketHead *icmpHeader = NULL;
UDPPacketHead *udpHeader = NULL;
BYTE *pData = NULL; // 存放数据的buf
char *pLastBuf = NULL;// 最后一个buf
WORD wSrcPort, wDestPort;// 源端口和目的端口
char sSrcIPAddr[32], sDestIPAddr[32], sProtoName[32];
memset(sSrcIPAddr, 0, sizeof(sSrcIPAddr));
memset(sDestIPAddr, 0, sizeof(sDestIPAddr));
memset(sProtoName, 0, sizeof(sProtoName));
in_addr inaddr;
char sBuf[8192];// Socket默认的Buffer位8K
char *pBuf = sBuf;
memset(sBuf, 0, sizeof(sBuf));
int iRes = recv(sock, sBuf, sizeof(sBuf), 0);
if (iRes == SOCKET_ERROR)
{
return WSAGetLastError();
}
// 得到IP包头
ipHeader = (IPHEADER *)pBuf;
// 得到IP包头总长度
WORD iLen = ntohs(ipHeader-&amp;gt;total_len);
while (true)
{
if (iLen &amp;lt;= iRes)
{
// 得到IP包的源地址
inaddr.S_un.S_addr = ipHeader-&amp;gt;sourceIP;
strcpy(sSrcIPAddr, inet_ntoa(inaddr));
// 得到IP包的目的地址
inaddr.S_un.S_addr = ipHeader-&amp;gt;destIP;
strcpy(sDestIPAddr, inet_ntoa(inaddr));
// 得到包的协议名称
strcpy(sProtoName, Get_proto_name(ipHeader-&amp;gt;proto));
// 得到IP包头的长度（因为header_len为4比特的数据，所以需要这样计算）
int iHdrLen = ipHeader-&amp;gt;header_len &amp;amp; 0xf;
iHdrLen *= 4;
// 总长度减包头长度得到的数据的长度
int iTotalLen = ntohs(ipHeader-&amp;gt;total_len);
iTotalLen -= iHdrLen;
switch (ipHeader-&amp;gt;proto)
{
case IPPROTO_ICMP:
{
icmpHeader = (ICMPPacketHead *)(sBuf + iHdrLen);
pData = ((BYTE*)icmpHeader) + ICMP_HEAD_LEN;
iTotalLen -= ICMP_HEAD_LEN;
}
case IPPROTO_TCP:
{
tcpHeader = (TCPPacketHead *)(sBuf + iHdrLen);
// 得到源端口
wSrcPort = ntohs(tcpHeader-&amp;gt;SourPort);
// 得到目标端口
wDestPort = ntohs(tcpHeader-&amp;gt;DesPort);
iHdrLen = tcpHeader-&amp;gt;HLen &amp;gt;&amp;gt; 4;
iHdrLen *= 4;
pData = ((BYTE *)tcpHeader) + iHdrLen;
iTotalLen -= iHdrLen;
break;
}
case IPPROTO_UDP:
{
udpHeader = (UDPPacketHead *)(&amp;amp;sBuf[iHdrLen]);
// 得到源端口
wSrcPort = ntohs(udpHeader-&amp;gt;SourcePort);
// 得到目标端口
wDestPort = ntohs(udpHeader-&amp;gt;DestPort);
pData = ((BYTE *)udpHeader) + UDP_HEAD_LEN;
iTotalLen -= UDP_HEAD_LEN;
break;
}
}
static unsigned int iSequence = 0;
iSequence++;
/*
Internet 组管理协议（IGMP）是因特网协议家族中的一个组播协议，用于IP主机向人一个相邻的
路由器报告他们的组成员情况
*/
if (strcmp(sProtoName, &amp;quot;IGMP&amp;quot;) != 0)// 如果是IGMP协议，就补打印协议内容
{
// 过滤掉广播消息
if (strncmp(sDestIPAddr, &amp;quot;192.168.0.255&amp;quot;, strlen(&amp;quot;192.168.0.255&amp;quot;)) != 0)
{
printf(&amp;quot;------------------begin %.10u------------------\n&amp;quot;, iSequence);
printf(&amp;quot;ProtoName:%s\nSrcAddr:%s\nDestAddr:%s\nSrcPort:%d\nDestPort:%d\n&amp;quot;,
sProtoName, sSrcIPAddr, sDestIPAddr, wSrcPort, wDestPort);
if (ShowByte)
{
printf(&amp;quot;Byte:\n&amp;quot;);
PrintByte((char*)pData, iTotalLen);
}
printf(&amp;quot;\nASCII:\n%s\n&amp;quot;, (char *)pData);
}
}
//printf(&amp;quot;------------------end %d.10u------------------\n\n&amp;quot;, iSequence);
if (iLen &amp;lt; iRes)
{
iRes -= iLen;
pBuf += iLen;
ipHeader = (IPHEADER *)pBuf;
}
else
{
break;// 如果ipHeader-&amp;gt;total_len == iRes则退出
}
}
else// 已经读到的buffer的最后部分，即包的长度
{
int iLast = iLen - iRes;
if (pLastBuf)
delete []pLastBuf;
pLastBuf = new char[iLen];
int iReaden = iRes;
memcpy(pLastBuf, pBuf, iReaden);
iRes = recv(sock, pLastBuf + iReaden, iLast, 0);
if (iRes == SOCKET_ERROR)
return WSAGetLastError();
pBuf = pLastBuf;
ipHeader = (IPHEADER *)pBuf;
if (iRes == iLast)
iRes = iLen;
else
{
// 读剩余所有的数据
iReaden += iRes;
iLast -= iRes;
while (true)
{
iRes = recv(sock, pLastBuf + iReaden, iLast, 0);
if (iRes == SOCKET_ERROR)
return WSAGetLastError();
iReaden += iRes;
iLast -= iRes;
if (iLast &amp;lt;= 0)
break;
}
}
}
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 指定的IP地址和端口上，建立一个原始的socket。&lt;br /&gt;
int SocketCreate(SOCKET &amp;amp;sock, const char *IPAddr, unsigned short Port)&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 初始化win socket环境
unsigned short wVersion;
WSADATA wsaData;
wVersion = MAKEWORD(1, 1);
int iRes = WSAStartup(wVersion, &amp;amp;wsaData);
if (iRes != 0)
return iRes;
// 创建原始的socket
sock = socket(AF_INET, SOCK_RAW, IPPROTO_IP);
if (sock == INVALID_SOCKET)
return WSAGetLastError();
// 设置超时选项
int iRecTime = 50000; // 50秒，设置接收超时
if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char *)&amp;amp;iRecTime, sizeof(iRecTime)) == SOCKET_ERROR)
return WSAGetLastError();
// 将socket bind到一个具体的断口和地址
sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(Port);
addr.sin_addr.s_addr = inet_addr(IPAddr);
if (bind(sock, (LPSOCKADDR)&amp;amp;addr, sizeof(addr)) == SOCKET_ERROR)
{
return WSAGetLastError();
}
// 设置socket模式，当调用WSAIoctl函数的时候为了能让socket能接收网络的所有IP包，
// 传给WSAIoctl函数的socket句柄必须设置成AF_INET， SOCK_RAW，和IPPROTO_IP协议，而且
// 这个socket必须显示的bind到本地的一个端口和地址
DWORD dwBufferInLen = 1;
DWORD dwBufferLen[10];
DWORD dwBytesReturned = 0;
// 调用WSAIoctl， 设置socket可以接收所有的IP包
if (WSAIoctl(sock, SIO_RCVALL, &amp;amp;dwBufferInLen, sizeof(dwBufferInLen),
&amp;amp;dwBufferLen, sizeof(dwBufferLen), &amp;amp;dwBytesReturned, NULL, NULL) == SOCKET_ERROR)
{
return WSAGetLastError();
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;sniffer.cpp&lt;/em&gt;/&lt;br /&gt;
// sinffer.cpp : 定义控制台应用程序的入口点。&lt;br /&gt;
//&lt;/p&gt;
&lt;p&gt;#include &amp;quot;stdafx.h&amp;quot;&lt;br /&gt;
#include &amp;quot;pub.h&amp;quot;&lt;/p&gt;
&lt;p&gt;int main(int argc, char* argv[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (argc &amp;lt; 3)
{
printf(&amp;quot;usage: %s IPAddress port [byte]\n&amp;quot;, argv[0]);
return 0;
}
printf(&amp;quot;sniffer\\nauthor: xhf by 2016-7-15\\nversion is 1.0.0\n\n&amp;quot;);
SOCKET sock;
int iPort = atoi(argv[2]);
int iRes = SocketCreate(sock, argv[1], (unsigned short)iPort);
if (iRes != 0)
{
LPVOID lpMsgBuf;
FormatMessage(
FORMAT_MESSAGE_ALLOCATE_BUFFER |
FORMAT_MESSAGE_FROM_SYSTEM |
FORMAT_MESSAGE_IGNORE_INSERTS,
NULL,
iRes, // 这个地方放的是lasterror的返回值
MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
(LPTSTR)&amp;amp;lpMsgBuf,
0,
NULL
);
printf(&amp;quot;Error:%d %s\n&amp;quot;, iRes, (LPCTSTR)lpMsgBuf);
LocalFree(lpMsgBuf);
return -1;
}
while (true)
{
if (argc ==4)
{
iRes = SnifferReceive(sock, true);
}
else
{
iRes = SnifferReceive(sock);
}
if (iRes != 0)
{
LPVOID lpMsgBuf;
FormatMessage(
FORMAT_MESSAGE_ALLOCATE_BUFFER |
FORMAT_MESSAGE_FROM_SYSTEM |
FORMAT_MESSAGE_IGNORE_INSERTS,
NULL,
iRes, // 这个地方放的是lasterror的返回值
MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
(LPTSTR)&amp;amp;lpMsgBuf,
0,
NULL
);
}
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;</description></item><item><title>linux system thread</title><link>/language/linux-system/linux-system-thread/</link><pubDate>Tue, 23 Jun 2020 19:17:57 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-thread/</guid><description>&lt;p&gt;####1,进程创建方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system 系统调用shell&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;fork 创建和父进程一样的进程拷贝&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;exec 创建一个新的进程，与父进程不同&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####2,得到pid、和ppid&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int main(void)
{
printf(&amp;quot;pid = %d\n&amp;quot;,getpid());
printf(&amp;quot;pid = %d\n&amp;quot;,getppid());
return EXIT_SUCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####3,获取当前用户信息&lt;br /&gt;
getlogin函数返回执行程序的登陆用户名&lt;br /&gt;
getpwnam函数可以返回/etc/passwd文件中与该登录名相关的完整一行&lt;br /&gt;
#include &lt;pwd.h&gt;&lt;br /&gt;
struct passwd *getpwnam(const char *name);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*例子*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
int main()
{
char * login = getlogin();
struct passwd *ps = getpwnam(login);
printf(&amp;quot;user name=%s\n&amp;quot;,ps-&amp;gt;pw_name);
printf(&amp;quot;uid=%s\n&amp;quot;,ps-&amp;gt;pw_uid);
printf(&amp;quot;home dir=%s\n&amp;quot;,ps-&amp;gt;pw_dir);
return EXIT_SUCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####4,system 系统调用&lt;br /&gt;
system (&amp;quot;ls -l&amp;quot;);&lt;/p&gt;
&lt;p&gt;####5,fork 系统调用&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;br /&gt;
pid_t fork(void)&lt;br /&gt;
//fork 执行成功，想父进程返回子进程的pid，并向子进程返回&lt;br /&gt;
0，这意味着fork即使只调用一次，也会返回两次&lt;br /&gt;
//fork创建的新进程是和父进程(除pid和ppid)一样的副本&lt;br /&gt;
//父进程和子进程有点区别，子进程没有继承父进程的超时设置&lt;br /&gt;
(使用alarm调用)、父进程创建的文件锁，或者未决信号&lt;br /&gt;
//fork 失败返回 -1&lt;/p&gt;
&lt;p&gt;####6,exec命令族&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
char * args[] = {&amp;quot;/bin/ls&amp;quot;,&amp;quot;-l&amp;quot;,NULL};
execve(&amp;quot;/bin/ls&amp;quot;,args, NULL);
printf(&amp;quot;End\n&amp;quot;);//不会执行，进程内容被execve覆盖
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;####7,wait()、waitpid()可以收集子进程的退出状态&lt;br /&gt;
#include &lt;sys/wait.h&gt;&lt;br /&gt;
pid_t wait(int * status);&lt;br /&gt;
pid_t waitpid(pid_t pid,int * status,int options);&lt;br /&gt;
//status 保存子进程退出状态&lt;br /&gt;
//pid为等待进程的pid，他能接受下表列出4种值的一个&lt;br /&gt;
值 描述&lt;br /&gt;
-1 等待任何PGID等于PID 的绝对值子进程&lt;br /&gt;
1 等待任何子进程&lt;br /&gt;
0 等待任何PGID等于调用进程的子进程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 等待PID等于pid的子进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*例子*/
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int main()
{
pid_t pid = fork();
int status;
if(pid == -1)
{
printf(&amp;quot;fork failed\n&amp;quot;);
return -1;
}
if(pid == 0)
{
printf(&amp;quot;child process start\n&amp;quot;);
sleep(2);
printf(&amp;quot;child process start\n&amp;quot;);
return 100;
}
else
{
printf(&amp;quot;parent process start\n&amp;quot;);
wait(&amp;amp;status);
//等待子进程退出，并获得状态，不能搜集多个子进程
//waitpid(pid,&amp;amp;status,0);
//等待子进程退出，并获得状态，能搜集多个子进程
printf(&amp;quot;status %d\n&amp;quot;,WEXITSTATUS(status));//用宏去解析这个状态
printf(&amp;quot;parent process start\n&amp;quot;);
return 0;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;//僵死进程&lt;br /&gt;
父进程没有调用wait，子进程就退出了，这个时候子进程就成了僵死进程&lt;/p&gt;
&lt;p&gt;//孤儿进程&lt;br /&gt;
父进程在调用wait()或者waitpid()之前就已经退出的进程，叫做孤儿进程，此时init&lt;br /&gt;
成为此进程的父进程，由父进程收集孤儿进程的退出状态，避免其僵死&lt;/p&gt;
&lt;p&gt;####8、结束进程&lt;br /&gt;
5种退出原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main 中调用return&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;调用exit函数，int exit(int status)返回状态值，用于非main函数中退出子进程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;调用_exit函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;调用abort函数，void abort(void)导致程序异常终止，产生core文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;被一个信号终止&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;`&lt;br /&gt;
kill函数&lt;br /&gt;
#include &lt;signal.h&gt;&lt;br /&gt;
#include &lt;sys/types.h&gt;&lt;br /&gt;
int kill(pid_t pid,int sig)&lt;br /&gt;
//exit,abort用来杀死自己&lt;br /&gt;
//kill函数用来杀死另一个进程&lt;br /&gt;
//参数pid指定一个要杀死的进程，sig指发送的信号&lt;/p&gt;</description></item><item><title>linux system ipc</title><link>/language/linux-system/linux-system-ipc/</link><pubDate>Tue, 23 Jun 2020 19:17:31 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-ipc/</guid><description>&lt;p&gt;一、无名管道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无名管道时半双工的，就是对于一个管道来讲，只能读或者写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无名管道只能在相关、有共同祖先的进程间使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一个fork或者exec调用创建的子进程继承了父进程的文件描述符&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1,打开和关闭管道&lt;br /&gt;
int pipe(int filedes[2]);&lt;br /&gt;
//在你从一个管道中读写，管道必须存在&lt;br /&gt;
//如果成功建立管道，则会打开两个文件描述符，并把它们的值保存在一个数值&lt;br /&gt;
//第一个文件描述符用于读数据，第二个文件描述符用于写数据&lt;br /&gt;
//出错返回-1，同时设置errno&lt;br /&gt;
//关闭一个管道用close()函数&lt;br /&gt;
//不能两端进行读写&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;读写无名管道例子&lt;/em&gt;/&lt;br /&gt;
int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int fd[2];//管道描述符
char buf[100];//存放管道收发数据
int len;//记录长度
pipe(fd);
memset(buf,0,sizeof(buf));//清空buf
int pid = fork();
if(pid == 0)
{
close(fd[1]);//关闭写管道
while(len = read(fd[0],buf,sizeof(buf) &amp;gt;0)//len大于
{
write(STDOUT_FIFLNO,buf,len);
}
close(fd[0]);
}
else
{
close(fd[0]);//关闭读管道
strcpy(buf,&amp;quot;hello world\n&amp;quot;);
write(fd[1],buf,sizeof(buf));
close(fd[1]);
waitpid(pid,NULL,0);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;二、有名管道(FIFO)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有名管道是持久稳定的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;它们存在于文件系统中&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可以让无关联的进程之间通信&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1,用shell命令建立有名管道mkfifo [option] name&lt;br /&gt;
#mkfifo fifo1 //创建一个有名管道&lt;br /&gt;
#cat &amp;lt; fifo1 //通过cat向管道读取数据&lt;br /&gt;
#ls &amp;gt; fifo1 //通过ls向管道输出数据&lt;/p&gt;
&lt;p&gt;2,函数创建FIFO&lt;br /&gt;
int mkfifo(const char *pathname,mode_t mode)&lt;br /&gt;
//函数执行成功返回0，否则返回-1，并设置变量errno&lt;br /&gt;
int unlink(const char*pathname)&lt;br /&gt;
//删除fifo文件，执行成功返回0，否则返回-1，并设置变量errno&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
mkfifo(&amp;quot;fifo1&amp;quot;,0666);
//mode:rw-rw-rw为权限
unlink(&amp;quot;fifo1&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3,读写FIFO文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//读FIFO例子
int main()
{
int len = 0;
char buf[100];
memset(buf,0,sizeof(buf));
int fd = open(&amp;quot;fifo1&amp;quot;,O_RDONLY);//只读方式
while(len = read(fd[0],buf,sizeof(buf) &amp;gt;0)
{
printf(&amp;quot;%s&amp;quot;,buf);
memset(buf,0,sizeof(buf));
}
close(fd);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//写FIFO例子
int main()
{
char buf[100];
memset(buf,0,sizeof(buf));
int fd = open(&amp;quot;fifo1&amp;quot;,O_WRONLY);//只写方式
while(1)
{
read(STDIN_FIFLNO,buf,sizeof(buf));
if(buf[0] == &#39;0&#39;)//如果输入字符0，退出循环
break;
write(fd,buf,strlen(buf));
memset(buf,0,sizeof(buf));
}
close(fd);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4,共享内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享内存是内核处于在多个进程之间交换&lt;br /&gt;
信息二留出的一块内存区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果段的权限设置恰当，每个要访问该段&lt;br /&gt;
内存的进程都可以把它映像到自己的私有空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果一个进程更新了段中的数据，其他进程也&lt;br /&gt;
会立即看到更新&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;由一个进程创建的段，也可以由另一个进程读写&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个进程都把自己对共享进程内存的映像放到自&lt;br /&gt;
己的内存空间&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1)创建共享内存区&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/shm.h&amp;gt;
int shmget(key_t key,size_t size,int shm_flg);
//参数key既可以是IPC_PRIVATE,也可以是ftok函数返回的一个关键字
//参数size指定段的大小。
//参数flag：八进制数，0XXX。转化为二进制权限
//shmget成功返回段标示符，失败返回-1。
int shmctl(id, IPC_RMID, 0);
//删除共享内存的函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/&lt;em&gt;创建共享内存区&lt;/em&gt;/&lt;br /&gt;
int main()&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int shmid = shmget (IPC_PRIVATE,1024,0666);
if(shmid &amp;lt; 0)
printf (&amp;quot;error\n&amp;quot;);
else
printf (&amp;quot;success\n&amp;quot;);
return 0;
//在命令行执行ipcs -m 显示成功创建的共享内存信息
//nattch：已经附加到这个内存的进程数
//在命令行执行ipcrm shm shmid 删除共享内存
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;2)附加共享内存区&lt;br /&gt;
void *shmat (int shmid,const void *shmaddr,int shmfg );&lt;br /&gt;
//参数shmid是要附加的共享内存标示符&lt;br /&gt;
//总是把参数shmaddr设置为0&lt;br /&gt;
//参数shmflg可以为SHM_RDONLY，这意味着附加段是只读&lt;br /&gt;
//shmat成功返回被附加了段的地址，失败返回-1，并设置变量errno&lt;br /&gt;
int shmdt (const void *shmaddr );&lt;br /&gt;
//函数shmdt将附加在shmaddr的段从调用进程的地址空间分离出去，这个地址必须shmat返回&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;附加，释放共享内存区&lt;/em&gt;/&lt;br /&gt;
int main(int argc,char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char* shmbuf;
int shmid = 0;
if(arg &amp;gt; 1)
{
shmid = atoi(args[1]);//传入共享内存id
shmbuf = shmat(shmid,0,0);
sleep(60);
shmdt(shmbuf);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3)读写共享内存区&lt;br /&gt;
/&lt;em&gt;附加，释放共享内存区&lt;/em&gt;/&lt;br /&gt;
int main(int argc,char *args[])&lt;br /&gt;
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;char* shmbuf;
int shmid = 0;
if(arg &amp;gt; 2)
{
shmid = atoi(args[1]);//传入共享内存id
shmbuf = shmat(shmid,0,0);
if (atoi(args[2] == 1))//write shared mem
{
scanf (&amp;quot;%s\n&amp;quot;,shmbuf);
}
if(atoi(args[2] == 2)//read shared mem
{
printf (&amp;quot;%s\n&amp;quot;,shmbuf);
}
shmdt(shmbuf);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;</description></item><item><title>linux system libso</title><link>/language/linux-system/linux-system-libso/</link><pubDate>Tue, 23 Jun 2020 19:17:04 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-libso/</guid><description>&lt;p&gt;###so库简介&lt;/p&gt;
&lt;p&gt;so文件在linux中为共享库，与windows下的dll文件类似&lt;br /&gt;
so文件中的函数可以供多个进程调用，最大可能的提供二进制代码的复用&lt;br /&gt;
共享库可以使代码维护工作大大简化&lt;br /&gt;
so文件不可实现两进程的通信&lt;/p&gt;
&lt;p&gt;###1,so文件编译方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;so文件的源文件不需要由main函数，即使有也不会被加载。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;编译的时候gcc需要加-fPIC选项，这可以使gcc产生与位置无关的代码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;链接的时候gcc使用-shared选项，指示生成一个共享库文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;共享库文件名要以lib开头，拓展名为.so&lt;br /&gt;
```mkf&lt;br /&gt;
/&lt;em&gt;makefile生成共享库&lt;/em&gt;/&lt;br /&gt;
.SUFFIXES: .cpp .o&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CC=g++&lt;/p&gt;
&lt;p&gt;SRCS=test.c&lt;/p&gt;
&lt;p&gt;OBJS=$(SRCS:.cpp=.o)&lt;br /&gt;
EXEC=libtest.so&lt;/p&gt;
&lt;p&gt;all: $(OBJS)&lt;br /&gt;
$(CC) -shared -o $(EXEC) $(OBJS)&lt;br /&gt;
@echo &#39;-------------ok--------------&#39;&lt;/p&gt;
&lt;p&gt;.cpp.o:&lt;br /&gt;
$(CC) -Wall -g -fPIC -o $@ -c $&amp;lt;&lt;/p&gt;
&lt;p&gt;clean:&lt;br /&gt;
rm -f $(OBJS)&lt;br /&gt;
rm -f core*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
###2,so文件的使用方法
- 在.bash_profile中添加：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.
- 或者将so文件放在linux的系统目录下
- 在c文件中使用so文件，首先要#include相关.h文件
- gcc链接时添加-L参数指明so文件存放路径，-l参数指明so文件名
/*例子：gcc -L. -ltest -o a a.o*/
```mkf
/*makefile编译使用so的程序*/
.SUFFIXES: .cpp .o
CC=g++
SRCS=a.c
OBJS=$(SRCS:.cpp=.o)
EXEC=a
all: $(OBJS)
$(CC) gcc -L. -ltest -o $(EXEC) $(OBJS)
@echo &#39;-------------ok--------------&#39;
.cpp.o:
$(CC) -Wall -g -o $@ -c $&amp;lt;
clean:
rm -f $(OBJS)
rm -f core*
```c
####c和cpp混合编译
当使用g++编译cpp文件使用gcc生成的so共享库的时候
- 可以把函数加上extern &amp;quot;C&amp;quot; int max(int a,int b);
- 也可以在.h中增加带有__cplusplus的预编译指令，解决混合编程
```c
/*头文件例子*/
#ifndef TEST_H_
#define TEST_H_
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
int max(int a,int b);
int add(int a,int b);
#ifdef __cplusplus
}
#endif
#endif/*TEST_H_*/
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>linux system pthread</title><link>/language/linux-system/linux-system-pthread/</link><pubDate>Tue, 23 Jun 2020 19:16:30 CST</pubDate><author>rinetd</author><guid>/language/linux-system/linux-system-pthread/</guid><description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;一 什么是线程?
- 进程执行的最小单元是线程,被称为轻量级进程(LightWeight Process,LWP)
- 单线程的进程可以简单认为是只有一个线程的进程
- 一个进程在同一时间可以做一件事,有了多线程后一个进程同一时间做很多件事情
- 无论系统有几个cpu,多线程都可以使进程并发处理多个事务
- 一个线程阻塞并不会影响到另一个线程
- 多线程的进程可以尽可能的利用系统cpu系统
- 有几个线程就有几个栈空间
- 进程内所有信息对于线程都是共享的,包括执行代码.全局变量,堆栈内存以及文件描述符
二 线程的标识
- 线程有自己的ID
- 线程ID 用pthread_t 表示, 不能把pthread_t当整数处理
- 线程可以通过pthread_self()函数获得自身的线程ID
线程调用
1)线程创建
- 在进程中只有一个控制线程
- 程序开始运行的时候每个进程只有一个线程,它是以单线程方式启动
的,在创建多线程以前,进程的运行方式和传统无区别
- gcc在链接的时候需要增加 -pthread选项
- 创建一个线程调用pthread_created函数
#include &amp;lt;pthread.h&amp;gt;
int pthread_created (pthread_t * thread,const pthread_attr_t *attr,
void *(*start_routine)(void *),void *arg);
//如果pthread返回成功,由参数thread指向的内存单元被设置为新创建进程的线程
//attr参数用于定制各种不同的线程属性
//新创建的线程从start_rtn函数地址开始执行,该函数只有一个
void *参数,如果需要向start_rtn函数传递多个参数.就需要把这些参数放到一个结构中
,然后把这个结构的地址作为void*传入
//线程创建的时候不能保证哪个先运行
//pthread函数成功返回0
//参数arg用来区别线程,或者生成好多相同的线程
/*创建线程*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthtead.h&amp;gt;
void *func(void *arg)//线程入口函数
{
return NULL;
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
pthread_t thrd;
if (pthread_created(&amp;amp;thrd,NULL,func,NULL) != 0)//四个参数两个必填
{
printf(&amp;quot;error is %s&amp;quot;,strerror(errno));
}
}
2)线程终止
- 任一线程调用了exit函数,整个进程就会终止
- 如果信号默认动作是终止进程,那么信号发送到该进程,整个进程也会被终止
- 单个线程通过以下三种方式退出:
1, 线程从启动函数中返回,返回值是退出线程码
2, 线程可以被同一进程中的其他线程取消
3, 线程调用pthread_exit(NULL);
void pthread_exit(void *arg)
//arg是个无类型的指针,该指针会被其他线程调用pthread_join捕捉
/*创建多个相同线程*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthtead.h&amp;gt;
void *func(void *arg)//线程入口函数
{
int *p = (int *)arg;
int i = *p;
free(p);
printf(&amp;quot;pthread start %d\n&amp;quot;,i);
while(1)
{
printf(&amp;quot;pthread %d\n&amp;quot;,i);
}
printf(&amp;quot;pthread end %d\n&amp;quot;,i);
return NULL;
}
void createthr()
{
pthread_t thrd1,thrd2;
int *i1 = malloc(sizeof(int));//暂时不能释放i1,所以在堆上分配内存
int *i2 = malloc(sizeof(int));//或者static int i2也可以
*i1 = 1; *i2 = 2;
if (pthread_created(&amp;amp;thrd1,NULL,func,i1) != 0)//四个参数两个必填
{
printf(&amp;quot;error is %s&amp;quot;,strerror(errno));
}
if (pthread_created(&amp;amp;thrd2,NULL,func,i2) != 0)
{
printf(&amp;quot;error is %s&amp;quot;,strerror(errno));
}
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
createthr();
while(1)
{
sleep(1);
}
return EXIT_SUCCESS;
}
3)线程捕获
int pthread_join (pthread_t th,void **thr_return)
//pthread_join函数用于挂起当前线程,直至th指点的线程终止为止
//如果一个线程的返回值不是NULL,则保存在thr_return地址中
//一个线程所使用的内存资源在应用pthread_join调用之前不会重新分配,
所以对于每个线程必须调用一次pthread_join函数
//其他线程不能对同一线程再应用pthread_join函数
/*创建多个相同线程,以及返回值的处理*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthtead.h&amp;gt;
void *test(void *arg)
{
int *a = malloc(sizeof(int));
*a = 100;
pthread_exit((void *)a);//或者return a;
}
void *func(void *arg)//线程入口函数
{
int *p = (int *)arg;
int i = *p;
free(p);
printf(&amp;quot;pthread start %d\n&amp;quot;,i);
printf(&amp;quot;pthread %d\n&amp;quot;,i);
printf(&amp;quot;pthread end %d\n&amp;quot;,i);
if(i == 2)
{
test();
}
return NULL;
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
pthread_t thrd1,thrd2;
int *i1 = malloc(sizeof(int));//暂时不能释放i1,所以在堆上分配内存
int *i2 = malloc(sizeof(int));//或者static int i2也可以
*i1 = 1; *i2 = 2;
if (pthread_created(&amp;amp;thrd1,NULL,func,i1) != 0)//四个参数两个必填
{
printf(&amp;quot;error is %s&amp;quot;,strerror(errno));
}
if (pthread_created(&amp;amp;thrd2,NULL,func,i2) != 0)
{
printf(&amp;quot;error is %s&amp;quot;,strerror(errno));
}
pthread_join(thrd1,NULL);//主线程挂起,等待thrd1退出
int *p = NULL;
pthread_join(thrd2,(void **)&amp;amp;p)//第二个参数取得返回值
printf(&amp;quot;p = %d\n&amp;quot;,*p);
printf(&amp;quot;main end\n&amp;quot;);
return EXIT_SUCCESS;
}
4)线程的被分离状态
int pthread_detach(pthread_t th)
//pthread_detach函数使得线程处于被分离状态
//对于被分离状态的线程,不需要调用pthread_join,如果对其他线程对其调用pthread_join
会失败,并返回EINVAL
//如果不等待一个线程,同时对线程的返回值不感兴趣,可以设置这个线程为被分离状态,
让系统在线程退出时候自动回收它所占用的资源
//一个线程不能自己调用pthread_detach改变自己为被分离状态,只能由其他线程调用
pthread_detach函数
/*设置可分离状态*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthtead.h&amp;gt;
void *func(void *arg)//线程入口函数
{
printf(&amp;quot;pthread start \n&amp;quot;);
printf(&amp;quot;pthread end \n&amp;quot;);
pthread_exit(NULL);
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
pthread_t thrd;
pthread_created(&amp;amp;thrd1,NULL,func,NULL)
pthread_detach(thrd);
sleep(1);
return EXIT_SUCCESS;
}
/*
一旦线程成为可分离线程之后，就不能再使用pthread_join了
可分离线程的使用场景
1、主线程不需要等待子线程
2、主线程不关心子线程的返回码
*/
5)在另一个进程中终止一个线程
int pthread_cancel(pthread_t th);
//pthread_cansel函数允许一个线程取消th指定的另一个线程
//函数成功,返回0,否则返回非0
/*在另一个进程中终止一个线程代码*/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthtead.h&amp;gt;
void *func1(void *arg)//线程入口函数
{
printf(&amp;quot;pthread start \n&amp;quot;);
while(1)
{
printf(&amp;quot;pthread living\n&amp;quot;);
sleep(1);
}
printf(&amp;quot;pthread end \n&amp;quot;);
pthread_exit(NULL);
}
void *func2(void *arg)//线程入口函数
{
sleep(5);
pthread_t thr;
thr = *(pthread_t *)arg;
pthread_cancel(thr);
return (NULL);
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
pthread_t thrd1,thrd2;
pthread_created(&amp;amp;thrd1,NULL,func1,NULL);
pthread_created(&amp;amp;thrd2,NULL,func2,&amp;amp;thrd1);
pthread_join(thrd1,NULL);
pthread_join(thrd2,NULL);
printf(&amp;quot;main end\n&amp;quot;);
return EXIT_SUCCESS;
}
6)判断两个线程是否相等*/
int pthread_equal(pthread_t th1,pthread_t th2);
//pthread_equal函数比较th1和th2是否为同一个线程,由于不可以
将pthread数据类型认为是整数,所以不能用整数的方式去比较
//如果th1与th2相同,函数返回非0值;如果不同,函数返回0
7)线程属性
- 以前调用pthread_created传入的attr参数都是空指针,而不是指向pthread_attr_t结构的指针
- 可以使用pthread_attr_t结构修改线程的默认属性,并把这些属性于创建的线程联系起来
- 可以使用pthread_attr_init函数初始化pthread_attr_t结构
- 调用pthread_attr_init后,pthread_attr_t结构所包含的内容就是操作系统实现支持线程的默认
值.如果要修改其中个别属性的值,需要调用其他函数
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_init(pthread_attr_t *attr);
//函数pthread_attr_init初始化attr结构
//函数pthread_attr_destroy释放attr内存空间
//pthread_attr_t的结构对于应用程序来讲是不透明的,应用程序不需要了解有关结构的内部
//可以通过pthread_attr_t属性在创建线程时就指定线程detach,而不用使用pthread_detach函数
int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate)
//函数pthread_attr_setdetachstate把线程属性设置为下面两个合法值之一
值 说明
PTHREAD_CREATE_DETACHED 设置线程为分离状态
PTHREAD_CREATE_JOINABLE 设置线程为正常状态
/*调整属性示例代码*/
void *func(void *arg)
{
printf(&amp;quot;pthread start\n&amp;quot;);
while(1)
{
printf(&amp;quot;thread is running\n&amp;quot;);
sleep(1);
}
pthread_exit(NULL);
}
int main()//控制线程(主线程),main函数退出,所有线程退出
{
pthread_t thrd;
pthread_attr_t attr;
pthread_attr_init(&amp;amp;attr);
pthread_attr_setdetachstate(&amp;amp;attr,PTHREAD_CREATE_DETACHED);
pthread_created(&amp;amp;thrd,&amp;amp;attr,func,NULL);
pthread_attr_destroy(&amp;amp;attr);
sleep(2);
printf(&amp;quot;main end\n&amp;quot;);
return EXIT_SUCCESS;
}
三 线程同步技术
- 互斥(mutex)是相互排斥的意思,它是一种锁或者信号灯
- 互斥用来保护多个线程共享数据和结构不会被同时修改
一个互斥锁只能有两个状态:locked和unlocked
- 加锁后互斥不让其他线程访问
- 任何时刻只能有一个线程来掌握某个互斥上锁
- 一个线程如果试图在一个已经加锁的互斥上再加锁,这个线程会挂起,
知道加锁的线程释放掉互斥锁为止
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
//PTHREAD_MUTEX_INITIALIZER 是初始化一个加速锁的宏定义
//pthread_mutex_lock用于给mutex加锁
//pthread_mutex_unlock用于给mutex解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
//检测是否锁
//最恰当的互斥用法
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//初始化了一个MUTEX锁
int count = 0;
void *func1(void *arg)
{
int *a = (int *) arg;
printf(&amp;quot;thread%d start\n&amp;quot;, *a);
int i;
for (i = 0; i &amp;lt; 10; i++)
{
printf(&amp;quot;thread%d is running\n&amp;quot;, *a);
sleep(1);
pthread_mutex_lock(&amp;amp;mutex);//给mutex加锁,这是一条原子操作，不可能出现两个线程同时执行这个代码
count++;//这段代码受到保护，永远只有一个线程可以操作
pthread_mutex_unlock(&amp;amp;mutex);//给mutex解锁
}
printf(&amp;quot;thread%d end\n&amp;quot;, *a);
pthread_exit(NULL);
}
int main(int arg, char * args[])
{
printf(&amp;quot;process start\n&amp;quot;);
pthread_t thr_d1, thr_d2;
int i[2];
i[0] = 1;
i[1] = 2;
pthread_create(&amp;amp;thr_d1, NULL, func1, &amp;amp;i[0]);
pthread_create(&amp;amp;thr_d2, NULL, func1, &amp;amp;i[1]);
pthread_join(thr_d1, NULL);
pthread_join(thr_d2, NULL);
printf(&amp;quot;process end\n&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>