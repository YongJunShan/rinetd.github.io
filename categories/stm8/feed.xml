<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>stm8 on 时光小栈</title><link>/categories/stm8/</link><description>Recent content in stm8 on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Tue, 30 Jun 2020 15:18:52 +0800</lastBuildDate><atom:link href="/categories/stm8/feed.xml" rel="self" type="application/rss+xml"/><item><title>STM8L151G6U6 之实现低功耗</title><link>/hardware/stm8/stm-rtc/</link><pubDate>Tue, 30 Jun 2020 15:18:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm-rtc/</guid><description>STM8L051F3P6 STM8L151G6U6 之实现低功耗 所谓低功耗产品，一般来讲就是在大多数时间让MCU进入睡眠模式，在有数据更新时唤醒，将数据显示或者发送上报。对于中断类型的，可</description></item><item><title>stm8 halt</title><link>/hardware/stm8/stm8-halt/</link><pubDate>Thu, 23 Apr 2020 17:53:28 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-halt/</guid><description>如果你象其它单片机一样，开启了AWU,然后来一句halt(); 那么此时的电流为200uA左右，到此差不多心灰意冷，STM8S这么差劲儿！ 仔细</description></item><item><title>stm8 awu</title><link>/hardware/stm8/stm8-awu/</link><pubDate>Thu, 23 Apr 2020 15:34:24 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-awu/</guid><description>#include &amp;quot;awu.h&amp;quot; #include &amp;lt;stm8s.h&amp;gt; /* * Enable auto wake up */ void awu_enable() { // Timebase 0b1011 (512 ms - 1.024 s) AWU_TBR = 0x0B; // Prescaler 62 (with 1011 timebase -&amp;gt; 0,496 s) AWU_APR = 0x3E; // Enable the auto wake up feature AWU_CSR = AWU_CSR | (1 &amp;lt;&amp;lt; AWU_CSR_AWUEN); } void awu_disable() { // Disable the auto wake up feature AWU_CSR = AWU_CSR | (0 &amp;lt;&amp;lt; AWU_CSR_AWUEN); AWU_TBR = 0; } void active_halt() { // Switch off main regulator during halt mode CLK_ICKR = CLK_ICKR | (1 &amp;lt;&amp;lt; CLK_ICKR_REGAH); // Power down flash during halt mode FLASH_CR1 = FLASH_CR1 | (1 &amp;lt;&amp;lt; FLASH_CR1_AHALT); // Halt instruction halt(); }</description></item><item><title>输电线路在线监测系统应用层数据传输规约协议 DTS_for_OLMS</title><link>/hardware/stm8/stm8-dts_for_olms/</link><pubDate>Thu, 23 Apr 2020 11:10:16 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-dts_for_olms/</guid><description>Data transportation specification for on-line monitoring system on overhead transmission lines kex2017/DTS_for_OLMS: Data transportation specification for on-line monitoring system on overhead transmission lines</description></item><item><title>stm8 GPIO_interrupt</title><link>/hardware/stm8/stm8-gpio_interrupt/</link><pubDate>Wed, 22 Apr 2020 19:51:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-gpio_interrupt/</guid><description>STM8S---外部中断应用之长按键识别 - mthoutai - 博客园 void buttons_set_handler(void) __interrupt( INTERRUPT_TLI) { if(setpt == PT_NONE) { setpt = PT_DOWN; setdown = buttons_gettime(); } } void buttons_on_handler(void) __interrupt(INTERRUPT_EXTI3) { if(onpt == PT_NONE) { onpt = PT_DOWN; ondown = buttons_gettime(); } } void buttons_init(void) { const uint8_t mask = (1 &amp;lt;&amp;lt; 3) |</description></item><item><title>stm8 timer</title><link>/hardware/stm8/stm8-timer/</link><pubDate>Wed, 22 Apr 2020 16:26:52 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-timer/</guid><description>Timer1 /*定时时间 = (TIM1_ARRL + 1) * 10ms */ void Timer1_init(void) { CLK_PCKENR1 |= 0x80; //打开TIM1时钟 = Fmaster = 2MHz asm(&amp;quot;sim&amp;quot;); // 关全局中断 TIM1_PSCRH = 0x4E; TIM1_PSCRL = 0x20; //时钟20000分频，2MHz/20000 =</description></item><item><title>stm8 uart</title><link>/hardware/stm8/stm8-uart/</link><pubDate>Wed, 22 Apr 2020 13:59:41 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-uart/</guid><description/></item><item><title>stm8 print</title><link>/hardware/stm8/stm8-print/</link><pubDate>Wed, 18 Mar 2020 17:42:19 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-print/</guid><description>然后就是重写fputc函数，使之定向到指定的串口中去。代码如下： /* ** Rewrite fputc function and make printf function work */ int fputc(int ch, FILE file) { USART1-&amp;gt;TDR = ch &amp;amp; 0xFF; while((USART1-&amp;gt;ISR &amp;amp; UART_FLAG_TC) == RESET); return ch; } 在该例中使用的U</description></item><item><title>stm8 adc</title><link>/hardware/stm8/stm8-adc/</link><pubDate>Tue, 17 Mar 2020 16:13:32 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/hardware/stm8/stm8-adc/</guid><description>void InitADC(void) { //PD6 set as FloatingInput PD_DDR &amp;amp;= 0xBF;//1011 1111 PD_CR1 &amp;amp;= 0xBF; PD_CR2 &amp;amp;= 0xBF; ADC_CR1 = 0x01;//first time open ADC£¬second time convert ADC data ADC_CSR = 0X06;//choose channel AIN6 ADC_CR2 = 0X00;//left arrange (default) } unsigned int GetADC(void) { volatile unsigned int adcValue; volatile unsigned char tmp = 100; ADC_CR1 |= 0x01;//first time open ADC while(tmp--); ADC_CR1</description></item></channel></rss>