<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clang on 时光小栈</title><link>/categories/clang/</link><description>Recent content in clang on 时光小栈</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><managingEditor>rinetd@163.com (rinetd)</managingEditor><webMaster>rinetd@163.com (rinetd)</webMaster><copyright>Copyright (c) 2017. All rights reserved. (版权所有) &lt;a href=&#39;http://www.miitbeian.gov.cn/&#39;&gt;鲁ICP备17074587号-1&lt;/a&gt;</copyright><lastBuildDate>Tue, 17 Mar 2020 14:31:44 +0800</lastBuildDate><atom:link href="/categories/clang/feed.xml" rel="self" type="application/rss+xml"/><item><title>clang setbit clearbit</title><link>/language/clang/clang-setbit-clearbit/</link><pubDate>Tue, 17 Mar 2020 14:31:44 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-setbit-clearbit/</guid><description>/include/linux/bitops.h
#define SET_BIT(x, n) (x |= (1 &amp;lt;&amp;lt; n)) #define CLR_BIT(x, n) (x &amp;amp;= ~(1 &amp;lt;&amp;lt; n)) #define GET_BIT(x, n) ((x &amp;gt;&amp;gt; n) &amp;amp; 0x01) #define set_bit(register_8, bit) (register_8 |= (1 &amp;lt;&amp;lt; bit)) #define clear_bit(register_8, bit) (register_8 &amp;amp;= ~(1 &amp;lt;&amp;lt; bit)) #define toggle_bit(register_8, bit) (register_8 ^= (1 &amp;lt;&amp;lt; bit)) #define set_bit(reg,bit) reg|=(1&amp;lt;&amp;lt;bit) //pondra en 1 el bit elegido de la variable elegida. #define clr_bit(reg,bit) reg&amp;amp;=~(1&amp;lt;&amp;lt;bit) //pondra en 0 el bit elegido de la variable elegida.</description></item><item><title>glibc printf</title><link>/language/clang/glibc-printf/</link><pubDate>Sat, 22 Feb 2020 11:25:31 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/glibc-printf/</guid><description>printf 打印指定长度字符串 转载rusty_knife 最后发布于2018-05-15 11:36:44 阅读数 4682 收藏 展开 1.原样输出字符串: printf(&amp;quot;%s&amp;quot;, str); 输出指定长度的字符串,</description></item><item><title>Linux驱动中的 wait_event_interruptible 与 wake_up_interruptible 深度理解</title><link>/language/clang/linux-wait_event_interruptible/</link><pubDate>Tue, 11 Feb 2020 11:44:43 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-wait_event_interruptible/</guid><description>linux字符驱动之中断按键_lwj103862095的专栏-CSDN博客 等待队列： 在 Linux 驱动程序设计中，可以使用等待队列来实现进程的阻塞. 等</description></item><item><title>linux c crypto</title><link>/language/clang/linux-c-crypto/</link><pubDate>Wed, 05 Feb 2020 19:14:22 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-crypto/</guid><description>https://gist.github.com/neikeq/d6d00bd24db606dd0b86
#ifndef _DEFINE_H_ #define _DEFINE_H_ #define OK 0 #define NOK -1 #define YES 1 #define NO 0 #define MAX_SERVER 50 #define MAX_PLAYER 500 #define MAX_ROOM 150 #define MAX_TEAM 150 #define MAX_VIEWER 4 #define MAX_ATHLETE 10 #define MAX_ITEM 70 #define MAX_LEVEL 50 #define MAX_LEVEL_SECTION (MAX_LEVEL/5)+1 #define MAX_TIP 50 #define MAX_MISSION 46 #define MAX_HOLIDAY 50 #define MAX_CARDSKILL 3 #define MAX_CARDRANK 4 #define MAX_BUDDY 30 #define MAX_BLACKLIST 30 #define EMBLEM_TYPE_GOLD 604101101 #define EMBLEM_TYPE_SILVER 604101102 #define MAX_PATH 255 #define GAME_PLAY_TIME 300 #define ID_NAME_SIZE (15 * 2) + 1 #define PLAYER_NAME_SIZE (7 * 2) + 1 #define OBJECT_NAME_SIZE (20 * 2) + 1 #define SERVER_NAME_SIZE (15 * 2) + 1 #define TITLE_NAME_SIZE (23 * 2) + 1 #define CLUB_NAME_SIZE (10 * 2) + 1 #define PLAYER_MENT_SIZE (22 * 2) + 1 #define MESSAGE_SIZE (40 * 2) + 1 #define PASS_SIZE (10 * 2) + 1 #define LOGIN_PASS_SIZE (32 * 2) + 1 #define TIP_SIZE (60 * 2) + 1 #define MISSTION_TEXT_SIZE (60 * 2) + 1 #define MAX_MUSIC_COUNT 3 #define MAX_EQUIP 17 #define MAX_FACULTY 130 #define MAX_CHARACTER 3 #define MAX_INVEN 80 #define MAX_SKILL 50 #define MAX_CEREMONY 5 #define MAX_CARD 100 #define MAX_SCHEDULE_LIST 10 #define MAX_BUDDY_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_ITEM_LIST 10 #define MAX_TRAINING_LIST 10 #define MAX_CEREMONEY_LIST 5 #define MAX_SKILL_LIST 50 #define MAX_QUEST_LIST 10 #define MAX_CARD_LIST 30 #define PACKET_SIZE 2048 #define HEAD_SIZE (int)sizeof(Header) #define IP_SIZE 20 #define TEAM_SIZE 6 #define ITEM_OPTION_SIZE 5 #define SLOT_SIZE 4 #define BASE_CHARACTER_SIZE 1 #define BASE_INVEN_SIZE 20 #define BASE_SKILL_SIZE 8 #define ITEM1_MIX_SIZE 5 #define ITEM2_MIX_SIZE 5 #define CARD_MIX_SIZE 12 #define LIST5_SIZE 5 #define LIST6_SIZE 6 #define LIST8_SIZE 8 #define LIST10_SIZE 10 #define TEAM_SIZE 6 #define SHOP_BIT_EXIST 0 #define SHOP_BIT_NONE 1 #define ITEM_FACE 100 #define ITEM_HAIR 101 #define ITEM_SHIRTS 102 #define ITEM_PANTS 103 #define ITEM_GLOVE 104 #define ITEM_SHOES 105 #define ITEM_DIGIT 1000000 #define OPTION_DIGIT 100000 #define POSITION_NONE 0 #define POSITION_ALL 1 #define POSITION_FW 10 #define POSITION_ST 11 #define POSITION_CF 12 #define POSITION_WF 13 #define POSITION_SS 14 #define POSITION_FW_RANGE 4 #define POSITION_MF 20 #define POSITION_AM 21 #define POSITION_CM 22 #define POSITION_SM 23 #define POSITION_DM 24 #define POSITION_MF_RANGE 4 #define POSITION_DF 30 #define POSITION_SW 31 #define POSITION_CB 32 #define POSITION_SB 33 #define POSITION_DF_RANGE 3 #define POSITION_GK 40 #define POSITION_BG 50 #define AUTO_FACULTY_LEVEL1 10 #define AUTO_FACULTY_LEVEL2 20 #define MAX_AI_COSTUME 61 #define PC_EXIT01 1 #define PC_EXIT02 2 #define PC_EXIT03 3 #define PC_EXIT04 4 #define PC_EXIT11 11 #define PC_EXIT12 12 #define PC_EXIT20 20 #define PC_EXIT21 21 #define PC_EXIT22 22 #define PC_EXIT30 30 #define PC_EXIT31 31 #define PC_EXIT32 32 #define PC_EXIT33 33 #define PC_EXIT90 90 #define ROOT2 1.</description></item><item><title>pthread 使用入门</title><link>/language/clang/linux-c-pthread/</link><pubDate>Wed, 05 Feb 2020 17:15:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-c-pthread/</guid><description>POSIX 线程（POSIX threads），简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类 Unix 操作系统（Unix</description></item><item><title>linux fopen open</title><link>/language/clang/linux-fdopen-fileno/</link><pubDate>Thu, 19 Dec 2019 14:17:10 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fdopen-fileno/</guid><description>每天进步一点点——Linux中的文件描述符与打开文件之间的关系_linux,文件描述符_Cynric 的博客-CSDN博客 1. 来源 从来源的角度看</description></item><item><title>linux mmap</title><link>/language/clang/linux-mmap/</link><pubDate>Thu, 19 Dec 2019 13:41:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-mmap/</guid><description>由于在应用层没法用writel，所以参考himm.c写了一个设置，代码如下： void uart1_rtsn_high(void) { void * pMem = NULL; pMem = memmap(0x201d0010, DEFAULT_MD_LEN); (U32)pMem = 0xff; } 文件名是rs485.c —————</description></item><item><title>linux fopen fwrite fflush fsync</title><link>/language/clang/linux-fopen-fwrite-fflush-fsync/</link><pubDate>Thu, 19 Dec 2019 11:28:34 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-fopen-fwrite-fflush-fsync/</guid><description>fwrite 立即写入文件 fwrite 函数只是将所写内容存入用户缓存,并不立刻写入文件. fflush 函数将用户缓存中的内容写入内核缓冲区 fsync 函数则是将内核缓冲写入文件 fclose 则先执</description></item><item><title>Linux下头文件以及库 编译链接运行时的搜寻路径顺序</title><link>/language/clang/make-gcc-include-order/</link><pubDate>Wed, 11 Dec 2019 11:17:08 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/make-gcc-include-order/</guid><description>Linux下头文件以及库 编译链接运行时的搜寻路径顺序 - ltshan139的专栏 LIBRARY_PATH 环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路</description></item><item><title>clang define extern c</title><link>/language/clang/clang-define-extern-c/</link><pubDate>Wed, 11 Dec 2019 10:23:02 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-define-extern-c/</guid><description>extern &amp;quot;C&amp;quot; 在C/C++中的用法 无论是C++调用C api 还是C调用C++ API， 必须先在API所对应得头文件对API进行 extern &amp;quot;C&amp;quot;声明</description></item><item><title>clang 3维数组的初始化</title><link>/language/clang/clang-array/</link><pubDate>Wed, 11 Dec 2019 10:20:42 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/clang-array/</guid><description>int a[2][3][4] = { {{1,2,3,4},{1,2,3,4},{1,2,3,4}}, {{5,6,7,8},{5,6,7,8},{5,6,7,8}} }; 注意初始化要先从最外围开始。</description></item><item><title>linux string strnicmp</title><link>/language/clang/linux-string-strnicmp/</link><pubDate>Thu, 28 Nov 2019 15:06:06 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strnicmp/</guid><description>char pDescr[100] strcpy(pDescr, &amp;quot;v=0\r\n&amp;quot;); strcat(pDescr, &amp;quot;o=-&amp;quot;); strcat(pDescr, pSdpId); #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; void main() { char *input=&amp;quot;I am OldWolf&amp;quot;; char *str=&amp;quot;I am Oldwolf&amp;quot;; int cmp; printf(&amp;quot;原字符串分别为：\n%s\n%s\n\n&amp;quot;,str1,</description></item><item><title>linux string strsep</title><link>/language/clang/linux-string-strsep/</link><pubDate>Thu, 28 Nov 2019 14:40:23 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/linux-string-strsep/</guid><description>/* lib/string.c */ strsep函数用于分割字符串 该函数同strtok函数类似，用来替换strtok函数 char *strsep(char **s, const char *delim); s为指向欲分割的字符串，delim为分</description></item><item><title>c http post file</title><link>/language/clang/c-http-post-file/</link><pubDate>Fri, 15 Nov 2019 17:20:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-http-post-file/</guid><description>基于C语言实现HTTP POST 表单形式上传文件 - fangye945a的博客 - CSDN博客 all: gcc -pthread -I. http_post.c clean: rm -f a.out POST /Server/interface_picture_upload.action?appid=wmj_BZ2WeU7K1iP&amp;amp;appsecret=MXkMcT43JsIgAwBwVJ30EbA2ovIcpfCQ&amp;amp;sn=0 HTTP/1.1 Host: test.inteink.com User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:59.0) Gecko/20100101 Firefox/59.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip,</description></item><item><title>gcc</title><link>/language/clang/gcc/</link><pubDate>Thu, 23 May 2019 10:58:04 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/gcc/</guid><description>linux ldconfig命令,环境变量文件配置详解 - winycg的博客 - CSDN博客 为什么使用静态编译方式编译应用程序无法使用动态库 【现象】 客户 A</description></item><item><title>c void</title><link>/language/clang/c-void/</link><pubDate>Wed, 22 May 2019 19:17:38 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-void/</guid><description>C语言中void和NULL - ascend的专栏 - CSDN博客 #define NULL ((void *)0) void的作用 a. 对函数参数的限定：当不需要传入参数时，即 function (void); b. 对函数返回</description></item><item><title>Linux内核中的offsetof和container_of</title><link>/language/clang/c-container_of/</link><pubDate>Sat, 20 Apr 2019 09:26:47 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-container_of/</guid><description>关于list_for_each_entry相关函数 - 简书 链表是内核最经典的数据结构之一，说到链表就不得不提及内核最经典 (没有之一) 的宏con</description></item><item><title>c位操作</title><link>/language/clang/c-bit-operate/</link><pubDate>Fri, 19 Apr 2019 16:29:17 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-bit-operate/</guid><description>bitops.h 位运算技巧 记得iOS总有一道面试题在不使用第三个变量的情况下交换两个变量的值，这里用到异或的上面加解密中的特性。我有x、y两个个变量，做如</description></item><item><title>c语言define的使用方法总结</title><link>/language/clang/c-define/</link><pubDate>Fri, 19 Apr 2019 11:13:07 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-define/</guid><description>#和##有什么区别？ 他们都不会将参数进行展开 1. # 的作用是将宏定义中的参数转换成“字符串” #define STR(x) #x =&amp;gt; a=1; STR(a) &amp;quot;a&amp;quot; 2. ##的作用是将宏定义中的参数变成字符</description></item><item><title>C语言中的指针</title><link>/language/clang/c-point/</link><pubDate>Sat, 13 Apr 2019 10:15:58 +0800</pubDate><author>rinetd@163.com (rinetd)</author><guid>/language/clang/c-point/</guid><description>二级指针传参数 - 简书 说透一级指针和二级指以及(void)&amp;amp;在双链表中的应用 注意char*是字符串指针，需要改变其对应的变量必须用地址</description></item></channel></rss>